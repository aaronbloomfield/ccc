<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' lang='' xml:lang=''>
<head>
  <meta charset='utf-8'></meta>
  <meta name='generator' content='pandoc'></meta>
  <meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=yes'></meta>
  <title>Arbitrage Trading</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel='stylesheet' href='../../markdown.css'></link>
  <script>
  function openTab(evt, tabName) {
    // Declare all variables
    var i, tabcontent, tablinks;

    // Get all elements with class="tabcontent" and hide them
    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i < tabcontent.length; i++) {
      tabcontent[i].style.display = "none";
    }

    // Get all elements with class="tablinks" and remove the class "active"
    tablinks = document.getElementsByClassName("tablinks");
    for (i = 0; i < tablinks.length; i++) {
      tablinks[i].className = tablinks[i].className.replace(" active", "");
    }

    // Show the current tab, and add an "active" class to the button that opened the tab
    document.getElementById(tabName).style.display = "block";
    evt.currentTarget.className += " active";
  }

  function insertCopyLink(text) {
    document.write("<span class=\"copylink copy_img\" onclick=\"navigator.clipboard.writeText('" + text.replace(/\"/g,"\\'") + "')\"></span>");
  }
  </script>
</head>
<body>
<h1 id='arbitrage-trading'>Arbitrage Trading</h1>
<p><a href='../index.html'>Go up to the CCC HW page</a> (<a href='../index.md'>md</a>) | <a href='index-full.html'>view one-page version</a></p><div class='tab'>
<button class='tablinks' onclick="openTab(event,'toverview')" id='defaultOpen'>Overview</button>
<button class='tablinks' onclick="openTab(event,'tchangelog')">Changelog</button>
<button class='tablinks' onclick="openTab(event,'tweb3.py')">Web3.py</button>
<button class='tablinks' onclick="openTab(event,'tmarket-theory')">Market Theory</button>
<button class='tablinks' onclick="openTab(event,'tassignment')">Assignment</button>
<button class='tablinks' onclick="openTab(event,'ttesting')">Testing</button>
<button class='tablinks' onclick="openTab(event,'treal-world-profit')">Real World Profit</button>
<button class='tablinks' onclick="openTab(event,'tnotes-and-hints')">Notes &amp; Hints</button>
<button class='tablinks' onclick="openTab(event,'tsubmission')">Submission</button>
</div>
<div id='toverview' class='tabcontent'><h3 id='overview'>Overview</h3>
<p>In this assignment you are going to create a Python program to perform <a href='../../slides/applications.html#/arbitrage'>arbitrage trading</a> on the blockchain. Your trading will be between a number of different DEX instances from the <a href='../dex/index.html'>DEX</a> (<a href='../dex/index.md'>md</a>) assignment. This program must be written in Python in a file called <code>arbitrage_trading.py</code>. We provide a number of DEXes for you to use on the course blockchain.</p>
<p>Beyond general experience with programming Solidity (which you have at this point it the course), this assignment requires:</p>
<ul>
<li>That you completed the <a href='../dex/index.html'>DEX</a> (<a href='../dex/index.md'>md</a>) assignment. This is for understanding of how our DEXes work; your DEX does not have to be function as we will provide the DEXes.</li>
<li>That you completed the <a href='../tokens/index.html'>Ethereum Tokens</a> (<a href='../tokens/index.md'>md</a>) assignment; this is also for the understanding, and your Token Cryptocurrency does not need to be functional.</li>
<li>Familiarity with the <a href='../../slides/applications.html#/arbitrage'>arbitrage trading</a> section of the lecture slides, including the <a href='https://aaronbloomfield.github.io/ccc/slides/applications.html#/cpamm'>CPAMM</a> trading method.</li>
</ul>
<p>In addition to your source code, you will submit an edited version of <a href='arbitrage.py.html'>arbitrage.py</a> (<a href='arbitrage.py'>src</a>).</p>
</div><div id='tchangelog' class='tabcontent'><h3 id='changelog'>Changelog</h3>
<p>Any changes to this page will be put here for easy reference. Typo fixes and minor clarifications are not listed here. </p>
<ul>
<li>Sunday, November 26th: <code>estimate_gas()</code> is reporting a revert when one would not occur, so we are hard-coding the gas values:
<ul>
<li>When trading ETH for TC, use 107,000 as your gas estimate</li>
<li>When trading TC for ETH, use 117,000 as your gas estimate</li>
</ul></li>
<li>Monday, November 27th: Added the “Specific Examples” sub-section at the bottom of the “Testing” tab</li>
</ul>

</div><div id='tweb3.py' class='tabcontent'><h3 id='web3.py'>Web3.py</h3>
<p>You will need to read the <a href='../../docs/web3py.html'>introduction to web3.py</a> (<a href='../../docs/web3py.md'>md</a>). While you do not need to have all of that memorized, you do need to understand it all! The intent is that you will use that page as a reference while you write this assignment.</p>
<h4 id='connecting'>Connecting</h4>
<p>The following code will handle the connection based on the values in the <code>arbitrage_config.py</code> file, which is introduced below. After reading this part, you may want to come back to it again once the <code>arbitrage_config.py</code> file has been introduced.</p>
<pre><code>from web3 import Web3
from web3.middleware import geth_poa_middleware
import arbitrage_config
if arbitrage_config.config['connection_is_ipc']:
    w3 = Web3(Web3.IPCProvider(arbitrage_config.config['connection_uri']))
else:
    w3 = Web3(Web3.WebsocketProvider(arbitrage_config.config['connection_uri']))
w3.middleware_onion.inject(geth_poa_middleware, layer=0)
print(w3.is_connected())</code></pre>
<p>The code above will connect either through a local geth.ipc endpoint or a server’s <code>wss://</code> connection based on the values in the <code>arbitrage_config.py</code> file:</p>
<ul>
<li>If the <code>connection_is_ipc</code> value is <code>True</code>, then the <code>connection_uri</code> value will have the form <code>/path/to/geth.ipc</code></li>
<li>If the <code>connection_is_ipc</code> value is <code>False</code>, then the <code>connection_uri</code> value will have the form <code>wss://server.univeristy.edu/path/to/geth</code></li>
</ul>
<p>The value for the second one is provided on the Canvas landing page, and in the provided <code>arbitrage_config.py</code> file.</p>
</div><div id='tmarket-theory' class='tabcontent'><h3 id='market-theory'>Market Theory</h3>
<h4 id='when-to-make-an-trade'>When to make an trade</h4>
<p>Your program will need to compute it’s <em>holdings</em>, which is the dollar amount of all the ETH and TC that it has. You will use some fixed price for ETH (say, $100) and for TC (say, $10) for initial testing – this value is provided in the <code>arbitrage_config.py</code> file, which is described below.</p>
<p>You will first need to obtain the various information (prices, <span class='math inline'><em>x</em></span>/<span class='math inline'><em>y</em></span>/<span class='math inline'><em>k</em></span> values at each DEX, etc.). Then you will need to make a <em>profitable trade</em>. A profitable trade is defined here as a trade where the overall value of <em>holdings</em>, in USD, increases. You must account for gas fees when determining this! The formula to determine if you will make a profit is whether:</p>
<blockquote>
<p><span class='math inline'><em>e</em><em>t</em><em>h</em><em>A</em><em>m</em><em>o</em><em>u</em><em>n</em><em>t</em><em>A</em><em>f</em><em>t</em><em>e</em><em>r</em> * <em>e</em><em>t</em><em>h</em><em>P</em><em>r</em><em>i</em><em>c</em><em>e</em> + <em>t</em><em>c</em><em>A</em><em>m</em><em>o</em><em>u</em><em>n</em><em>t</em><em>A</em><em>f</em><em>t</em><em>e</em><em>r</em> * <em>t</em><em>c</em><em>P</em><em>r</em><em>i</em><em>c</em><em>e</em> − <em>g</em><em>a</em><em>s</em><em>F</em><em>e</em><em>e</em><em>s</em> &gt; <em>e</em><em>t</em><em>h</em><em>A</em><em>m</em><em>o</em><em>u</em><em>n</em><em>t</em><em>B</em><em>e</em><em>f</em><em>o</em><em>r</em><em>e</em> * <em>e</em><em>t</em><em>h</em><em>P</em><em>r</em><em>i</em><em>c</em><em>e</em> + <em>t</em><em>c</em><em>A</em><em>m</em><em>o</em><em>u</em><em>n</em><em>t</em><em>B</em><em>e</em><em>f</em><em>o</em><em>r</em><em>e</em> * <em>t</em><em>c</em><em>P</em><em>r</em><em>i</em><em>c</em><em>e</em></span></p>
</blockquote>
<p>The <em>gasFees</em> is just the amount Ethereum charges for a transaction; DEX fees are not part of that value (the DEX pays out less, to the two amount-after variables will be less as a result, and thus will take DEX fees into account).</p>
<p>Note: there are other reasonable ways to determine “profit”. In particular, if one believes that the price of the currency will grow, then the total amount of that currency (not the total USD value) would be another metric. For our purposes, we will just use the USD value of the holdings.</p>
<p>This formula also accounts for the DEX fees (the amount after is lower as a result of those).</p>
<p>Although the price of our (fake) ether will vary, you don’t know if it will go up or down – thus, the value for <em>ethPrice</em> should be the current price, and thus will be the same on each side of the equation above.</p>
<p>We are going to call this a <em>single trade</em>. This is when you make one transaction at a single DEX to increase your holdings.</p>

<h4 id='arbitrage-goal'>Arbitrage goal</h4>
<p>For each DEX, and for each of the two directions (ETH -&gt; TC and TC -&gt; ETH), find the (DEX,currency,amount) combination that maximizes your profit.</p>
<p>Consider the most profitable such transaction among all the available DEXes. If that transaction increases your holdings in USD, then take that action. It’s also possible that a <em>double trade</em> would yield a profit, where as a single trade would not (for example, exchanging some ETH for some TC in one DEX, and then trading that TC back for more ETH at a different DEX). We are not considering double trades for this assignment.</p>
<h4 id='how-much-to-trade'>How much to trade</h4>
<p>We can formulaically determine how much to trade. The full derivation of the formulas in this section is being omitted here, but you can see that full derivation <a href='extra.html'>here</a> (<a href='extra.md'>md</a>). First we need to define a number of variables:</p>
<ul>
<li>The DEX values are <span class='math inline'><em>x</em><sub><em>d</em></sub></span>, <span class='math inline'><em>y</em><sub><em>d</em></sub></span>, and <span class='math inline'><em>k</em><sub><em>d</em></sub></span></li>
<li>The current prices are <span class='math inline'><em>p</em><sub><em>e</em></sub></span> and <span class='math inline'><em>p</em><sub><em>t</em></sub></span>, the price of ETH and TC, respectively</li>
<li>The quantity of each that we currently have is <span class='math inline'><em>q</em><sub><em>e</em></sub></span> and <span class='math inline'><em>q</em><sub><em>t</em></sub></span>, for the quantity of ETH and TC, respectively</li>
<li>Our holdings, in USD, are <span class='math inline'><em>h</em><sub><em>b</em><em>e</em><em>f</em><em>o</em><em>r</em><em>e</em></sub></span> (our current holdings, before any potential transaction) and <span class='math inline'><em>h</em><sub><em>a</em><em>f</em><em>t</em><em>e</em><em>r</em></sub></span> (our holdings after the transaction)</li>
<li>The gas fees, computed as per the <a href='../../docs/web3py.html'>introduction to web3.py</a> (<a href='../../docs/web3py.md'>md</a>) page, are <span class='math inline'><em>g</em></span>; this is in units of ETH. Gas fees are discussed below (in the “Assignment” section). Note that this is NOT the price (in gwei) per gas step, nor the gas price in USD, but the total expected cost in ether of the transaction.</li>
<li><span class='math inline'><em>f</em></span> is the percentage (out of 1.0) obtained after the DEX fees are removed. So if <span class='math inline'><em>f</em><sub><em>n</em></sub></span> is the fee numerator (say, 3) and <span class='math inline'><em>f</em><sub><em>d</em></sub></span> is the fee denominator (say, 1000), then <span class='math inline'><em>f</em> = 1 − <em>f</em><sub><em>n</em></sub>/<em>f</em><sub><em>d</em></sub></span>. As an example, if <span class='math inline'><em>f</em><sub><em>n</em></sub> = 3</span> and <span class='math inline'><em>f</em><sub><em>d</em></sub> = 1000</span>, then <span class='math inline'><em>f</em> = 0.997</span>. Note that this fee applies to both ETH and TC transactions, but only on the amount paid out. While each DEX <em>could</em> have their own fee values, for this assignment we will assume that each DEX has the same fee amount (specified in the arbitrage_config.py file).</li>
</ul>
<p>The above values are all fixed for each time the program runs – either from the config file (described below) or by querying the DEXes. Different DEXes will have different values for <span class='math inline'><em>x</em><sub><em>d</em></sub></span>, <span class='math inline'><em>y</em><sub><em>d</em></sub></span>, and <span class='math inline'><em>k</em><sub><em>d</em></sub></span>, of course. The only values that the program chooses are the amount of ETH that we trade in (we’ll call this <span class='math inline'><em>δ</em><sub><em>e</em></sub></span>) or the amount of TC that we trade in (we’ll call this <span class='math inline'><em>δ</em><sub><em>t</em></sub></span>). As we are only considering a single trade, only one of them will be non-zero.</p>
<p>The formulas that we need are (derivations <a href='extra.html'>here</a> (<a href='extra.md'>md</a>)):</p>
<ul>
<li>Our current holdings, in USD, are:  <img src='formulas/formulas/img1.svg' class='formula'></li>
<li>If we trade in TC, then our holdings after (in USD) are:  <img src='formulas/formulas/img3.svg' class='formulabig'></li>
<li>If we trade in ETH, then our holdings after (in USD) are:  <img src='formulas/formulas/img5.svg' class='formulabig'></li>
</ul>
<p>For a single trade, want to find the maximum profit for the two <span class='math inline'><em>h</em><sub><em>a</em><em>f</em><em>t</em><em>e</em><em>r</em></sub></span> formulas <em>for each DEX</em>. We take the derivative, then set it equal to zero to find the roots (details <a href='extra.html'>here</a> (<a href='extra.md'>md</a>), if you are interested). The roots will give us the maximum and/or minimum points. This gives us:</p>
<ul>
<li>If we traded in TC, then the maxima or minima is at:  <img src='formulas/formulas/img7.svg' class='formulabig'>
<ul>
<li>Note that <span class='math inline'><em>p</em><sub><em>e</em></sub></span> is in the numerator in that fraction, and that fraction is different than the fraction in the next formula</li>
</ul></li>
<li>If we traded in ETH, then the maxima or minima is at:  <img src='formulas/formulas/img9.svg' class='formulabig'>
<ul>
<li>Note that <span class='math inline'><em>p</em><sub><em>t</em></sub></span> is in the numerator in that fraction, and that fraction is different than the fraction in the previous formula </li>
</ul></li>
</ul>
<p>A few notes on those:</p>
<ul>
<li>If you want to cut-and-paste these formulas into your program, the <a href='extra.html'>derivations page</a> (<a href='extra.md'>md</a>) has them in text form</li>
<li>Neither of these are guaranteed to make a profit! It could be that it just loses the least amount instead. But if a profit can be made, then one of those will be the maximum profit.</li>
<li>How much profit is determined from the <span class='math inline'><em>h</em><sub><em>a</em><em>f</em><em>t</em><em>e</em><em>r</em></sub></span> formulas, above</li>
<li>Because the variables in the square root can never be negative, and because the fraction denominators can never be zero, the square root will always return real values</li>
<li>However, the values to trade (meaning <span class='math inline'><em>δ</em><sub><em>e</em></sub></span> or <span class='math inline'><em>δ</em><sub><em>t</em></sub></span>) may be negative, and you should ignore them in that case</li>
<li>The values to trade (meaning <span class='math inline'><em>δ</em><sub><em>e</em></sub></span> or <span class='math inline'><em>δ</em><sub><em>t</em></sub></span>) may be larger than your balance; if so, then you should consider how much profit can be made from trading in all of your balance in that case (but, if it’s ether, then you have to deduct the gas cost before you trade it all in).</li>
</ul>
</div><div id='tassignment' class='tabcontent'><h3 id='assignment'>Assignment</h3>
<p>Your assignment is to create a program that attempts to make a profit by arbitrage trading. For the purposes of this assignment, a <em>profit</em> means an increase in the value of your holdings in USD; the holdings are computed from the amount of ETH and TC your program controls as well as the current price of each.</p>
<p>You must take gas estimation into account! Otherwise, if you were only to make 0.001 ETH, but it costs 0.002 ETH in gas, you are losing money. How to estimate gas fees is discussed on the <a href='../../docs/web3py.html'>introduction to web3.py</a> (<a href='../../docs/web3py.md'>md</a>) page – once you create a transaction, you call <code>eth.estimate_gas()</code>. The expected gas values will be in the tens of thousands of gwei – 36,000 to 65,000 is a reasonable guess, but yours may be higher or lower.</p>
<p>When providing a transaction, you also have to supply the gasPrice. For this assignment, you should use the value is in the <code>arbitrage_config.py</code> file (described below), which will typically be set to 10 gwei. This gas estimate times the gas cost (10 gwei) will allow you to compute the cost of gas in ether, which is the <span class='math inline'><em>g</em></span> variable in the formulas above.</p>
<p>Your program must be in Python. It must be named <code>arbitrage_trading.py</code>.</p>
<p>In practice, your program would listen for events from any of the DEXes, and any time the exchange rate of any of the DEXes changed, it would re-run the analysis. In order to make this assignment gradable, we are going to ignore events, and your program will consider all trade possibilities each time it is run.</p>
<h4 id='values-to-query-the-dexes-for'>Values to query the DEXes for</h4>
<p>Each DEX will have to be queried to get values for <span class='math inline'><em>x</em></span>, <span class='math inline'><em>y</em></span>, and <span class='math inline'><em>k</em></span>; from this, you can determine the exchange rate (<span class='math inline'><em>y</em>/<em>x</em></span> or <span class='math inline'><em>x</em>/<em>y</em></span>). You will also have to query the DEXes for the fee amount (<code>feeNumerator()</code> and <code>feeDenominator()</code>). Note that different DEXes, even for the same coin, can have different exchange rates and different fee amounts.</p>
<h4 id='values-provided'>Values provided</h4>
<p>The program will import an <code>arbitrage_config.py</code> file to provide many of the values, a sample of which is shown below. The correct file for this semester is available on the Canvas landing page.</p>
<pre><code>config = {
    # you will have to change these values for it to work
    'account_address': '0x123456789ABcdEf0123456789aBCDeF123456789',
    'account_private_key': hexbytes.HexBytes('0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef'),
    'connection_uri': '/path/to/geth.ipc',
    'connection_is_ipc': True, # set to false if it's a ws:// connection
    # once set, these should only be changed as necessary as you are testing your code
    'price_eth': 100.00,
    'price_tc': 10.0,
    'max_eth_to_trade': 10.0,
    'max_tc_to_trade': 100.0,
    'gas_price': 10, # in gwei
    # once set, you should not have to change these
    'dex_addrs': [
                  '0x123456789abcdef0123456789abcdef123456789', 
                  '0x123456789abcdef0123456789abcdef123456789', 
                  '0x123456789abcdef0123456789abcdef123456789', 
                  '0x123456789abcdef0123456789abcdef123456789',
                  '0x123456789abcdef0123456789abcdef123456789',
                  '0x123456789abcdef0123456789abcdef123456789'
                  ],
    'tokencc_addr': '0x123456789abcdef0123456789abcdef123456789',
    'chainId': 12345678,
}</code></pre>
<p>The <code>output()</code> function, below, will also be in the <a href='arbitrage_config.py.html'>arbitrage_config.py</a> (<a href='arbitrage_config.py'>src</a>) file, a <code>getTXNResult()</code> function for you to use, and the relevant ABIs.</p>
<p>You may assume that the arbitrage_config.py will always be present and properly structured, and that all values will be valid. The parts of the <code>config</code> dictionary are:</p>
<ul>
<li>Values that you must modify:
<ul>
<li><code>account_address</code>: the address of <em>your</em> Ethereum account that this program is controlling – it is the balance that this account has, in both ETH and TC, that constitutes the holdings of this account. You are welcome to create a different account for this assignment – just be sure to use that account as the <code>eth_coinbase</code> value when you submit the required <code>arbitrage.py</code> file.</li>
<li><code>account_private_key</code>: the (decrypted) private key for that account, used to initiate transactions; this must be in the exact format shown above
<ul>
<li>You will have obtained the decrypted version of your private key in the <a href='../ethprivate/index.html'>Private Ethereum Blockchain</a> assignment – you may have to run through that part again if you lost it or are now using a different account</li>
<li>That key was likely in the form <code>b'0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef'</code> – just copy the hex code (meaning without the leading <code>b'</code> and trailing <code>'</code>) into the <code>HexBytes()</code> constructor to make it the same format as the code above.</li>
</ul></li>
<li><code>connection_is_ipc</code>: whether the connection URI (which is on the next line in this file) is a geth.ipc file or a URL – this will determine how the web3 provider is created
<ul>
<li>Your code MUST be able to handle both types of connections!</li>
</ul></li>
<li><code>connection_uri</code>: how to connect to the blockchain – this will either be the path to a geth.ipc file or a URL to the course server; see the <a href='../../docs/web3py.html'>introduction to web3.py</a> (<a href='../../docs/web3py.md'>md</a>) for details – you either have to pass it to a <code>Web3.IPCProvider()</code> call or a <code>Web3.WebsocketProvider()</code> call</li>
</ul></li>
<li>Values you are welcome to modify, but you can complete the assignment with them as-is
<ul>
<li><code>price_eth</code>: the current price of ETH, in USD, as a float – this is without all the extra decimal places</li>
<li><code>price_tc</code>: the current price of TC, in USD, as a float – this is without all the extra decimal places</li>
<li><code>max_eth_to_trade</code>: the maximum amount of ether to send for a given transaction. Your code needs to explicitly check this, otherwise you are going to trade your entire quota in one go (see below for quota issues). This is also meant to allow you to limit your trade to a reasonable value (say, 10 ether) rather than accidentally trading everything you have by mistake.</li>
<li><code>max_tc_to_grade</code>: same as the previous, but for TCC</li>
<li><code>gas_price</code>: the gas price, in gwei, of a single gas step</li>
</ul></li>
<li>Values we are providing, and you should not modify them unless you are deploying your own DEXes
<ul>
<li><code>dex_addrs</code>: the smart contract addresses of the various DEX smart contracts; you can assume that there will be at least two in this list</li>
<li><code>tokencc_addr</code>: the smart address of the TokenCC smart contract</li>
<li><code>chainId</code>: the chainID for the course blockchain</li>
</ul></li>
</ul>
<p>You will need to edit some those values in arbitrage_config.py for your particular situation.</p>
<p>We provide a few other things in arbitrage_config.py: the ABI for IDEX and ITokenCC for you to use. We also provide a function called <code>getTXNResult()</code> that will attempt to figure out what happened on a transaction function call (the return value or revert reason). You can see these in the <a href='arbitrage_config.py.html'>arbitrage_config.py</a> (<a href='arbitrage_config.py'>src</a>) file.</p>
<h4 id='output'>Output</h4>
<p>Your program will analyze the various values at the different DEXes, and make a change (or not). Your output must be in the exact format shown below. If no profitable trades are possible, then you should output <code>No profitable arbitrage trades available</code>. If an trade is made, then the output should be of the exact form:</p>
<pre><code>Exchanged -123.0000 ETH for 2.3400 TC; fees: 1.23 USD; prices: ETH 12.30 USD, TC: 1.23 USD; holdings: 34.30 USD</code></pre>

<p>To ensure you output in the correct format, we provide a function that will print the appropriate lines in the required format. This function is also provided in the <a href='arbitrage_config.py.html'>arbitrage_config.py</a> (<a href='arbitrage_config.py'>src</a>) file.</p>
<pre><code>def output(ethAmt, tcAmt, fees, holdings_after):
    if ethAmt == 0 and tcAmt == 0:
        print("No profitable arbitrage trades available")
        return
    assert ethAmt * tcAmt &lt; 0, "Exactly one of ethAmt and tcAmt should be negative, the other positive"
    if ethAmt &lt; 0:
        print("Exchanged %.4f ETH for %.4f TC; fees: %.2f USD; prices: ETH %.2f USD, TC: %.2f USD; holdings: %.2f USD" %
              (ethAmt, tcAmt, fees, config['price_eth'], config['price_tc'], holdings_after))
    else:
        print("Exchanged %.4f TC for %.4f ETH; fees: %.2f USD; prices: ETH %.2f USD, TC: %.2f USD; holdings: %.2f USD" %
              (tcAmt, ethAmt, fees, config['price_eth'], config['price_tc'], holdings_after))</code></pre>
<p><strong><em>YOUR FINAL PROGRAM SHOULD PRODUCE NO OTHER OUTPUT</em></strong> other than the result of calling the <code>output()</code> function, above.</p>
<p>If there are no profitable transactions available, then pass in 0 for the first two parameters; the values of the last two parameters do not matter in this case. When a transaction is made, then one of <code>ethAmt</code> or <code>tcAmt</code> should be negative – that’s the one that is being sold. The other should be positive, and is how much of the other you received for that exchange. These values should be the amount of coin being bought or sold as a floating-point number, and without all the decimals (so 1.5 TC rather than 15000000000 TC). The prices for ETH and TC are pulled from <code>config</code> dictionary in <code>arbitrage_config.py</code>, so they do not have to be passed into this function. The <code>fees</code> and <code>holdings_after</code> parameters should be in USD.</p>
<p>The <code>fees</code> value that you are reporting is just the USD value of the Ethereum transaction fees. The DEX fees were deducted from the amount obtained.</p>
</div><div id='ttesting' class='tabcontent'><h3 id='testing'>Testing</h3>
<p>To see if your program makes the right decision, you can hard-code the <span class='math inline'><em>x</em></span>, <span class='math inline'><em>y</em></span>, and <span class='math inline'><em>k</em></span> values in your arbitrage_trading.py program and print out the results to see if it computed the correct values to trade.</p>
<p>The geth-config.toml file that you used in the <a href='../ethprivate/index.html'>HW S4: Private Ethereum Blockchain</a> (<a href='../ethprivate/index.md'>md</a>) assignment opens up a web socket. Thus, you can connect in two ways:</p>
<ul>
<li>Use the course connection (which is on the Canvas landing page) or <code>ws://localhost:8546</code>; you have to set <code>connection_is_ipc</code> to <code>False</code> for this</li>
<li>Use your geth.ipc file, but then you have to set <code>connection_is_ipc</code> to <code>True</code>.</li>
</ul>
<p>Which one you use must be read from the <code>arbitrage_config.py</code> file so that we can modify them when we test your submission.</p>
<h4 id='testing-setup'>Testing setup</h4>
<p><a href='img/ddc.webp' target='_blank'><img src='img/ddc.webp' style='width:300px;float:right'></img></a></p>
<p>To help you in your testing, we have deployed six DEXes that all trade the same coin, but at different rates. The coin is Dragon Dice Coin (DDC), whose image is shown to the right. The six different DEXes all trade at a <em>fixed</em> exchange rate (but still uses CPAMM!) – which means that multiple trades will <em>not</em> change their <span class='math inline'><em>x</em></span>, <span class='math inline'><em>y</em></span>, or <span class='math inline'><em>k</em></span> values. This is not realistic in a real-world situation, of course, but it is useful for testing. The six different DEXes have the icons of different sided dice, which correspond to their exchange rates:</p>
<ul>
<li><a href='img/d4c.webp' target='_blank'><img src='img/d4c.webp' style='width:50px;vertical-align:middle'></img></a> D4 exchanges at a rate of 1:4 (ETH:DDC)</li>
<li><a href='img/d6c.webp' target='_blank'><img src='img/d6c.webp' style='width:50px;vertical-align:middle'></img></a> D6 exchanges at a rate of 1:6 (ETH:DDC)</li>
<li><a href='img/d8c.webp' target='_blank'><img src='img/d8c.webp' style='width:50px;vertical-align:middle'></img></a> D8 exchanges at a rate of 1:8 (ETH:DDC)</li>
<li><a href='img/d10c.webp' target='_blank'><img src='img/d10c.webp' style='width:50px;vertical-align:middle'></img></a> D10 exchanges at a rate of 1:10 (ETH:DDC)</li>
<li><a href='img/d12c.webp' target='_blank'><img src='img/d12c.webp' style='width:50px;vertical-align:middle'></img></a> D12 exchanges at a rate of 1:12 (ETH:DDC)</li>
<li><a href='img/d20c.webp' target='_blank'><img src='img/d20c.webp' style='width:50px;vertical-align:middle'></img></a> D20 exchanges at a rate of 1:20 (ETH:DDC)</li>
</ul>
<p>Just to clarify: all six of these DEXes exchange the same DDC coin, but at different exchange rates. The individual dice images are used for the images of the DEXes; the multi-die image to the right is the image of the coin. The DEXes all follow the <a href='../dex/IDEX.sol.html'>IDEX.sol</a> (<a href='../dex/IDEX.sol'>src</a>) interface, and the DDC coin follows the <a href='../tokens/ITokenCC.sol.html'>ITokenCC.sol</a> (<a href='../tokens/ITokenCC.sol'>src</a>) interface.</p>
<p><strong><em>IMPORTANT NOTE:</em></strong> These DEXes follow <a href='https://aaronbloomfield.github.io/ccc/slides/applications.html#/cpamm'>CPAMM</a>, so the amount they give you will depend on the <span class='math inline'><em>x</em></span>, <span class='math inline'><em>y</em></span>, and <span class='math inline'><em>k</em></span> values that they report. Thus, you will not get <em>exactly</em> a 1:4 trade from the d4 DEX, but instead will get what a <a href='https://aaronbloomfield.github.io/ccc/slides/applications.html#/cpamm'>CPAMM</a> trade will provide.</p>
<p>The addresses of all these DEXes, as well as DDC, are on the Canvas landing page and are provided in an <code>arbitrage_config.py</code> file, which is available in Canvas’ Files.</p>
<h4 id='obtaining-ddc'>Obtaining DDC</h4>
<p>The <a href='../tokens/ITokenCC.sol.html'>ITokenCC.sol</a> (<a href='../tokens/ITokenCC.sol'>src</a>) interface has a <code>requestFunds()</code> function, which you just had revert in the <a href='../tokens/index.html'>dApp Tokens</a> (<a href='../tokens/index.md'>md</a>) assignment. For DDC, that function will pay you 100 DDC on each call. This will allow you to obtain DDC for use in your exchange testing.</p>
<p>Of course, you can also exchange ether for DDC with any of the DEXes to obtain DDC.</p>
<h4 id='limiters'>Limiters</h4>
<p>The problem with fixed exchange rates is that it is easy to deplete the DEX of funds – one could exchange 1 ETH for 20 TC via the D20 DEX, then back for 5 ETH via the D4 DEX, and repeat forever. This would deplete the reserves of the DEXes and also cause the blockchain size to balloon. It would also prevent other students from using the DEXes. For this reason, there are three limiters in effect for DDC and these DEXes:</p>
<ul>
<li>You may not make more than 1 exchange to any DEX every 60 seconds. This is checked by looking at the block timestamp. Remix will not always be able to judge correctly when 1 minute has passed; see the <a href='../auction/index.html'>Auction assignment</a> (<a href='../auction/index.md'>md</a>) for details (in the “Notes and Hints” tab, under “<code>block.timestamp()</code> behavior”). This time limit is for any DEX, so if you exchange with one DEX, you have to wait to exchange with any of the others.</li>
<li>You may not receive more than 10,000 ether from all of these DEXes combined. This is a total, and is independent of how much you have paid back to the DEXes. Thus, if you exchange for 10,000 ether from one of the DEXes, and then exchange it back for DDC with that same DEX, this limit will still take effect and none of these six DEXes will allow any further exchanges for ether. Thus, you should try exchanging for smaller values (say, 10 ether). This is one of the primary purposes for the <code>max_eth_to_trade</code> value in <code>arbitrage_config.py</code>.</li>
<li>You may not own more than 100,000 DDC at any one time. Unlike the previous limitation, this is a single snapshot, so if you are at the limit, and you exchange some back, you can then exchange for more DDC.</li>
</ul>
<p>These values can be changed by the course instructor, although that may take some time (i.e., it’s not instantaneous). However, you should use smaller amounts in your testing – don’t start by trading in a huge amount of ether, or all of your DDC, as this will cause you to hit your limits very quickly.</p>
<p>Keep in mind that the difficult part of this assignment is making the calculations. During testing you can have your code make those calculations, print out the result (and lots of intermediate values), but not make the actual trade on the blockchain. Once you think you have it working, then call the code to actually make the trade.</p>
<p>When you finally submit your solution, it should print out exactly one line, as described above, and make the trade.</p>
<p>Lastly, these DEXes have the ability to be “turned off” so that any attempt at a transaction will revert with an appropriate error message (either “trading not currently enabled” or “this DEX has been destructed”). In the former case, it will be turned on again soon. In the latter case, the DEXes were likely replaced – check the Canvas landing page for new DEX (and DDC) addresses.</p>
<h4 id='usage'>Usage</h4>
<p>The different DEX addresses are available from the Canvas landing page, in the <code>arbitrage_config.py</code> file in Canvas’ Files. The intent is for you to comment out different DEXes in that file so that you can test it with different pairs. The version of <a href='arbitrage_config.py.html'>arbitrage_config.py</a> (<a href='arbitrage_config.py'>src</a>) in the github repo does not have the addresses of the six DEXes deployed on the course-wide blockchain, but the version linked to from the Canvas landing page does.</p>
<p>Let’s assume a standard price ratio of 1:10 (ETH:DDC). This means that the arbitrage_config.py file might have lines such as:</p>
<pre><code>'price_eth': 100.00,
'price_tc': 10.0, </code></pre>
<p>This is as is provided in the arbitrage_config.py file on the Canvas landing page. Furthermore, the provided file has the <code>dex_addrs</code> list formatted as follows:</p>
<pre><code>'dex_addrs': [
              '0x123456789abcdef0123456789abcdef123456789', # d4 dex
              '0x123456789abcdef0123456789abcdef123456789', # d6 dex
              '0x123456789abcdef0123456789abcdef123456789', # d8 dex
              '0x123456789abcdef0123456789abcdef123456789', # d10 dex
              '0x123456789abcdef0123456789abcdef123456789', # d12 dex
              '0x123456789abcdef0123456789abcdef123456789', # d20 dex
             ],</code></pre>
<p>You can easily comment out different DEXes for your testing. The following three examples assume the prices listed above ($10 for DDC and $100 for ETH).</p>
<ul>
<li>If only the lower three DEXes that are available (d4, d6, and d8), then it will be more profitable to exchange DDC for ETH at the lowest numbered DEX available. Exchanging 4 DDC ($40) for <em>about</em> 1 ETH ($100) at the d4 DEX will generate a profit of <em>about</em> $60 minus fees. This is better than exchanging at the d6 DEX (profit of <em>about</em> $40 minus fees) and the d8 DEX (profit of <em>about</em> $20 minus fees).
<ul>
<li>The “<em>about</em>” moniker is because the profit is slightly less than the amount due to <a href='https://aaronbloomfield.github.io/ccc/slides/applications.html#/cpamm'>CPAMM</a>.</li>
</ul></li>
<li>If only the upper three DEXes available (d10, d12, and d20), then the most profitable exchange will be the highest numbered DEX. Exchanging 1 ETH ($100) for <em>about</em> 20 DDC ($200) will generate a profit of <em>about</em> $100 minus fees. This is better than exchanging at the d12 DEX (profit of <em>about</em> $20 minus fees).</li>
<li>The d10 DEX is never profitable if the price ratio is also 1:10. It exchanges at the same rate as the current prices, but once fees (both DEX and gas) are subtracted, money will be lost. .</li>
</ul>
<h4 id='specific-examples'>Specific Examples</h4>
<p>We assume that the prices in <code>arbitrage_config.py</code> are set to the standard 100 for ether and 10 for TC. There are four specific examples below; these are the visible Gradescope submission tests. These examples were from an account that started with 11 ether, but was not allowed to trade for than 10 ether (as per the <code>arbitrage_config.py</code> file).</p>
<ul>
<li>Example 1: starting with 11 ETH, 0 TC and all the DEXes yields about 1.0 ETH and exactly 180.909 TCC
<ul>
<li>Formally: <code>Exchanged -10.0000 ETH for 180.9091 TC; fees: 0.11 USD; prices: ETH 100.00 USD, TC: 10.00 USD; holdings: 1908.87 USD</code></li>
</ul></li>
<li>Example 2: starting with 11 ETH, 100 TC and the upper three DEXes yields about 1.0 ETH and exactly 280.909 TCC
<ul>
<li>Formally: <code>Exchanged -10.0000 ETH for 180.9091 TC; fees: 0.11 USD; prices: ETH 100.00 USD, TC: 10.00 USD; holdings: 2908.82 USD</code></li>
<li>The 280.909 comes from the initial balance of 100 TC plus the DEX trade gain of 180.909 TC</li>
</ul></li>
<li>Example 3: starting with 11 ETH, 100 TC and the lower three DEXes yields about 30.90 ETH and no TCC
<ul>
<li>Formally: <code>Exchanged -100.0000 TC for 19.8988 ETH; fees: 0.12 USD; prices: ETH 100.00 USD, TC: 10.00 USD; holdings: 3089.75 USD</code></li>
<li>The 30.90 ether comes from the initial balance of 11 plus the DEX trade gain of about 19.90 ether</li>
</ul></li>
<li>Example 4: staring with 11 ETH, 100 TC and only the d10 DEX yields no trade
<ul>
<li>Formally: <code>No profitable arbitrage trades available</code></li>
</ul></li>
</ul>
</div><div id='treal-world-profit' class='tabcontent'><h3 id='real-world-profit'>Real-world profit?</h3>
<p>Could you use this program in the real world with real ETH?</p>
<p>Well, sorta.</p>
<p>The concepts are the same. But you would have to make a few changes:</p>
<ul>
<li>The DEX addresses would be different, of course, since that would be on the real Ethereum blockchain.</li>
<li>You would listen for events from the DEXes to trigger the analysis – we know how to do that from the <a href='../daoweb3/index.html'>DAO & web3 assignment</a> (<a href='../daoweb3/index.md'>md</a>) in Javascript, and the function calls are similar in web3.py.</li>
<li>You would need to consider double (or triple) trades, not just single trades.</li>
<li>They are going to use a different set of exchange functions, and different DEXes are likely to have different interfaces (and thus different ABIs); thus you would need <em>separate</em> code to interact with each individual DEX.</li>
<li>I’m guessing you would want to test your code really, really, REALLY well if you were about to put a whole bunch of money into it.</li>
<li>We assumed a fixed price based on what was in the config file. If the USD value of the holdings was your metric, then you would need a means to get real-time prices. You could also use a different metric, such as how much of each currency you had in your holdings.</li>
<li>One of the big issues here is speed – if an arbitrage opportunity does exist, and your program takes 20 seconds to figure that out, it is going to get beat by a program written in a faster language that can do it in 10 seconds. The difference between those would mean that the other one would get in the block before yours, and make the profit instead.</li>
<li>You would likely be making <em>limit</em> orders instead of <em>market</em> orders (meaning you place an upper bound on the exchange rate when you place an order) – we have ignored limit orders in this course.</li>
</ul>
<p>But the concepts are certainly the same!</p>
</div><div id='tnotes-and-hints' class='tabcontent'><h3 id='notes-and-hints'>Notes and Hints</h3>
<ul>
<li>Be sure to put the <code>chainId</code> value in <em>each</em> transaction that you call from Python – things don’t always work well otherwise. The sample transactions on the <a href='../../docs/web3py.html'>introduction to web3.py</a> (<a href='../../docs/web3py.md'>md</a>) page all have this value present. Be sure to set it to the correct value for the course blockchain!</li>
<li>On Macs, there seems to be a problem using web3 via Python. When connecting to the course endpoint (the one with the <code>wss://</code> start of the URI), if you get an error such as: <code>ssl.SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED]</code>, try running going into your application/python_3.11 directory (might be different on your machine) and running the “Install Certificates.command” script</li>
</ul>
</div><div id='tsubmission' class='tabcontent'><h3 id='submission'>Submission</h3>
<p>You will need to fill in the various values from this assignment into the <a href='arbitrage.py.html'>arbitrage.py</a> (<a href='arbitrage.py'>src</a>) file. That file clearly indicates all the values that need to be filled in. That file, along with your Python source code, are the only files that must be submitted. The ‘sanity_checks’ dictionary is intended to be a checklist to ensure that you perform the various other aspects to ensure this assignment is fully submitted.</p>
<p>There is only one submission for this assignment.</p>
<p>Submission 1: Submit your <code>arbitrage_trading.py</code> source code file, along with your completed <code>arbitrage.py</code> file, to Gradescope. You should not submit the arbitrage_config.py file. #### Execution runs</p>
<p>The submission will make three execution runs, all on the same account. The account will start with 10 ether and 0 TCC. For all the execution runs, the following value are set:</p>
<ul>
<li>gas price: 10 gwei</li>
<li>ether price: $100</li>
<li>TCC price: $10</li>
<li>max ether to trade: 5</li>
<li>max TCC to trade: 50</li>
</ul>
<p>Each run assumes the state from the previous run. The trades are:</p>
<ul>
<li>Before first run: 10 ether, 0 TCC, holdings of 1000.00 USD</li>
<li>First run: with all the DEXes enabled in the config file, it should send 5 ether (the max allowed) to the d20 DEX
<ul>
<li>That will result in a receipt of 94.7619 TC</li>
<li>Output line: <code>Exchanged -5.0000 ETH for 94.7619 TC; fees: 0.18 USD; prices: ETH 100.00 USD, TC: 10.00 USD; holdings: 1447.45 USD</code></li>
<li>Balances after: 4.99826916 ether (5 ether minus gas fees), TC balance of 94.7619047620, holdings of $1,447.45</li>
</ul></li>
<li>Second run: with only the d10 DEX enabled in the config file, it should not find a profitable trade
<ul>
<li>Output line: <code>No profitable arbitrage trades available</code></li>
<li>Balances after: same as above, since no trades were made</li>
</ul></li>
<li>Third run: with only the lower 3 DEXes enabled (d4, d6, and d8), it should send 50 TC (the max allowed) to the d4 DEX
<ul>
<li>That will result in a gain of 11.0544 ether</li>
<li>Output line: <code>Exchanged -50.0000 TC for 11.0544 ETH; fees: 0.12 USD; prices: ETH 100.00 USD, TC: 10.00 USD; holdings: 2052.89 USD</code></li>
<li>Balances after: 16.052676835555555 ether, TC balance of 44.7619047620, holdings of $2,052.89</li>
</ul></li>
</ul>
<p>These should happen fairly quickly, as the Gradescope auto-grader can bypass the 60-second DEX waiting period.</p>
</div><script>document.getElementById('defaultOpen').click();</script></body>
</html>

