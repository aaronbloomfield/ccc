<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Arbitrage Trading</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../../markdown.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="arbitrage-trading">Arbitrage Trading</h1>
<p><a href="../index.html">Go up to the CCC HW page</a> (<a
href="../index.md">md</a>)</p>
<h3 id="overview">Overview</h3>
<p>In this assignment you are going to create a Python program to
perform <a href="../../slides/applications.html#/arbitrage">arbitrage
trading</a> on the blockchain. Your trading will be between a number of
different of your TokenDEX instances from the <a
href="../dex/index.html">DEX</a> (<a href="../dex/index.md">md</a>)
assignment.</p>
<h3 id="changelog">Changelog</h3>
<p>Any changes to this page will be put here for easy reference. Typo
fixes and minor clarifications are not listed here. So far there aren’t
any significant changes to report.</p>
<h3 id="pre-requisites">Pre-requisites</h3>
<p>Beyond general experience with programming Solidity (which you have
at this point it the course), this assignment requires:</p>
<ul>
<li>That you completed the <a href="../dex/index.html">DEX</a> (<a
href="../dex/index.md">md</a>) assignment as we will be using that. If
you didn’t get yours working, contact us, and we will provide it for
you.</li>
<li>That you completed the <a href="../tokens/index.html">Ethereum
Tokens</a> (<a href="../tokens/index.md">md</a>) assignment as we will
be using your TokenCC contract.</li>
<li>Familiarity with the <a
href="../../slides/applications.html#/arbitrage">arbitrage trading</a>
section of the lecture slides</li>
</ul>
<h3 id="tokendex-deployment">TokenDEX deployment</h3>
<p>You will need to deploy five (or so) instances of your TokenDEX. The
intent is to have a difference in exchange rates between these, and your
program below will take advantage of these differences. Before you
deploy them, however, read this section through.</p>
<p>There is a lot to do to get this all set up: you have to deploy a
TokenCC contract, five (or so) DEXes, initialize all the DEXes via
<code>createPool()</code>, and then perform some trades to create a
difference in the exhange rates. While this can all be done manually, we
can automate that via a smart contract. Consider the following
method:</p>
<pre><code>function setup(uint numdex, uint amt_eth, uint amt_tc) public payable {
    require (msg.value &gt; numdex * amt_eth * 1 ether, &quot;Must supply enough eth&quot;);
    tokencc = address(new TokenCC());
    num_dexes = numdex;
    etherpricer = address(new EtherPricerConstant());
    for ( uint i = 0; i &lt; num_dexes; i++ ) {
        if ( dexes[i] == address(0) )
            dexes[i] = address(new TokenDEX());
        else
            TokenDEX(dexes[i]).reset();
        TokenCC(tokencc).approve(dexes[i],amt_tc * 10**TokenCC(tokencc).decimals());
        TokenDEX(dexes[i]).createPool{value: amt_eth * 1 ether}(amt_tc * 10**TokenCC(tokencc).decimals(), 
                                 3, 1000, tokencc, etherpricer);
    }
}</code></pre>
<p>This handles all the deployment of the DEXes. As the addresses of the
DEXes and the TokenCC contract are stored in public variables (a
<code>dexes</code> mapping and a <code>tokencc</code> field,
respectively), we can get their addresses after this function runs –
we’ll need those when we write our program. Note that this function
requires supplying ETH with the call – if you are creating 5 DEXes with
10 ETH per DEX, then you have to supply it with 50 ETH plus gas fees (or
just make it 51 ETH).</p>
<p>We also want to make a few exchanges on the DEXes to vary the
exchange rates. Consider:</p>
<pre><code>    function configureDEXes() public payable {
        require (msg.value &gt; 10 ether, &quot;Must supply enough eth&quot;);
        // excahnge with the DEXes
        uint balance = TokenCC(tokencc).balanceOf(address(this));
        TokenDEX(dexes[1]).exchangeEtherForToken{value: 1 ether}();
        TokenDEX(dexes[2]).exchangeEtherForToken{value: 2 ether}();
        TokenDEX(dexes[3]).exchangeEtherForToken{value: 3 ether}();
        TokenDEX(dexes[4]).exchangeEtherForToken{value: 4 ether}();
        // give the sender the TC obtained
        uint xferamt = TokenCC(tokencc).balanceOf(address(this)) - balance;
        TokenCC(tokencc).transfer(msg.sender,xferamt);
    }</code></pre>
<p>When supplied with 10 ETH (plus enough for gas fees), this will make
a few exchanges. We don’t put it in the same function as the previous as
that would run over the gas limit.</p>
<p>We provide these functions, and a few others, in an <a
href="Arbitrage.sol.html">Arbitrage.sol</a> (<a
href="Arbitrage.sol">src</a>) file for you to use. You will not be
submitting this file, so feel free to adapt it as desired. Note that we
create a constant EtherPricer in that code, as we need to pass in an
EtherPricer to the <code>createPool()</code> function in the TokenDEX.
However, we don’t call any functions on the DEX that use the
EtherPricer, so using the constant one is fine here.</p>
<h3 id="web3.py">Web3.py</h3>
<p>You will need to read the <a href="web3py.html">introduction to
web3.py</a> (<a href="web3py.md">md</a>).</p>
<h3 id="market-theory">Market Theory</h3>
<h5 id="when-to-make-an-trade">When to make an trade</h5>
<p>Your program will need to compute it’s <em>holdings</em>, which is
the dollar amount of all the ETH and TC that it has. You can assume some
fixed price for ETH (say, $100) and for TC (say, $1) for testing – but
that means that your DEXes should have about 100 times as much TC as
ETH.</p>
<p>You will first need to obtain the various information (prices, <span
class="math inline"><em>x</em></span>/<span
class="math inline"><em>y</em></span>/<span
class="math inline"><em>k</em></span> values at each DEX, etc.). Then
you will need to make a <em>profitable trade</em>. A profitable trade is
defined here as a trade where the overall value of <em>holdings</em>, in
USD, increases. You must account for gas fees when determining this! The
formula to determine if you will make a profit is whether:</p>
<blockquote>
<p><span
class="math inline"><em>e</em><em>t</em><em>h</em><em>A</em><em>m</em><em>o</em><em>u</em><em>n</em><em>t</em><em>A</em><em>f</em><em>t</em><em>e</em><em>r</em> * <em>e</em><em>t</em><em>h</em><em>P</em><em>r</em><em>i</em><em>c</em><em>e</em> + <em>t</em><em>c</em><em>A</em><em>m</em><em>o</em><em>u</em><em>n</em><em>t</em><em>A</em><em>f</em><em>t</em><em>e</em><em>r</em> * <em>t</em><em>c</em><em>P</em><em>r</em><em>i</em><em>c</em><em>e</em> &gt; <em>e</em><em>t</em><em>h</em><em>A</em><em>m</em><em>o</em><em>u</em><em>n</em><em>t</em><em>B</em><em>e</em><em>f</em><em>o</em><em>r</em><em>e</em> * <em>e</em><em>t</em><em>h</em><em>P</em><em>r</em><em>i</em><em>c</em><em>e</em> + <em>t</em><em>c</em><em>A</em><em>m</em><em>o</em><em>u</em><em>n</em><em>t</em><em>B</em><em>e</em><em>f</em><em>o</em><em>r</em><em>e</em> * <em>t</em><em>c</em><em>P</em><em>r</em><em>i</em><em>c</em><em>e</em> − <em>g</em><em>a</em><em>s</em><em>F</em><em>e</em><em>e</em><em>s</em></span></p>
</blockquote>
<p>Note: there are other reasonable ways to determine “profit”. In
particular, if one believes that the price of the currency will grow,
then the total amount of that currency (not the total USD value) would
be another metric. For our purposes, we will just use the raw USD value
of the holdings.</p>
<p>We are going to call this a <em>single trade</em>. This is when you
make one transaction at a single DEX to increase your holdings.</p>
<!--

However, it could be that making *two* trades at once is profitable, whereas making one would not -- you must consider this possibility as well.  For example, imagine that ETH is worth $100, TC is worth $1, and you have 10 ETH and no TC, for a holdings of $1000.  We'll assume a constant exchange rate, even though our DEXes use $x \ast y = k$ to compute the exchange rate.  If a DEX 1 has a 1:100 ETH:TC exchange rate, then making that trade would not increase the holdings -- you would get $10 \ast 100 = 1,000$ TC for your 100 ETH, still worth $1000, but but the gas fees would lower that amount slightly, causing a loss of holdings.  However, if another DEX could trade that TC back for *more* ETH -- say it had a 1:50 ETH:TC exchange rate -- then you could trade that 1,000 TC for 20 ETH, making a profit.  Thus, you  must consider making two trades to make a profit as well.  We are going to call this a *double trade*.

You can assume the number of DEXes involved, $d$, is relatively small, so you can compute $d^2$ different combinations.  We will not be testing it with more than, say, half a dozen DEXes.

-->
<p>For this assignment, you will only need to consider a <em>single
trade</em> for each run of the program. This means, for each DEX, and
for each of the two directions (ETH -&gt; TC and TC -&gt; ETH), find the
(DEX,currency,amount) combination that maximizes your profit. If this
increases your holdings, then take that action. It’s also possible that
a <em>double trade</em> would yield a profit, where as a single trade
would not (for example, exchanging some ETH for some TC in one DEX, and
then trading it back for more ETH at a different DEX). We are not
considering those for this assignment.</p>
<h5 id="how-much-to-buy">How much to buy</h5>
<p>We can formulaicly determine how much to buy. The full derivation of
the formulas in this section is being omitted here, but you can see that
full derivation <a href="extra.html">here</a> (<a
href="extra.md">md</a>). For this, we need to define a few
variables:</p>
<ul>
<li>The DEX values are <span
class="math inline"><em>x</em><sub><em>d</em></sub></span>, <span
class="math inline"><em>y</em><sub><em>d</em></sub></span>, and <span
class="math inline"><em>k</em><sub><em>d</em></sub></span></li>
<li>The current prices are <span
class="math inline"><em>p</em><sub><em>e</em></sub></span> and <span
class="math inline"><em>p</em><sub><em>t</em></sub></span>, the price of
ETH and TC, respectively</li>
<li>The quantity of each that we currently have is <span
class="math inline"><em>q</em><sub><em>e</em></sub></span> and <span
class="math inline"><em>q</em><sub><em>t</em></sub></span>, for the
quantity of ETH and TC, respectively</li>
<li>Our holdings are <span
class="math inline"><em>h</em><sub><em>n</em><em>o</em><em>w</em></sub></span>
(our current holdings) and <span
class="math inline"><em>h</em><sub><em>a</em><em>f</em><em>t</em><em>e</em><em>r</em></sub></span>
(our holdings after the transaction)</li>
<li>The gas fees, computed as per the <a href="web3py.html">introduction
to web3.py</a> (<a href="web3py.md">md</a>) page, are <span
class="math inline"><em>g</em></span>; this is in units of ETH. Gas fees
are discussed below (in the “Assignment” section)</li>
<li><span class="math inline"><em>f</em></span> is the percentage (out
of 1.0) obtained after the DEX fees are removed – if <span
class="math inline"><em>f</em><sub><em>n</em></sub></span> is the fee
numerator (say, 3) and <span
class="math inline"><em>f</em><sub><em>d</em></sub></span> is the fee
denominator (say, 1000), then <span
class="math inline"><em>f</em> = 1 − <em>f</em><sub><em>n</em></sub>/<em>f</em><sub><em>d</em></sub></span>.
In this example, with <span
class="math inline"><em>f</em><sub><em>n</em></sub> = 3</span> and <span
class="math inline"><em>f</em><sub><em>d</em></sub> = 1000</span>, <span
class="math inline"><em>f</em> = 0.997</span>. Note that this fee
applies to both ETH and TC transactions.</li>
</ul>
<p>The above values are all fixed when the program runs. The only values
that the program chooses are the amount of ETH that we trade in (we’ll
call this <span
class="math inline"><em>δ</em><sub><em>e</em></sub></span>) or the
amount of TC that we trade in (we’ll call this <span
class="math inline"><em>δ</em><sub><em>t</em></sub></span>). As we are
only considering a single trade, only one of them will be non-zero.</p>
<p>The formulas that we need are (derivations <a
href="extra.html">here</a> (<a href="extra.md">md</a>)):</p>
<ul>
<li>Our current holdings, in USD, are: <span
class="math inline"><em>h</em><sub><em>n</em><em>o</em><em>w</em></sub> = <em>q</em><sub><em>e</em></sub> * <em>p</em><sub><em>e</em></sub> + <em>q</em><sub><em>t</em></sub> * <em>p</em><sub><em>t</em></sub></span></li>
<li>If we trade in TC, then our holdings after (in USD) are: <span
class="math inline"><em>h</em><sub><em>a</em><em>f</em><em>t</em><em>e</em><em>r</em></sub> = (<em>q</em><sub><em>e</em></sub>+<em>f</em>*<em>x</em><sub><em>d</em></sub>−<em>f</em>*<em>k</em><sub><em>d</em></sub>/(<em>y</em><sub><em>d</em></sub>+<em>δ</em><sub><em>t</em></sub>)) * <em>p</em><sub><em>e</em></sub> + (<em>q</em><sub><em>t</em></sub>−<em>δ</em><sub><em>t</em></sub>) * <em>p</em><sub><em>t</em></sub> − <em>g</em> * <em>p</em><sub><em>e</em></sub></span></li>
<li>If we trade in ETH, then our holdings after (in USD) are: <span
class="math inline"><em>h</em><sub><em>a</em><em>f</em><em>t</em><em>e</em><em>r</em></sub> = (<em>q</em><sub><em>t</em></sub>+<em>f</em>*<em>y</em><sub><em>d</em></sub>−<em>f</em>*<em>k</em><sub><em>d</em></sub>/(<em>x</em><sub><em>d</em></sub>+<em>δ</em><sub><em>e</em></sub>)) * <em>p</em><sub><em>t</em></sub> + (<em>q</em><sub><em>e</em></sub>−<em>δ</em><sub><em>e</em></sub>) * <em>p</em><sub><em>e</em></sub> − <em>g</em> * <em>p</em><sub><em>e</em></sub></span></li>
</ul>
<p>For a single trade, want to find the maximum profit for the two <span
class="math inline"><em>h</em><sub><em>a</em><em>f</em><em>t</em><em>e</em><em>r</em></sub></span>
formulas. We take the derivative, then set it equal to zero to find the
roots (details <a href="extra.html">here</a> (<a
href="extra.md">md</a>), if you are interested). The roots will give us
the maximum and/or minimum points. This gives us:</p>
<ul>
<li>If we traded in TC, then the maxima / minima are at: <span
class="math inline"><em>δ</em><sub><em>t</em></sub> =  − <em>y</em><sub><em>d</em></sub>±</span>
√ <span
class="math inline">(<em>f</em>*<em>k</em><sub><em>d</em></sub>*<em>p</em><sub><em>e</em></sub>/<em>p</em><sub><em>t</em></sub>)</span></li>
<li>If we traded in ETH, then the maxima / minima are at: <span
class="math inline"><em>δ</em><sub><em>e</em></sub> =  − <em>x</em><sub><em>d</em></sub>±</span>
√ <span
class="math inline">(<em>f</em>*<em>k</em><sub><em>d</em></sub>*<em>p</em><sub><em>t</em></sub>/<em>p</em><sub><em>e</em></sub>)</span></li>
<li>Those two formulas do not render well in HTML, but the entire
parenthetical is what we take the square root of</li>
</ul>
<p>A few notes on those:</p>
<ul>
<li>Neither of these are guaranteed to make a profit! But if a profit
can be made, then one of those will be the maximum profit.</li>
<li>How much profit is determined from the <span
class="math inline"><em>h</em><sub><em>a</em><em>f</em><em>t</em><em>e</em><em>r</em></sub></span>
formulas, above</li>
<li>Because the variables in the parenthetical can never be negative,
and because <span
class="math inline"><em>p</em><sub><em>e</em></sub></span> will never be
zero, the square root will always return real values</li>
<li>The amount of TC or ETH to trade in may be larger than your balance;
if so, then you should consider how much profit can be made from trading
in all of your balance in that case</li>
<li>However, the values that report how much to trade in may also be
negative, and you should ignore them in that case.</li>
</ul>
<h3 id="assignment">Assignment</h3>
<p>Your assignment is to create a program that attempts to make a profit
by arbitrage trading. For the purposes of this assignment, a
<em>profit</em> means an increase in the value of your holdings in USD;
the holdings are computed from the amount of ETH and TC your program
controls as well as the current price of each.</p>
<p>You must take gas estimation into account! Otherwise, if you were
only to make 0.001 (fake) ETH, but it costs 0.002 (fake) ETH in gas, you
are losing money. How to estimate gas fees is discussed on the <a
href="web3py.html">introduction to web3.py</a> (<a
href="web3py.md">md</a>) page – once you create a transaction, you call
<code>eth.estimateGas()</code>. Note that if you are exchanging TC for
ETH, then your gas fees will be double, as you have to call
<code>approve()</code> first on the TokenCC contract, and then
<code>exchangeTokenForEther()</code> on the DEX. For our purposes, you
can just estimate the gas for the first transaction and just double it.
The espected gas values will be in the tens of thousands of gas – 36,000
to 65,000 is a reasonable guess, but yours may be higher or lower.</p>
<p>When providing a transaction, you also have to supply the gasPrice.
For this assignment, we will select a standard 10 gwei as the gas price.
The gas estimate (perhaps doubled) times the gas cost (10 gwei) will
allow you to compute the cost of gas in ether, which is the <span
class="math inline"><em>g</em></span> variable in the formulas
above.</p>
<p>Your program must be in Python. It must be named
<code>arbitrage.py</code>.</p>
<p>In practice, your program would listen for events from any of the
DEXes, and any time the exchange rate of any of the DEXes changed, it
would re-run the analysis. In order to make this assignment gradable, we
are going to ignore events, and specify a different way that this
program is to be run.</p>
<h5 id="input">Input</h5>
<p>The program will read in a config.py file to provide all the
settings, a sample of which is shown below:</p>
<pre><code>config = {
    &#39;account_address&#39;: &#39;0x123456789abcdef0123456789abcdef123456789&#39;,
    &#39;account_private_key&#39;: hexbytes.HexBytes(&#39;0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef&#39;),
    &#39;connection_is_ipc&#39;: True,
    &#39;connection_uri&#39;: &#39;/path/to/geth.ipc&#39;,
    &#39;price_eth&#39;: 100.00,
    &#39;price_tc&#39;: 10.0,
    &#39;dex_addrs&#39;: [&#39;0x123456789abcdef0123456789abcdef123456789&#39;, &#39;0x123456789abcdef0123456789abcdef123456789&#39;, 
                  &#39;0x123456789abcdef0123456789abcdef123456789&#39;, &#39;0x123456789abcdef0123456789abcdef123456789&#39;,
                  &#39;0x123456789abcdef0123456789abcdef123456789&#39;],
    &#39;tokencc_addr&#39;: &#39;0x123456789abcdef0123456789abcdef123456789&#39;,
}

def hook():
    pass</code></pre>
<p>The <code>output()</code> function, below, will also be in the <a
href="config.py.html">config.py</a> (<a href="config.py">src</a>) file,
as well as a few more useful items.</p>
<p>You can assume that the config.py will always be present and properly
structured, and that all values will be valid. The parts of the
<code>config</code> dict are:</p>
<ul>
<li><code>account_address</code>: the address of the Ethereum account
that this program is controlling – it is the balance that this account
has, in both ETH and TC, that constitutes the holdings of this
account</li>
<li><code>account_private_key</code>: the private key for that account,
used to initiate transactions; this must be in the exact format shown
here
<ul>
<li>You will have obtained the decrypted version of your private key in
the <a href="ethprivate/index.html">Private Ethereum Blockchain</a> –
you may have to run through that part again if you lost it or are now
using a different key</li>
<li>That key was likely in the form
<code>b'0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef'</code>.
Just copy the hex code (meaning without the leading <code>b'</code> and
trailing <code>'</code>) into the <code>HexBytes()</code> constructor,
above.</li>
</ul></li>
<li><code>connection_is_ipc</code>: whether the connection URI (the next
item in the dict) is a geth.ipc file or a URL – this will determine how
the web3 provider is created</li>
<li><code>connection_uri</code>: how to connect to the blockchain – this
will either be the path to a geth.ipc file or a URL to the course
server; see the <a href="web3py.html">introduction to web3.py</a> (<a
href="web3py.md">md</a>) for details – you either have to wrap it in a
<code>Web3.IPCProvider()</code> call or a
<code>Web3.WebsocketProvider()</code> call</li>
<li><code>price_eth</code>: the current price of ETH, as a float – this
is without all the extra decimal places</li>
<li><code>price_tc</code>: the current price of TC, as a float – this is
without all the extra decimal places</li>
<li><code>tokencc_addr</code>: the smart address of the TokenCC smart
contract</li>
<li><code>dex_addrs</code>: the smart contract addresses of the various
TokenDEX smart contracts; there will be at least two in this list</li>
</ul>
<p>The <code>hook()</code> function should be present, and should do
nothing as shown. This function needs be called at the <em>start</em> of
each program execution run – meaning when your program starts but before
you read in any of the values from the blockchain. We are going to use
that when we grade the assignment.</p>
<p>We provide a few other things in config.py: the ABI for the TokenDEX
and the TokenCC for you to use. We also provide a function that will
attempt to figure out the reason for a reverting transaction. These are
provided in the <a href="config.py.html">config.py</a> (<a
href="config.py">src</a>) file.</p>
<h5 id="output">Output</h5>
<p>Your program will analyze the various values at the different DEXes,
and make a change (or not). Your output must be in an exact format. If
no profitable trades are possible, then you should output <code>No
profitable arbitrage trades available</code>. If an trade is made, then
the output should be of the form:</p>
<pre><code>Exchanged 123 ETH for 2.34 TC; fees: 0.0123 USD; prices: ETH 12.3 USD, TC: 1.23 USD; holdings: 34.3 USD</code></pre>
<!--

If two trades are made, then print out two lines of that form.  Keep in mind that each program execution will either make one single trade or one double trade.  

-->
<p>To ensure you output in the correct format, we provide a function
that will print the appropriate lines. This function is also provided in
the <a href="config.py.html">config.py</a> (<a href="config.py">src</a>)
file.</p>
<pre><code>def output(ethAmt, tcAmt, fees, holdings):
    if ethAmt == 0 and tcAmt == 0:
        print(&quot;No profitable arbitrage trades available&quot;)
        return
    assert (ethAmt * tcAmt &lt; 0; &quot;Exactly one of ethAmt and tcAmt should be negative, the other positive&quot;)
    if ethAmt &lt; 0:
        print(&quot;Exchanged %f ETH for %f TC; fees: %f USD; prices: ETH %.2f USD, TC: %.4f USD; holdings: %.2f USD&quot; %
              str(ethAmt), str(tcAmt), str(fees), config[&#39;price_eth&#39;], config[&#39;price_tc&#39;], str(holdings))
    else:
        print(&quot;Exchanged %f TC for %f ETH; fees: %f USD; prices: ETH %.2f USD, TC: %.4f USD; holdings: %.2f USD&quot; %
              str(tcAmt), str(ethAmt), str(fees), config[&#39;price_eth&#39;], config[&#39;price_tc&#39;], str(holdings))</code></pre>
<p>If there are no profitable transactions available, then pass in 0 for
the first two parameters (the last two parameters are not used in this
case). When a transaction is made, then one of <code>ethAmt</code> or
<code>tcAmt</code> should be negative – that’s the one that is being
sold. The other should be positive. These values should be the amount of
coin being bought or sold, and without all the decimals (so 1.5 TC
rather than 15000000000 TC). The prices for ETH and TC are pulled from
<code>config</code> dict, so they do not have to be passed into this
function. The <code>fees</code> and <code>holdings</code> parameters
should be in USD.</p>
<h3 id="testing">Testing</h3>
<p>When testing your code, don’t worry about getting the <span
class="math inline"><em>x</em></span>, <span
class="math inline"><em>y</em></span>, and <span
class="math inline"><em>k</em></span> values exactly correct for a test.
If you want to test such a situation, you can hard-code those values in
the arbitrage.py program. Trying to get all the DEXes configured and
deployed will be very frustrating if you are trying for exact values.
Instead, make a few transactions to the various DEXes from
<em>another</em> account to get the <span
class="math inline"><em>x</em></span>, <span
class="math inline"><em>y</em></span>, and <span
class="math inline"><em>k</em></span> values to differ between the
different DEXes. The Arbitrage conract above does that, but you may need
to do that more for your testing.</p>
<p>We provide an Arbitrage.sol contract that will help with the setup
and testing. The <code>setup()</code> function will deploy five DEXes
and configure them with some ETH and TC – you have to provide enough TC
when you call that function. You can then get the addresses of the
deployed TokenCC and TokenDEX instances through the various fields.
<strong><em>NOTE:</em></strong> Just using this blindly without
understanding what it does will not be successful – you need to
understand the code that is being called.</p>
<p>The intent is that some <em>other</em> account (meaning not the
account running the arbitrage program) will make transactions with one
of the DEX instances, which will cause a change in the exchange rates.
The <code>arbitrage.py</code> program is then called to see if any
profitable trades can be made.</p>
<h3 id="real-world-profit">Real-world profit?</h3>
<p>Could you use this program in the real world with real ETH?</p>
<p>Well, sorta.</p>
<p>The concepts are the same. But you would have to make a few
changes:</p>
<ul>
<li>The DEX addresses would be different, of course, since that would be
on the real Ethereum blockchain.</li>
<li>You would listen for events from the DEXes to trigger the
analysis.</li>
<li>You would need to consider double (or triple) trades, not just
single trades.</li>
<li>They are going to use a different set of exchange functions, and
different DEXes are likely to have different interfaces (and thus
different ABIs); thus you would need <em>separate</em> code to interact
with each individual DEX.</li>
<li>I’m guessing you would want to test your code really, really, really
well if you were about to put a whole bunch of money into it.</li>
<li>We assumed a fixed price based on what was in the config file. If
the USD value of the holdings was your metric, then you would need a
means to get real-time prices. You could also use a different metric,
such as how much of each currency you had in your holdings.</li>
<li>One of the big issues here is speed – if an arbitrage opportunity
does exist, and your program takes 20 seconds to figure that out, it is
going to get beat by a program written in a faster language that can do
it in 10 seconds – and do it such that it gets in a block ahead of
you.</li>
</ul>
<p>But the concepts are certainly the same!</p>
<h3 id="submission">Submission</h3>
<p>There are <em>two</em> forms of submission for this assignment; you
must do both of them. Note that there is no required deployment to the
blockchain for this assignment.</p>
<p>Submission 1: Submit your arbitrage.py file to Gradescope. You do not
need to submit the config.py file. Note that gradescope can’t test that
the program works.</p>
<p>Submission 2: Fill out the Google form, whose URL is on the Collab
landing page.</p>
<p>We also have a few other things for you to check:</p>
<ul>
<li>Your program should produce NO output other than that provided by
the <code>output()</code> function</li>
<li>…</li>
</ul>
</body>
</html>
