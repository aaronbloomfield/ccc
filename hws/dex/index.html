<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Decentralized Exchange (DEX)</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../../markdown.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="decentralized-exchange-dex">Decentralized Exchange (DEX)</h1>
<p><a href="../index.html">Go up to the CCC HW page</a> (<a
href="../index.md">md</a>)</p>
<h3 id="overview">Overview</h3>
<p>In this assignment you are going to create a Decntralized
Cryptocurrency Exchange (hereafter: DEX) for the token cryptocurrency
you created in the <a href="../tokens/index.html">Ethereum Tokens</a>
(<a href="../tokens/index.md">md</a>) assignment. Once deployed, anybody
will be able to exchange (fake) ETH for your token cryptocurrency. The
DEX will use the <a
href="../../slides/applications.html#/cpamm">Constant Product Automated
Market Maker (CPAMM)</a> method for determining the exchange rates.</p>
<h3 id="pre-requisites">Pre-requisites</h3>
<p>Writing this homework will require completion of the following
assignments:</p>
<ul>
<li><a href="../ethprivate/index.html">Connecting to the private
Ethereum blockchain</a> (<a href="../ethprivate/index.md">md</a>)</li>
<li><a href="../dappintro/index.html">dApp introduction</a> (<a
href="../dappintro/index.md">md</a>)</li>
<li><a href="../tokens/index.html">Ethereum Tokens</a> (<a
href="../tokens/index.md">md</a>)</li>
</ul>
<p>Note that this assignment requires that your <a
href="../tokens/index.html">Ethereum Tokens</a> (<a
href="../tokens/index.md">md</a>) assignment is working properly. If you
did not get it working properly, then contact us. You are expected to
use your TokenCC code from the <a href="../tokens/index.html">Ethereum
Tokens</a> (<a href="../tokens/index.md">md</a>) assignment. While you
are welcome to use that deployment or re-deploy it, we suspect that you
will likely have to re-deploy it many times as you are testing your DEX.
Be sure to save the contract address of the final deployment that you
will use when you submit the assignment.</p>
<p>You will also need to be familiar with the <a
href="../../slides/ethereum.html#/">Ethereum slide set</a>, the <a
href="../../slides/solidity.html#/">Solidity slide set</a>, the <a
href="../../slides/tokens.html#/">Tokens slide set</a>, and the <a
href="../../slides/applications.html">Blockchain Applications</a> slide
set. The last one is most relevant, as it discusses how DEXes work.</p>
<h3 id="the-price-of-our-fake-eth">The price of our (fake) ETH</h3>
<p>To simulate changing market conditions, we have deployed two smart
contracts to help one determine the price of our (fake) ETH. Both of
these contracts fulfill the <a
href="EtherPricer.sol.html">EtherPricer.sol</a> (<a
href="EtherPricer.sol">src</a>) interface:</p>
<pre><code>interface EtherPricer is IERC165 {
        function getEtherPriceInCents() external view returns (uint);
}</code></pre>
<p>Thus, it provides only two functions: the
<code>getEtherPriceInCents()</code> and <code>supportsInterface()</code>
from the <a href="IERC165.sol.html">IERC165.sol</a> (<a
href="IERC165.sol">src</a>) contract. The
<code>getEtherPriceInCents()</code> will return the current price in
cents. Thus, if the price is $99.23 per (fake) ETH, it would return
<code>9923</code>.</p>
<p>As mentioned, there are two deployed, the contract addresses of which
are on the Collab landing page. The first is a constant implementation,
which always returns $100.00 (formally: <code>10000</code>) as the
price. The implementation for this is in <a
href="EtherPricerConstant.sol.html">EtherPricerConstant.sol</a> (<a
href="EtherPricerConstant.sol">src</a>). This is meant to be used for
debugging, as it always returns the same value.</p>
<p>The second one is a variable version, whose price ranges greatly, but
generally averages (over time) around $100 in price. As there is no true
randomness on a fully deterministic blockchain, the value is based on
the current block number. So while this will change at each block, it
will not change until a new block is mined. The implementation for the
variable version is not being provided, but it follows the interface
above.</p>
<p>You should use the first (constant) one while you are debugging your
code. You will need to use the second (variable) one when you make your
final deployment. The current (variable) price of our (fake) ETH is
shown on the DEX web page, which is described below.</p>
<h3 id="details">Details</h3>
<p>Your DEX must follow the <a
href="../../slides/applications.html#/cpamm">CPAMM (Constant Product
Automated Market Maker)</a> method as discussed in the lecture slides.
Once deployed, there will be some liquidity that must be added to the
DEX before trading can start. Anybody can then exchange some of our
(fake) ETH for your token cryptocurrency. This, combined with the
varying price of our (fake) ETH, will cause the price of your token
cryptocurrency to fluctuate significantly. At the end of the assignment
you will register your DEX with a course-wide exchange so that the
entire class can see all of the exchangeable token cryptocurrencies.</p>
<p>As far as this assignment is concerned, there will only be
<em>one</em> DEX for each token cryptocurrency. You may have deployed
multiple ones to test your code, but for our class trading we will only
be having one DEX that you deploy at the end. Thus, arbitrage trading is
not possible, since that requires trading between two or more
exchanges.</p>
<h3 id="interface">Interface</h3>
<p>Formally, you must implement a <code>TokenDEX</code> contract that
implements the <a href="DEX.sol.html">DEX.sol</a> (<a
href="DEX.sol">src</a>) interface. Your contract opening line MUST be:
<code>contract TokenDEX is DEX</code>. Note that the <code>DEX</code>
interface extends the <code>IERC165</code> interface, so you will also
have to implmenet the <code>supportsInterface()</code> function. The
functions in this interface are shown below, and much more detail is
provided in the <a href="DEX.sol.html">DEX.sol</a> (<a
href="DEX.sol">src</a>) file.</p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import &quot;./IERC165.sol&quot;;
import &quot;./EtherPricer.sol&quot;;

interface DEX is IERC165 {

    //------------------------------------------------------------
    // Events

    event liquidityChangeEvent();

    //------------------------------------------------------------
    // Getting the exchange rates and prices

    function tokenDecimals() external view returns (uint);

    function getEtherPrice() external view returns (uint);

    function getTokenPrice() external view returns (uint);

    //------------------------------------------------------------
    // Getting the liquidity of the pool or part thereof

    function k() external view returns (uint);

    function etherLiquidity() external view returns (uint);

    function tokenLiquidity() external view returns (uint);

    function getPoolLiquidityInUSDCents() external view returns (uint);

    function etherLiquidityForAddress(address who) external returns (uint);

    function tokenLiquidityForAddress(address who) external returns (uint);

    //------------------------------------------------------------
    // Pool creation

    function createPool(uint tokenAmount, uint feeNumerator, uint feeDenominator, 
                        address erc20token, address etherpricer) external payable;

    //------------------------------------------------------------
    // Fees

    function feeNumerator() external view returns (uint);

    function feeDenominator() external view returns (uint);

    function feesEther() external view returns (uint);

    function feesToken() external view returns (uint);

    //------------------------------------------------------------
    // Managing pool liquidity

    function addLiquidity() external payable;

    function removeLiquidity(uint amountEther) external;

    //------------------------------------------------------------
    // Exchanging currencies

    function exchangeEtherForToken() external payable;

    function exchangeTokenForEther(uint amountToken) external;

    //------------------------------------------------------------
    // Functions for debugging and grading

    function setEtherPricer(address p) external;

    function etherPricerAddress() external returns (address);

    function erc20TokenAddress() external returns (address);

    function getTokenCCAbbreviation() external returns (string memory);

    //------------------------------------------------------------
    // Functions for efficiency

    function getDEXinfo() external returns (address, string memory, string memory, 
                            address, uint, uint, uint, uint, uint, uint, uint, uint);

    //------------------------------------------------------------
    // Inherited functions

    // function supportsInterface(bytes4 interfaceId) external view returns (bool);

}</code></pre>
<p>Here are all the files you will need:</p>
<ul>
<li><a href="DEX.sol.html">DEX.sol</a> (<a href="DEX.sol">src</a>): the
interface, above, that your contract will need to implement</li>
<li><a href="EtherPricer.sol.html">EtherPricer.sol</a> (<a
href="EtherPricer.sol">src</a>): the interface that the two pricing
smart contracts implement; the contract addresses for these are on the
Collab landing page</li>
<li><a href="EtherPricerConstant.sol.html">EtherPricerConstant.sol</a>
(<a href="EtherPricerConstant.sol">src</a>) is the contract
implementation of EtherPricer.sol that always returns 100 in cents
(formally: <code>10000</code>); note that the source code for the
variable version is not being made available</li>
<li><a href="IERC165.sol.html">IERC165.sol</a> (<a
href="IERC165.sol">src</a>): the ERC-165 interface, which the DEX
interface extends</li>
<li><a href="IERC20Metadata.sol.html">IERC20Metadata.sol</a> (<a
href="IERC20Metadata.sol">src</a>): the same file from the <a
href="../tokens/index.html">Ethereum Tokens</a> (<a
href="../tokens/index.md">md</a>) assignment, which your token
cryptocurrency implements</li>
<li><a href="IERC20.sol.html">IERC20.sol</a> (<a
href="IERC20.sol">src</a>): The full ERC-20 interface, which the
IERC20Metadata contract extends</li>
</ul>
<p>When you want to test your program, this is the expected flow to get
it started, whether to the Javascript blockchain in Remix or to our
private Ethereum blockchain:</p>
<ul>
<li>Deploy your TokenDEX contract and (if necessary) your TokenCC
contract</li>
<li>Approve your TokenDEX contract for some amount of your TokenCC
supply via <code>approve()</code> on your TokenCC contract</li>
<li>Call <code>createPool()</code> on your TokenDEX. Choose how much
TokenCC supply to use (you don’t have to use it all!), and put in the
appropriate EtherPricer contract address</li>
</ul>
<h3 id="fees">Fees</h3>
<p>Each transaction will have fees deducted. Fees are always deducted
from the amount the DEX pays out – it just pays that much less.
Reasonable fees are a fraction of a percent – perhaps 0.2%, for
example.</p>
<p>When fees are withheld, the amount that is withheld is added to the
<code>feesEhter</code> and <code>feesToken</code> variables (and getter
functions). These accumulate the <em>total</em> amount of fees that the
DEX has accumulated over time.</p>
<p>Managing fees is quite complicated – one has to take into account how
much liquidity each provider has in the DEX, and over what time frame.
There could be thousands of liquidity providers in the pool, each of
which gets a cut, proportional to their liquidity, of each transaction’s
fee. Furthermore, fees are added to the liquidity pool, but only when
they can be added in appropriate proportions.</p>
<p>For this assignment, we are not going to handle distributing fees
back to the liquidity providers – we are just going to accumulate them
into the <code>feesEhter</code> and <code>feesToken</code> variables. We
realize that this inability to retrieve the fees would result in lost
ETH or TC. That’s fine for this assignment, even if it would not be fine
in a real world situation.</p>
<h3 id="example">Example</h3>
<p>To help you debug your program, here is a worked-out example of how
the values in the DEX change as various transactions occur. This is
assuming a constant (fake) ETH price of $100. In the example below, we
will call the token cryptocurrency “TC” for “Token Cryptocurrency”. For
reasons we will see below, we are only putting in 10 (fake) ETH in this
example, whereas you will have put in 100 when you deploy it at the end
of the assignment.</p>
<ul>
<li>We are starting off with a few assumptions; if these vary from
yours, then change as necessary
<ul>
<li><span class="math inline"><em>x</em></span> will always represent
the amount of ETH in the pool. As ETH is represented in wei, this will
be the ETH amount with 18 decimal places</li>
<li><span class="math inline"><em>y</em></span> will always represent
the amount of TC in the pool. We assume that there are 10 decimal places
for TC.</li>
<li>The assumption is that you have more TC that you own beyond what you
have just deposited</li>
<li>For the examples herein, we are ignoring fees – you can set the
<code>feeNumerator</code> to 0 to get this when testing your
contract</li>
</ul></li>
<li><code>createPool()</code>: initially, we will deposit 10 (fake) ETH
and 100 TC
<ul>
<li><span class="math inline"><em>k</em></span> should be <span
class="math inline">10 * 100 = 1, 000</span>, since we deposited 10 ETH
and 100 TC. But the value reported by the DEX will be with 10 more
decimal places for TC and 18 more decimal places for the ETH. So <span
class="math inline"><em>k</em></span> will report as <span
class="math inline">1, 000 * 10<sup>10</sup> * 10<sup>18</sup> = 10<sup>31</sup> = 10, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000</span></li>
<li>The 10 ETH are worth $100 each (we are assuming the constant
EtherPricer for this example), so the ETH is worth $1,000. Since the TC
is assumed to have the same value, the overall DEX liquidity is $2,000.
Each TC is worth $0.10.</li>
<li>At this point:
<ul>
<li><span class="math inline"><em>k</em> = 10<sup>31</sup></span></li>
<li><span class="math inline"><em>x</em></span>, the amount of ETH, is
10 or <span
class="math inline"><em>x</em> = 10 * 10<sup>18</sup> = 10<sup>19</sup></span></li>
<li><span class="math inline"><em>y</em></span>, the amount of TC, is
100 or <span
class="math inline"><em>y</em> = 100 * 10<sup>10</sup> = 10<sup>12</sup></span></li>
<li>The exchange ration is 1 ETH for 10 TC (we just divide 1,000 by
100)</li>
</ul></li>
</ul></li>
<li>Transaction 1: we exchange 2.5 ETH for some amount of TC
<ul>
<li>The pool will then have 12.5 ETH (or <span
class="math inline"><em>x</em> = 12.5 * 10<sup>18</sup></span> wei)</li>
<li>Determine <span class="math inline"><em>y</em></span> by dividing
<span class="math inline"><em>k</em></span> by <span
class="math inline"><em>x</em></span>: <span
class="math inline"><em>y</em> = <em>k</em>/<em>x</em> = 10<sup>31</sup>/12.5 * 10<sup>18</sup> = 8 * 10<sup>11</sup></span>
or (after removing the decimals) 80 TC</li>
<li>As the pool had 100 TC before this transaction, we get <span
class="math inline">100 − 80 = 20</span> TC (formally: <span
class="math inline">20 * 10<sup>10</sup></span>)</li>
<li>At this point:
<ul>
<li><span class="math inline"><em>k</em> = 10<sup>31</sup></span></li>
<li><span class="math inline"><em>x</em></span>, the amount of ETH, is
12.5 or <span
class="math inline"><em>x</em> = 12.5 * 10<sup>18</sup> = 1.25 * 10<sup>19</sup></span></li>
<li><span class="math inline"><em>y</em></span>, the amount of TC, is 80
or <span
class="math inline"><em>y</em> = 80 * 10<sup>10</sup> = 8<sup>11</sup></span></li>
<li>The exchange rate is 1 ETH for 6.4 TC (we just divide 80 by
12.5)</li>
</ul></li>
</ul></li>
<li>Transaction 2: we exchange 120 TC for some ETH
<ul>
<li>The pool will then have 200 TC (or <span
class="math inline"><em>y</em> = 200 * 10<sup>10</sup> = 2 * 10<sup>12</sup></span>)</li>
<li>Determine <span class="math inline"><em>x</em></span> by dividing
<span class="math inline"><em>k</em></span> by <span
class="math inline"><em>y</em></span>: <span
class="math inline"><em>x</em> = <em>k</em>/<em>y</em> = 10<sup>31</sup>/2 * 10<sup>12</sup> = 5 * 10<sup>18</sup></span>
or 5 ETH</li>
<li>As the pool had 12.5 ETH, we get <span
class="math inline">12.5 − 5 = 7.5</span> ETH</li>
<li>At this point:
<ul>
<li><span class="math inline"><em>k</em> = 10<sup>31</sup></span></li>
<li><span class="math inline"><em>x</em></span>, the amount of ETH, is 5
or <span
class="math inline"><em>x</em> = 5 * 10<sup>18</sup></span></li>
<li><span class="math inline"><em>y</em></span>, the amount of TC, is
200 or <span
class="math inline"><em>y</em> = 200 * 10<sup>10</sup> = 2 * 10<sup>12</sup></span></li>
<li>The exchange rate is 1 ETH for 40 TC (we just divide 200 by 5)</li>
</ul></li>
</ul></li>
<li>We add liquidity to the pool
<ul>
<li>The DEX has 5 ETH and 200 TC; the exchange rate is 1 ETH for 40 TC
(from above)</li>
<li>We have to add in equal amounts; as far as this DEX is concerned, 1
ETH is equal to 40 TC; thus, we have to put in 40 times as many TC as we
put in ETH</li>
<li>We opt to put in 1 ETH and 40 TC</li>
<li>The new amounts in the DEX will be 6 ETH and 240 ETH; this keeps the
same exchange ratio of 1 ETH = 40 TC (we just divide 240 by 6)</li>
<li><span class="math inline"><em>x</em></span>, the amount of ETH,
increases by 1 or <span class="math inline">1 * 10<sup>18</sup></span>
to become <span
class="math inline"><em>x</em> = 5 * 10<sup>18</sup> + 1 * 10<sup>18</sup> = 6 * 10<sup>18</sup> = 6 * 10<sup>18</sup></span></li>
<li><span class="math inline"><em>y</em></span>, the amount of TC,
increases by 40 or <span class="math inline">40 * 10<sup>10</sup></span>
to become: <span
class="math inline"><em>y</em> = 200 * 10<sup>10</sup> + 40 * 10<sup>10</sup> = 240 * 10<sup>10</sup> = 2.4 * 10<sup>12</sup></span></li>
<li>We recompute <span class="math inline"><em>k</em></span> via <span
class="math inline"><em>k</em> = <em>x</em> * <em>y</em> = 6 * 10<sup>18</sup> * 2.4 * 10<sup>12</sup> = 1.44 * 10<sup>31</sup></span></li>
<li>At this point:
<ul>
<li><span
class="math inline"><em>k</em> = 1.44 * 10<sup>31</sup></span></li>
<li><span class="math inline"><em>x</em></span>, the amount of ETH, is 6
or <span
class="math inline"><em>x</em> = 6 * 10<sup>18</sup> = 6 * 10<sup>18</sup></span></li>
<li><span class="math inline"><em>y</em></span>, the amount of TC, is
240 or <span
class="math inline"><em>y</em> = 240 * 10<sup>10</sup> = 2.4 * 10<sup>12</sup></span></li>
<li>The exchange rate is 1 ETH for 40 TC (we just divide 240 by 6)</li>
</ul></li>
</ul></li>
</ul>
<h3 id="deployment">Deployment</h3>
<p>This part has three different steps. This may require a few runs to
get it right – that’s fine, just be sure to submit the various values
(contract addresses and transaction hashes) from the last
deployment.</p>
<p>Step 1: You will need to have deployed your TokenCC smart contract,
from the previous assignment, to the blockchain, and you will need to
know its contract address. You are welcome to use the deployed one from
the previous assignment, or re-deploy it for this one.</p>
<p>Step 2: Deploy your DEX to the private Ethereum blockchain. So that
it will work properly with all of your other classmates’ DEX
implementations, we have some strict requirements for the
deployment:</p>
<ul>
<li>It must be initialized with the <em>variable</em> EtherPricer
contract for the price of our (fake) ether. While you are welcome to use
the constant one for testing, you MUST use the variable one for the
final deployment.</li>
<li>You need to call <code>createPool()</code>
<ul>
<li>You must fund it with 100 (fake) ether. <em>Do not put a different
amount in!</em>
<ul>
<li>This implies initializing the TokenCC and allowing the DEX to
transfer it</li>
</ul></li>
<li>You can put as many or as little of your token in as you like (but
no less than 10.0 coins). Putting in fewer will give them a higher
monetary value, but allow for less growth. But you should keep some for
yourself, as you will need it below – so don’t put them all in. We
recommend putting in about half of what you own, and you can certainly
put in less.</li>
</ul></li>
<li>Do not call either <code>addLiquidity()</code> or
<code>removeLiquidity()</code> yet</li>
</ul>
<p>Step 3: You need to register your DEX with the course-wide exchange
board website; the URL for this is on the Collab landing page. To
register your DEX, fill out the contract address form at the bottom of
that page – all the other information (your userid and token
abbreviation) has already been submitted for you. You will see your DEX
values populate one of the table rows – make sure they are correct. Note
that the current ETH price is listed at the top of the page.</p>
<h3 id="send-me-some-of-your-token-cryptocurrency">Send me some of your
token cryptocurrency</h3>
<p>I will need some of your token cryptocurrency to test your DEX for
grading purposes. While you sent me some in a previous homework, that
was likely with a differently deployed TokenCC smart contract. Please
send me 1.0 coins. This means that if your TokenCC has 10 decimal
places, then the value you need to send me is 10,000,000,000. The
address to send this to is on the Collab landing page.</p>
<h3 id="make-some-exchanges">Make some exchanges</h3>
<p>Now that your exchange is registered, you can view all the exchanges.
You should see your exchange in there, along with your cryptocurrency’s
logo. The stats of each exchange are listed in that table.</p>
<p>You need to make 4 total exchanges with DEXes other than you own. As
you likely have more of your own Token cryptocurrency, you can now
exchange that with your DEX to get some ether. Or you can mine ether and
use that to exchange for the others.</p>
<p>Depending on when you submit your assignment, there may not be other
DEXes to interact with. That’s fine – you don’t have to have those bids
completed by the time the assignment is due; you have an extra few days
to place your bids. We are going to judge lateness on this assignment by
the Gradescope submission time, and the Google form does not ask for the
transaction hashes of the exchanges. We are going to check whether you
exchange for the other token cryptocurrencies by looking if your
eth.coinbase account, the address of which you will submit below,
initiated exchanges on any one of your classmate’s submitted DEX
addresses by a few days after the due date. Note that you have to place
the bid via Remix or geth; the course website just displays the
auctions.</p>
<h3 id="submission">Submission</h3>
<p>There are <em>four</em> forms of submission for this assignment; you
must do all four.</p>
<p>Submission 1: Submit the TokenDEX.sol file to Gradescope. Also submit
the TokenCC.sol file, from the previous assignment.</p>
<p>Submission 2: Deploy the TokenDEX smart contract to the private
Ethereum blockchain. Your TokenCC will need to have been deployed as
well, either from the previous assignment or again for this one. These
were likely done in the deployment section, above.</p>
<p>Submission 3: Register your DEX smart contract with the course-wide
exchange. This, also, was likely done in the deployment section,
above.</p>
<p>Submission 4: Google form! The URL is on the Collab landing page.</p>
</body>
</html>
