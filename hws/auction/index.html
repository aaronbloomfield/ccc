<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Decentralized NFT Auction</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../../markdown.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="decentralized-nft-auction">Decentralized NFT Auction</h1>
<p><a href="../index.html">Go up to the CCC HW page</a> (<a
href="../index.md">md</a>)</p>
<h3 id="overview">Overview</h3>
<p>In this assignment you will write a smart contract, in Solidity, to
handle auctions for NFTs. The NFTs will be ERC-721 tokens.</p>
<p>Once deployed to our private Ethereum blockchain, anybody should be
able to initiate an auction by transferring an NFT to the smart
contract. Anybody could then submit a bid to the auction. To prevent
somebody from placing a bid and then not paying, one has to transfer ETH
to the smart contract when a bid is placed – it is the transfer of this
ETH that actually places the bid. Anybody who is outbid will have their
ETH returned, and they can choose (or not) to place a higher bid. Once
the auction is completed, the ETH from the winning bid is transferred to
the person who initiated the auction, and the NFT is transferred to the
winning bidder.</p>
<h3 id="pre-requisites">Pre-requisites</h3>
<p>Writing this homework will require completion of the following
assignments:</p>
<ul>
<li><a href="../ethprivate/index.html">Connecting to the private
Ethereum blockchain</a> (<a href="../ethprivate/index.md">md</a>)</li>
<li><a href="../dappintro/index.html">dApp introduction</a> (<a
href="../dappintro/index.md">md</a>)</li>
<li><a href="../tokens/index.html">Ethereum Tokens</a> (<a
href="../tokens/index.md">md</a>)</li>
</ul>
<p>Note that this assignment requires that your <a
href="../tokens/index.html">Ethereum Tokens</a> (<a
href="../tokens/index.md">md</a>) assignment is working properly. If you
did not get it working properly, then see the next section.</p>
<p>You will also need to be familiar with the <a
href="../../slides/ethereum.html#/">Ethereum slide set</a>, the <a
href="../../slides/solidity.html#/">Solidity slide set</a>, and the <a
href="../../slides/tokens.html#/">Token slide set</a></p>
<h3 id="task-1-create-some-nft-images-in-your-nftmanager">Task 1: Create
some NFT images in your NFTmanager</h3>
<p>You should use your NFT manager that you wrote and deployed in the <a
href="../tokens/index.html">Ethereum Tokens</a> (<a
href="../tokens/index.md">md</a>) assignment. You can use the previously
deployed version or you can redeploy it, either one is fine. If you were
unable to get yours working in that assignment, then speak to me, and I
will provide an alternative deployed contract for you to use.</p>
<p>You will need to submit the contract address of your NFT manager, and
the transaction hash that deployed it, at the end of this
assignment.</p>
<p>You will need to create a few NFTs, all of which are tagged to
images. You are welcome to use anything in the public domain, including
memes. But nothing inappropriate or otherwise offensive. As before, in
this course, owning the NFT does NOT imply ownership of the image. The
assumption is that you don’t actually own the original image, since it’s
in the public domain. You will need three different NFT images, and you
can reuse the ones you used in the <a
href="../tokens/index.html">Ethereum Tokens</a> (<a
href="../tokens/index.md">md</a>) assignment.</p>
<p>As with the <a href="../tokens/index.html">Ethereum Tokens</a> (<a
href="../tokens/index.md">md</a>) assignment, the images should be in
the <code>ipfs/</code> directory in the Collab Resources tool. Note that
you can upload a file into that folder, but once uploaded you can not
edit it or delete it – this is a setting in Collab, but was done to
mirror the fact that you can’t delete images from the Internet once they
are placed on the web. As it is in the Collab workspace, only those in
the class can view those files – but that means anybody in the class can
view it.</p>
<p>All image file names should start with your userid and an underscore:
<code>mst3k_foo.jpg</code>. You are going to be uploading multiple image
files in a future assignment, so please plan your file naming scheme
appropriately. As long as it starts with your userid and an underscore,
we don’t really care what the rest of the file name is. Only JPEG and
PNG images, please.</p>
<p>You will need three such images to create NFTs for. Make them
interesting! But they must all be different. You can re-use some or all
of your NFT images from the <a href="../tokens/index.html">Ethereum
Tokens</a> (<a href="../tokens/index.md">md</a>) assignment. For those
three images, you can re-use the images you used in the <a
href="../tokens/index.html">Ethereum Tokens</a> (<a
href="../tokens/index.md">md</a>) assignment.</p>
<p>Not surprisingly, you will then need to create NFTs for each of your
images in your deployed <code>NFTmanager</code> smart contract – you are
welcome to do that later as they are needed.</p>
<h3
id="task-2-create-and-deploy-a-decentralized-auction-smart-contract">Task
2: Create and deploy a Decentralized Auction smart contract</h3>
<p>The contract you will be creating will allow for a decentralized
auction for NFTs. The intended flow is as follows:</p>
<ul>
<li>Anybody can create an auction – this involves setting the auction
duration, reserve (minimum) price, etc. This does not <em>start</em> the
auction just yet, but configures all the information for it.
<ul>
<li>The person who started the auction is called the ‘initiator’</li>
<li>There cannot be two auctions of the same NFT going on at the same
time – the contract should revert in this case</li>
</ul></li>
<li>Once ownership of the NFT is transferred to the auction contract,
the auction begins – the length was specified in the previous step.
<ul>
<li>In the situation where somebody creates a second auction before the
first auction has started (meaning calling <code>createAuction()</code>
twice without transferring the NFT to the auction manager between the
two calls), then the second call to <code>createAuction()</code> should
revert.</li>
</ul></li>
<li>Anybody can bid on the auction – a bid is placed by transferring
ether to the auction contract, and specifying which auction it is for
<ul>
<li>If the amount bid is less than the reserve price, then the bid still
goes through – however, this is not a winning bid, as described
below</li>
<li>If the amount bid is less than or equal to the current maximum bid,
then it also fails via a <code>require()</code> or
<code>revert()</code></li>
<li>If the amount bid is (strictly) higher than the previously highest
bid, then the sender is the new winning bidder; the previously highest
winning bidder is refunded his/her ether</li>
</ul></li>
<li>Once we are past the auction end time, the auction can be closed
<ul>
<li>If there are no bids, then the NFT is transferred back to the
initiator</li>
<li>If the highest bid is less than the reserve price, then that bidder
is refunded his/her money, and the NFT is transferred back to the
initiator</li>
<li>If the highest bid is above the reserve price, then the NFT is
transferred to the winning bidder, and the ether is transferred to the
initiator</li>
<li>Once closed, an auction cannot be re-opened, although a new auction
with the same NFT later can be created</li>
</ul></li>
<li>There are three events that must be emitted at the appropriate
times:
<ul>
<li><code>auctionStartEvent()</code>: when the NFT is transferred to the
smart contract and the auction starts (<em>NOT</em> when
<code>createAuction()</code> is called)</li>
<li><code>auctionEndEvent()</code>: when <code>closeAuction()</code>
successfully closes an auction</li>
<li><code>higherBidEvent()</code>: when a new (and higher) bid is placed
on an NFT</li>
</ul></li>
</ul>
<p>Formally the task is to develop an <code>Auctioneer</code> contract
that implements the following <code>AuctionManager</code> interface
below. The provided <a
href="AuctionManager.sol.html">AuctionManager.sol</a> (<a
href="AuctionManager.sol">src</a>) file has more comments for this
interface.</p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import &quot;./IERC721.sol&quot;;
import &quot;./IERC721Receiver.sol&quot;;

interface AuctionManager is IERC165, IERC721Receiver {

    // holds the information for each auction
    struct Auction {
        uint id;            // the auction id
        uint num_bids;      // how many bids have been placed
        string data;        // a text description of the auction or NFT data
        uint highestBid;    // the current highest bid
        uint reserve;       // the minimum bid allowed
        address winner;     // the current highest bidder
        address initiator;  // who started the auction
        address manager;    // the ERC721 contract address that holds the NFT
        uint tokenId;       // the token ID at that ERC721 manager
        uint endTime;       // when the auction will end
        bool active;        // if the auction is active
    }

    function num_auctions() external view returns (uint);

    function auctions(uint _id) external view returns (Auction memory);
    
    function createAuction(uint m, uint h, uint d, string memory _data, uint _reserve) external returns (uint);

    function cancelAuction(uint id);

    function closeAuction(uint _id) external;

    function placeBid(uint _id) payable external;

    function auctionTimeLeft(uint _id) external view returns (uint);


    event auctionStartEvent(uint indexed _id);

    event auctionEndEvent(uint indexed _id);

    event higherBidEvent (uint indexed _id);
}</code></pre>
<p>This interface is provided in the <a
href="AuctionManager.sol.html">AuctionManager.sol</a> (<a
href="AuctionManager.sol">src</a>) file. This interface extends the <a
href="IERC165.sol.html">IERC165.sol</a> (<a href="IERC165.sol">src</a>)
interface, which requires the <code>supportsInterface()</code> function
– your Auctioneer class supports three interfaces (AuctionManager,
IERC165, and IERC721Receiver). You will also need to use the <a
href="IERC721Metadata.sol.html">IERC721Metadata.sol</a> (<a
href="IERC721Metadata.sol">src</a>) interface (and thus the <a
href="IERC721.sol.html">IERC721.sol</a> (<a href="IERC721.sol">src</a>)
interface), as you will be calling methods on the NFT manager, which
implements that interface.</p>
<p>The contract also extends the <a
href="IERC721Receiver.sol.html">IERC721Receiver.sol</a> (<a
href="IERC721Receiver.sol">src</a>) interface:</p>
<pre><code>// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

interface IERC721Receiver {
    function onERC721Received(
        address operator,
        address from,
        uint tokenId,
        bytes calldata data
    ) external returns (bytes4);
}</code></pre>
<p>The <code>onERC721Received()</code> function is called when an ERC721
token is transferred to the smart contract. This was done in the <a
href="../tokens/ERC721.sol.html">ERC721.sol</a> (<a
href="../tokens/ERC721.sol">src</a>) code that your NFTmanager.sol file
extended. The <code>operator</code> parameter is the NFT manager smart
contract, the <code>from</code> is who actually owns the NFT (meaning
the entity starting the auction), the <code>tokenId</code> is the token
number in that NFT manager, and you can ignore the <code>data</code>
parameter (it’s to send extra data if desired). It is by the call to
this function that your Auctioneer knows an NFT has been transferred to
it, and can start an auction. If the NFT is unknown, then a reversion
will cancel the entire NFT transfer. This function needs to return a
confirmation that it acknowledges the receipt of the NFT – to do this,
have the last line of your function return the <a
href="../../slides/tokens.html#/funcsel">function selector</a> for that
function – the line for that is: <code>return
bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"));</code>.</p>
<p>As you are testing it, you will notice in Remix that the button for
<code>placeBid()</code> is red – that is because this is a
<code>payable</code> function. When you call this function, after
setting the correct auction ID as the parameter, you will need to
transfer some ETH along with the call. In the deployment pane in Remix,
just enter a numerical value in the ‘Value’ box, and select the right
denomination (wei, gwei, ether, etc.). That amount of ETH will be
transferred along with the function call. If the call reverts, then you
get that money back (minus the gas fees). If you have a mistake in your
function code, you will likely lose that ETH – this is why we are
practicing on a private blockchain where the ETH has no value.</p>
<p>Some people are having problems in Remix with determining the return
value of a transaction – if this is happening to you, you can create a
function such as <code>getPendingAuctionID()</code> that, given an
address, returns the pending (but not yet started) auction ID for that
address.</p>
<p>Test all this thoroughly in Remix! You will need to deploy both your
NFTManager contract and also your Auctioneer contract in Remix’s
Javascript environment to test them working together. Recall that you
have to select the right contract to deploy in the “Contract” list, else
Remix may not know which one to deploy. <strong><em>We are going to try
to break your contract.</em></strong> So you will need to spend some
time thinking about all the things that you should be checking for, and
also testing it out as much as you can.</p>
<p>One it works, deploy it to our private Ethereum blockchain. You
should test it there as well. You will need to submit the contract
address and transaction hash of the deployed Auctioneer. If you deploy
it multiple times, just submit the most recent contract address. Once it
is deployed to our private Ethereum blockchain, you can view it on the
auctions page, the URL of which is on the Collab landing page. This web
page will make it far easier to see what is going on with your
auctions.</p>
<h3 id="task-3-populate-a-few-auctions">Task 3: Populate a few
auctions</h3>
<p>You should create two auctions in your Auctioneer contract (you’ll
create a third one below as well). It’s fine if you create more (such as
from testing) – we will only look at the two requested here. These two
auctions will use two of your three NFT images. In particular, if you
have one NFT that you like more than the others, or is “better”, you
will want to save it for the course-wide auction, below.</p>
<p>Note that you can perform these calls through Remix (via calling an
external contract, as described in the <a
href="../dappintro/index.html">dApp introduction</a> (<a
href="../dappintro/index.md">md</a>) assignment) or through geth calls
(as described in the <a
href="../../slides/solidity.html#/debtor">Solidity slide set</a>).</p>
<h4 id="auction-1">Auction 1</h4>
<p>The first one should be an auction that has ended by the time you
turn in your assignment. Basically, we want it to be an expired auction.
There should be a few bids on this auction. You can create multiple
accounts for this – just call <code>personal.newAccount()</code> a few
more times – each account is in the <code>eth.accounts</code> list, and
you will have to unlock each one with
<code>personal.unlockAccount()</code>. To get ether into those other
accounts you can:</p>
<ul>
<li>Transfer ETH to that account (see the <a
href="../ethprivate/index.html">Connecting to the private Ethereum
blockchain</a> (<a href="../ethprivate/index.md">md</a>) assignment for
how to do that)</li>
<li>Mine to that account (something like
<code>miner.setEtherbase(eth.accounts[1])</code> – but be sure to change
it back!)</li>
</ul>
<p>You can also get classmates to bid on your auction. This auction will
use the first of your (three) NFTs. The contract address for your
NFTmanager will be submitted as part of the task 2 requirements, above.
You must also submit the auction ID for this auction.</p>
<p>You <em>SHOULD</em> call <code>closeAuction()</code> on this
auction.</p>
<h4 id="auction-2">Auction 2</h4>
<p>The second auction should end <em>two weeks</em> after the assignment
is due. Just get it on the day two weeks later – we don’t really care
about the time, as long as the date is 14 days after the assignment due
date. Basically, we want to see an active auction. This, also, should
have a few bids on it. This auction use the second of your (three) NFTs.
The contract address for your NFTmanager will be submitted as part of
the task 2 requirements, above. You must also submit the auction ID for
this auction.</p>
<h3 id="task-4-participate-in-a-class-wide-auction-manager">Task 4:
Participate in a class-wide auction manager</h3>
<p>We have deployed an auction manager, and the contract address for
that Auctioneer contract is on the Collab landing page. As above, you
can perform these calls through Remix (via calling an external contract,
as described in the <a href="../dappintro/index.html">dApp
introduction</a> (<a href="../dappintro/index.md">md</a>) assignment) or
through geth calls (as described in the <a
href="../../slides/solidity.html#/">Solidity slide set</a>).</p>
<p>You should use the third of your (three) NFTs. You must use
<strong><em>YOUR</em></strong> NFTmanager. You should create an auction
that ends <em>one week</em> after the due date of the assignment (again,
we are looking for the day – we don’t care too much about the time of
day). You will need to submit the transaction hash from when you call
<code>createAuction()</code>, as well as the auction ID from the auction
you created.</p>
<p>Lastly, bid on at least <em>three</em> auctions that are not your
own. Depending on when you submit your assignment, there may not be any
(or any interesting) auctions available to bid on. That’s fine – you
don’t have to have those bids completed by the time the assignment is
due; you have an extra few days to place your bids. We are going to
judge lateness on this assignment by the Gradescope submission time, and
the Google form does not ask for the transaction hashes of the bids. We
are going to check whether you bid on the auctions by looking if your
<code>eth.coinbase</code> account, the address of which you will submit
below, initiated bids on any one of your classmate’s submitted NFT
manager addresses by a few days after the due date.</p>
<p><strong>MAKE YOUR BIDS REASONABLE!!!</strong> If the current highest
bid is 0.5 ETH, don’t suddenly bid 5,000 ETH. Doing so is going to
require others who need to bid on that NFT to have to mine a lot more
ETH, which will increase the blockchain size and the difficulty, which
will make it harder for everybody else in the class. This will make me
very cranky. Any successive bid should be no more than about 1 ETH more
than the previous bid.</p>
<h3 id="submission">Submission</h3>
<p>There are <em>three</em> forms of submission for this assignment; you
must do all three.</p>
<p>Submission 1: You should submit your <code>Auctioneer.sol</code>
file, and ONLY that file, to Gradescope. All your code should be in that
file, and you should specifically import the various interfaces. Those
interface files will be placed in the same directory on Gradescope when
you submit. <strong>NOTE:</strong> Gradescope cannot fully test this
assignment, as it does not have access to the private blockchain. So it
can only do a few sanity tests (correct files submitted, successful
compilation, etc.).</p>
<p>Submission 2: You must deploy those two smart contracts
(<code>NFTmanager</code> and <code>Auctioneer</code>) to our private
Ethereum blockchain. It’s fine if you deploy it a few times to test it.
But the final deployment for the <code>Auctioneer</code> should only
have the data specified in task 3, above. It’s also fine if you use your
<code>NFTmanager</code> from a previous assignment. Save the contract
addresses and transaction hash of these deployments, as you will need to
submit them below.</p>
<p>Submission 3: You will need to submit your information via a Google
form, the link to which is on the Collab landing page. You will need to
submit the following items:</p>
<ul>
<li>Your name &amp; UVA userid</li>
<li>Your account number from <code>eth.coinbase</code>. The assumption
is that you did your tasks from this account (deployed your contract,
the votes, etc.); if you did it from a different account, submit that
account address instead.</li>
<li>From task 1 (NFT images):
<ul>
<li>The contract address and transaction hash of your deployed
NFTmanager contract (this may be the same as in the <a
href="../tokens/index.html">Ethereum Tokens</a> (<a
href="../tokens/index.md">md</a>) assignment)</li>
</ul></li>
<li>From task 2 (Auctioneer): the contract address and transaction hash
of your deployed smart contract</li>
<li>From task 3 (your auctions): the auction ID for the two auctions
(the contract address for the Auctioneer contract is assumed to be the
one from task 2)</li>
<li>From task 4 (class auctions):
<ul>
<li>The auction ID of the auction you created</li>
<li>The transaction hash for each of the three transactions where you
bid on another auction</li>
</ul></li>
</ul>
</body>
</html>
