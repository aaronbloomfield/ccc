<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Bitcoin Blockchain Parser</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../../markdown.css" />
  <script>
  function openTab(evt, tabName) {
    // Declare all variables
    var i, tabcontent, tablinks;

    // Get all elements with class="tabcontent" and hide them
    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i < tabcontent.length; i++) {
      tabcontent[i].style.display = "none";
    }

    // Get all elements with class="tablinks" and remove the class "active"
    tablinks = document.getElementsByClassName("tablinks");
    for (i = 0; i < tablinks.length; i++) {
      tablinks[i].className = tablinks[i].className.replace(" active", "");
    }

    // Show the current tab, and add an "active" class to the button that opened the tab
    document.getElementById(tabName).style.display = "block";
    evt.currentTarget.className += " active";
  }
  </script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="bitcoin-blockchain-parser">Bitcoin Blockchain Parser</h1>
<p><a href="../index.html">Go up to the CCC HW page</a> (<a href="../index.md">md</a>) | <a href="index.html">view tabbed version</a></p>
<h3 id="overview">Overview</h3>
<p>In this assignment you will read in, validate, and then output the Bitcoin blockchain.</p>
<p>Your program will take in a file that contains one or more blocks from the Bitcoin blockchain; these blocks are in binary format. Your program must read these blocks in, check the blockchain for a set of possible errors, and then output the result in JSON format.</p>
<p>Your program will provide exactly one line of output to the standard output: either <code>no errors X blocks</code> (case sensitive! and always pluralize “blocks”) or the specific error and block number (<code>error 5 block 17</code>) – we describe the error numbers below. In the case of multiple errors, your program should report then terminate on the first discovered error. In addition, it will create a JSON file if there were no errors – if the input file name was blk00000.blk, then it will create a JSON file named blk00000.blk.json. If there are errors, it is fine to create the JSON file or not – it will not be checked. The format of this file is described below.</p>
<p>The Bitcoin block format that is being parsed for this assignment is the initial format of the blockchain – specifically before any <a href="https://github.com/bitcoin/bips">BIPs</a> were proposed and enacted. Thus, the blocks will not contain fields such as the height number. Furthermore, the blocks use regular Merkle Trees and not Fast Merkle Trees (which were proposed later).</p>
<p>You will need to be familiar with the <a href="../../slides/bitcoin.html#/">Bitcoin slide set</a>, specifically the first four sections: on <a href="../../slides/bitcoin.html#/merkle">Merkle trees</a>, <a href="../../slides/bitcoin.html#/datatypes">data types used</a>, <a href="../../slides/bitcoin.html#/concepts">Bitcoin concepts and terminology</a>, and the <a href="../../slides/bitcoin.html#/blockchain">blockchain description</a>.</p>
<h3 id="changelog">Changelog</h3>
<p>Any changes to this page will be put here for easy reference. Typo fixes and minor clarifications are not listed here. <!-- So far there aren't any significant changes to report. --></p>
<ul>
<li>Thu, 9/15: added the last bullet point guarantee in the Validation section</li>
</ul>
<h3 id="languages">Languages</h3>
<p>In theory, this can be implemented in any language. In practice, though, it needs to be a language that the auto-graders can compile and run, and that the skeleton code is written for. Four languages that can currently be used: C (using <code>gcc</code>), C++ (using <code>g++</code>), Java (using OpenJDK 11), and Python (using Python 3.10.x). If you want to use a different language, let’s have a chat about it, as it will take some time to ensure that the grading system can handle it. You will have to let us know at least two days before the submission deadline so that we can configure it in time.</p>
<p>This assignment specifically is intended for you to use packages that handle the JSON processing for your programming language. In particular, you may NOT use any cryptocurrency specific libraries (such as the Bitcoin libraries). However, you are welcome to – and probably should – use any JSON libraries.</p>
<p><strong>Python:</strong> To output JSON in Python, you create a dictionary (with nested dictionaries and lists, as necessary), and then use the <code>json</code> library (included with Python) to output the JSON; see <a href="https://www.w3schools.com/python/python_json.asp">here</a> for a tutorial.</p>
<p><strong>Java:</strong> In Java, a number of tutorials (<a href="https://www.javatpoint.com/java-json-example">1</a>, <a href="https://www.tutorialspoint.com/json/json_java_example.htm">2</a>, <a href="https://www.geeksforgeeks.org/working-with-json-data-in-java/">3</a>, etc.) recommend using the <a href="https://github.com/fangyidong/json-simple">json-simple</a> package from <a href="https://www.json.org/json-en.html">json.org</a>; you can download the .jar file from <a href="https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/json-simple/json-simple-1.1.1.jar">here</a>. Version 1.1.1 of that file (<code>json-simple-1.1.1.jar</code>) will be put into the directory along with your source code; thus, you should NOT include it in the files that you submit. To use it you will need to update your classpath on both the compilation (<code>javac -cp json-simple-1.1.1.jar:. BTCParse.java</code>) and execution (<code>java -cp json-simple-1.1.1.jar:. BTCParse</code>); these updates will have to be made to the Makefile and parse.sh files, respectively, that you submit. The first of those tutorials (<a href="https://www.javatpoint.com/java-json-example">this one</a>) has example code that outputs in JSON using this library. Lastly, it’s fine if the compilation line complains about a deprecated API, as long as the compilation result is still successful.</p>
<h3 id="provided-files">Provided files</h3>
<p>We have a number of files of the blockchain itself. Blockchain block counting is indexed from 0 (the genesis block), so a file that contains the first 10 blocks will contain blocks 0-9. Note that not all of the files below contain the genesis block!</p>
<ul>
<li>Files with multiple blocks
<ul>
<li><a href="blk00000-f10.blk">blk00000-f10.blk</a> (2.3 Kb) contains the first 10 blocks</li>
<li><a href="blk00000-f100.blk">blk00000-f100.blk</a> (24 Kb) contains the first 100 blocks</li>
<li>blk00000.blk (125 Mb) contains the first 119,341 Bitcoin blocks. Due to this file’s size, it is not kept in this repository, but can be found on Collab in the Resources tool</li>
</ul></li>
<li>Files with single blocks
<ul>
<li><a href="blk00000-b0.blk">blk00000-b0.blk</a> is block 0, the genesis block</li>
<li><a href="blk00000-b29664.blk">blk00000-b29664.blk</a> is block 29,664, the first block with a compactSize unsigned integer that takes up more than one byte – this may help you ensure you are reading those values in properly; see below for details on where that value is in the block</li>
<li>A number of individual block files to help you ensure that the Merkle tree hashes are computed properly; see below for their purpose. Those block files are blocks <a href="blk00000-b170.blk">170</a>, <a href="blk00000-b546.blk">546</a>, <a href="blk00000-b586.blk">586</a>, <a href="blk00000-b26816.blk">26,816</a>, <a href="blk00000-b2812.blk">2812</a>, <a href="blk00000-b49820.blk">49,820</a>, and <a href="blk00000-b53066.blk">53,066</a></li>
</ul></li>
<li>Helper programs
<ul>
<li><a href="check_genesis_json.py.html">check_genesis_json.py</a> (<a href="check_genesis_json.py">src</a>) will help you ensure that your JSON output is correct – see the comments in the file for a description of how to use it</li>
<li><a href="change_byte.py.html">change_byte.py</a> (<a href="change_byte.py">src</a>) will help with checking for blockchain errors – see below for how to use it</li>
</ul></li>
</ul>
<h3 id="other-files">Other files</h3>
<h4 id="shell-script">Shell script</h4>
<p>As we do not know what language your program will be written in, nor what you will name your executable, you will need to submit a <code>parse.sh</code> shell script for us to call. Such a file for C or C++ might look like:</p>
<pre><code>#!/bin/bash
./a.out $@</code></pre>
<p>The first line must be there exactly as shown (pound sign, then exclamation point, then <code>/bin/bash</code>). For the second line, replace <code>./a.out</code> with how to run your (compiled) program: <code>java BTCBlockChain</code> or <code>python3 btc-parse.py</code> (use <code>python3</code>, not <code>python</code>). Be sure to put the <code>$@</code> on that line as well.</p>
<p>Once created, you will have to ensure it can be executed: <code>chmod 755 parse.sh</code>. You should then be able to run your program via: <code>./parse.sh blk00000.blk</code>.</p>
<p>The following might be what it would look like for Python:</p>
<pre><code>#!/bin/bash
python3 btc-parse.py $@</code></pre>
<p>Be sure to call <code>python3</code>, not <code>python</code> in your shell script! Otherwise it will not work.</p>
<p>And for Java:</p>
<pre><code>#!/bin/bash
java BTCParse $@</code></pre>
<p>Note that you may have to add a flag to modify the class path if you are using the suggested JSON library in Java, as described in the Languages section above. If so, your parse.sh file may look something like this:</p>
<pre><code>#!/bin/bash
java -cp json-simple-1.1.1.jar:. BTCParse $@</code></pre>
<h4 id="makefile">Makefile</h4>
<p>You will also have to submit a <code>Makefile</code> that will be used to compile your program, if needed. For languages that do not need compilation (such as Python), just put in a single <code>echo</code> statement so that <code>make</code> still runs properly. This is the same as in the <a href="../intro/index.html">previous assignments</a> (<a href="../intro/index.md">md</a>).</p>
<h3 id="part-1-parsing">Part 1: Parsing</h3>
<p>Your program will take in exactly one command-line parameter: the file to read in. You can assume that there will always be one command line parameter provided, and that that file will exist. Sample files are provided above – both large and small.</p>
<h4 id="block-group-file-format">Block group file format</h4>
<p>The blocks to be verified are grouped together in a file – this file is from the Bitcoin system, and if you were to launch a Bitcoin node and have it sync the blockchain, you would have those files on your machine as well. The largest file we provide contains block 0 (the genesis block) through block 119,340.</p>
<p>To see the contents of a binary file, run it through <code>hexdump -C</code> on a Linux / UNIX system. Make sure you use the <code>-C</code> parameter! This will print a LOT of text, so we will pipe it through <code>head</code>, as shown below. Each block is preceded by 8 bytes of data. The first 4 bytes are the magic number, and the second four bytes are the block size. Both are in little-Endian format in the file. The output of the genesis block, when run through <code>hexdump -C</code>, are:</p>
<pre><code>$ hexdump -C blk00000-f10.blk | head -13
00000000  f9 be b4 d9 1d 01 00 00  01 00 00 00 00 00 00 00  |................|
00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000020  00 00 00 00 00 00 00 00  00 00 00 00 3b a3 ed fd  |............;...|
00000030  7a 7b 12 b2 7a c7 2c 3e  67 76 8f 61 7f c8 1b c3  |z{..z.,&gt;gv.a....|
00000040  88 8a 51 32 3a 9f b8 aa  4b 1e 5e 4a 29 ab 5f 49  |..Q2:...K.^J)._I|
00000050  ff ff 00 1d 1d ac 2b 7c  01 01 00 00 00 01 00 00  |......+|........|
00000060  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 ff ff  |................|
00000080  ff ff 4d 04 ff ff 00 1d  01 04 45 54 68 65 20 54  |..M.......EThe T|
00000090  69 6d 65 73 20 30 33 2f  4a 61 6e 2f 32 30 30 39  |imes 03/Jan/2009|
000000a0  20 43 68 61 6e 63 65 6c  6c 6f 72 20 6f 6e 20 62  | Chancellor on b|
000000b0  72 69 6e 6b 20 6f 66 20  73 65 63 6f 6e 64 20 62  |rink of second b|
000000c0  61 69 6c 6f 75 74 20 66  6f 72 20 62 61 6e 6b 73  |ailout for banks|
$</code></pre>
<p>The file specified on the command line in the execution above has the first 10 blocks, and would create 145 lines of output; we only want the beginning, so we pipe it through <code>head -13</code> to get the first 13 lines of the hexdump output.</p>
<p>Each line displays 16 bytes from the file. The columns in hexdump shows the address of the first byte in the row (in hex), the hex values of the 16 bytes, and an ASCII representation of those 16 bytes (if they are printable characters; a period is used if they are not printable characters). You can see, at the bottom of the hexdump display above, the text included in the genesis block for Bitcoin (“The Times 03/Jan/2009 Chancellor on brink of second bailout for banks”). You may want to save the hexdump output to a file (<code>hexdump -C blk00000.blk &gt; blk00000.blk.txt</code>). If you do this with some of the larger blockchain files, be aware that the hexdump output can be quite large – up to 631 Mb for the largest file we provide in this assignment.</p>
<p>The first four bytes (<code>f9 be b4 d9</code>) is the so-called “magic number” which identifies the start of a block in a file. The value is 0xd9b4bef9, or 0xf9beb4d9 in little-Endian. The next four bytes (<code>1d 01 00 00</code>) are the size. That’s in little-Endian, so converted to big-Endian it’s 0x0000011d = 285. The next 285 bytes are the contents of block 0 (the genesis block). Block 1 thus starts at byte 285+8=293 (0x125 in hex) in the file. You can see this later in the hexdump output (not shown above because of the <code>head -13</code> pipe):</p>
<pre><code>00000110  5c 38 4d f7 ba 0b 8d 57  8a 4c 70 2b 6b f1 1d 5f  |\8M....W.Lp+k.._|
00000120  ac 00 00 00 00 f9 be b4  d9 d7 00 00 00 01 00 00  |................|
00000130  00 6f e2 8c 0a b6 f1 b3  72 c1 a6 a2 46 ae 63 f7  |.o......r...F.c.|</code></pre>
<p>On the second line, the magic number (<code>f9 be b4 d9</code>) of the second block (block index 1) starts on the 6th byte.</p>
<h4 id="reading-in-the-blockchain">Reading in the blockchain</h4>
<p>Your task is to read in the blockchain. The format for the blockchain can be found in the <a href="../../slides/bitcoin.html#/">Bitcoin lecture slides</a>, specifically starting <a href="../../slides/bitcoin.html#/blockchain">here</a>. You will need to read in the file in binary format.</p>
<p>You will likely want to print out the data read in (and the associated fields). This will be changed to a different output format in part 3, below. As you are printing out the values, you can see what they should be <a href="https://www.blockchain.com/btc/block/0">here</a> for block 0; the output is also shown below. That site prints the values in big-Endian, which is how we will be printing them in this assignment. However, we are going to print out the nBits field in hex; that site prints it out in decimal.</p>
<p>Some useful hints:</p>
<ul>
<li>There really are only five different types in the bitcoin blockchain: 4-byte unsigned integers, 8-byte unsigned integers, compactSize unsigned integers, 32-byte hashes, and variable-length scripts. That’s it. All of the blockchain is one of these five types – so you can reuse your code from reading in one type to read in another value of that type.</li>
<li>While there are only 5 types, we will be outputting them in different ways – but each programming language can easily print a number in hex or decimal.</li>
<li>Make sure you have a method that reads in compactSize unsigned integers properly, as this will cause your program to crash otherwise. In particular, remember that if the variable is more than one byte, then all the bytes <em>other</em> than the first are in little-Endian format. HOWEVER, some routines that read in the values will swap them for you, and some will not. This is explicitly why we provide <a href="blk00000-b29664.blk">block 29,664</a> for you – that is the first block that has such a compactSize unsigned int value that is more than one byte (the <code>txn_in_count</code> for the second transaction is 320); you can see more information about that transaction <a href="https://blockchair.com/bitcoin/block/29664">here</a>.</li>
</ul>
<p>If you can read in all of the input files – especially the large one – without any errors, then you’ve successfully completed this part. Note that you may want to redirect your output to a file, since that’s a lot of text to be output to the screen.</p>
<h3 id="part-2a-validation">Part 2a: Validation</h3>
<p>Now that you can read in valid blockchain, your program should be extended to check for errors in the blockchain. Once an error is encountered, the program should output the error number and exit. The errors below are what should be checked for – note that these are not all the possible errors, but a selection of errors to check for in this assignment.</p>
<ol type="1">
<li>Invalid magic number</li>
<li>Invalid header version (we only are allowing version 1 for this assignment)</li>
<li>Invalid previous header hash (this is not checked for the first block in the file, since we don’t know the previous block)</li>
<li>Invalid timestamp (it needs to be no earlier than 2 hours before that of the previous block (this is a simplification of the <a href="https://en.bitcoin.it/wiki/Block_timestamp">actual requirements</a>); this is not checked for the first block in the file)</li>
<li>Invalid transaction version (we are only allowing version 1 for this assignment)</li>
<li>The Merkle tree hash in the header is incorrect (implement this last – see below)</li>
</ol>
<p>If an error is found, the output should only be <code>error 5 block 17</code> with the appropriate error number and block number (remember that blocks start counting at 0, not 1). If no errors are found, then the output should only be “no errors X blocks”, where ‘X’ is an integer. (We are going to use the plural “blocks” even when there is only 1 block).</p>
<p>If there are multiple errors, you should report the one found in the earlier block and then exit. For example, if there is a modification to the Merkle hash in block 10, then both block 10 will have an error (#6 – bad Merkle hash) as well as block 11 (#3 – bad previous header hash). In this case, the error in block 10 should be reported, and the program should then exit.</p>
<p>If there are multiple errors in a single block, you can report any one of them and then exit. Because this makes it very difficult to grade, we are going to avoid testing this possibility when grading your assignment.</p>
<p>Test this well! We are going to provide all sorts of messed-up files to your program as input. The file provided to your program may not even be a valid blockchain file! You are guaranteed that the following will be true:</p>
<ul>
<li>The file name specified as the command-line parameter will exist, will be readable, and will be non-zero in size; you do not have to check for these three things</li>
<li>The blocks – if they exist – will be consecutive in the file
<ul>
<li>This means that the block order will be 0,1,2,3,4,… – not, for example 0,2,1,4,3,…</li>
<li>Formally, this means that the previous header hash for a given block will be for the block immediately preceding it in the file (obviously this doesn’t apply for the first block in the file)</li>
<li>Note that the actual Bitcoin block chain files downloaded by the BTC client do not assure they are in order!</li>
</ul></li>
<li>There will be no ‘orphan’ blocks – each block will be the successor to the block immediately before it
<ul>
<li>Obviously that doesn’t apply to the first block in the file</li>
</ul></li>
<li>If there is an error in the file, it will be one of the 6 errors listed above. Other errors that may occur are not ones that you have to check for. As an example, an error where the block size (the send half of the preamble) is larger than the file size is not one of the errors listed above, so we will not provide a file with that type of error.</li>
</ul>
<p>Note that if you are printing out the blockchain data to standard output from the previous section, you should just terminate the program with the “no errors X blocks” or “error 5 block 17” line – we’ll get rid of the other output in the next section.</p>
<h3 id="testing">Testing</h3>
<p>To test each error, you should try to change one byte in the file – specifically, a byte in the particular field you are checking for errors. For example, if you want to modify the magic number, you would change one of the first 4 bytes; as bytes are indexed from zero, that’s bytes 0, 1, 2, or 3. To do that, you can use the following Python program, which you can save as <code>change_byte.py</code>:</p>
<pre><code>#!/usr/bin/python3
import sys
assert (len(sys.argv)==3)
data = bytearray(sys.stdin.buffer.read())
data[int(sys.argv[1])] = int(sys.argv[2])
sys.stdout.buffer.write(bytes(data))</code></pre>
<p>This can also be downloaded via <a href="change_byte.py.html">change_byte.py</a> (<a href="change_byte.py">src</a>). Yes, this program could be compacted more, but then it would be even more unreadable. This program will read in binary data from standard input, change the one byte specified via the command line arguments, and write the resulting data to standard output. It takes in two command-line parameters: the byte number to change, and the value to change it to, in that order; both are decimal numbers. There is no error checking in this program! You would use it as such:</p>
<pre><code>$ cat blk00000-f10.blk | ./change_byte.py 2 0 &gt; test.blk
$ ./parse.sh test.blk
error 1 block 0
$</code></pre>
<p>The first line may be different on your machine (especially if you use Windows), and it may be invoked slightly differently than what is shown below. Here are a few more execution runs to show you both successful execution runs and runs with some errors. You should test it beyond these! We are certainly going to when we grade your assignment…</p>
<pre><code>$ ./parse.sh ~/Dropbox/git/ccc/hws/btcparser/blk00000-b0.blk 
no errors 1 blocks
$ ./parse.sh ~/Dropbox/git/ccc/hws/btcparser/blk00000-f10.blk 
no errors 10 blocks
$ ./parse.sh ~/Dropbox/git/ccc/hws/btcparser/blk00000-f100.blk 
no errors 100 blocks
$ ./parse.sh blk00000.blk 
no errors 119341 blocks
$ cat blk00000-f10.blk | ./change_byte.py 2 0 &gt; test.blk
$ ./parse.sh test.blk 
error 1 block 0
$ cat blk00000-f10.blk | ./change_byte.py 10 7 &gt; test.blk
$ ./parse.sh test.blk 
error 2 block 0
$ cat blk00000-f10.blk | ./change_byte.py 14 3 &gt; test.blk
$ ./parse.sh test.blk 
error 3 block 1
$ cat blk00000-f10.blk | ./change_byte.py 310 23 &gt; test.blk
$ ./parse.sh test.blk 
error 3 block 1
$ cat blk00000-f10.blk | ./change_byte.py 372 0 &gt; test.blk
$ ./parse.sh test.blk 
error 4 block 1
$ cat blk00000-f10.blk | ./change_byte.py 89 17 &gt; test.blk
$ ./parse.sh test.blk 
error 5 block 0
$ cat blk00000-f10.blk | ./change_byte.py 46 3 &gt; test.blk
$ ./parse.sh test.blk 
error 6 block 0
$</code></pre>
<p>These test are by no means comprehensive! But some of these examples will be used for the visible tests when you submit the file to Gradescope. The hidden tests, which your grade will be based on similar tests different than the ones shown above.</p>
<h3 id="part-2b-merkle-trees">Part 2b: Merkle Trees</h3>
<p>Validating the Merkle Tree hashes is likely the hardest part of the assignment. Work on this last, as you can still get a lot of partial credit if this part is not implemented. In particular, you may want to ensure that the JSON output, below, is working first before you complete this part.</p>
<p>The computation of the Merkle tree root hash is <a href="../../slides/bitcoin.html#/merkle">discussed in the lecture slides</a>. You will need to be familiar with that before proceeding. It is expected that you will use the SHA-256 hashing programs that come with your programming language; use of these is discussed in the last few slides of the <a href="../../slides/encryption.html#/hashing">hashing section of the Encryption slide set</a>.</p>
<p>Some important notes to remember:</p>
<ul>
<li>The hashes for the children nodes are concatenated, and then the hash of that concatenation is used in the level above</li>
<li>If there is an odd number of hashes in a given level, then the last one is concatenated to itself, and the hash of that is used in the level above</li>
<li>The hashes need to be in binary little-Endian form; the binary form is 32 bytes long</li>
<li>Bitcoin uses a double hashing, so each hash is really the sha256 hash of the sha256 hash of the data itself</li>
<li>This assignment is <em>NOT</em> using Fast Merkle trees</li>
</ul>
<p>For testing the Merkle tree hashes, we provide a few particular blocks that have a given number of transactions. The “Block xxx” link is to a blockchain explorer, which displays the value of the Merkle tree hash.</p>
<ul>
<li><a href="https://www.blockchain.com/btc/block/170">Block 170</a>, in file <a href="blk00000-b170.blk">blk00000-b170.blk</a>, is the first block with 2 transactions</li>
<li><a href="https://www.blockchain.com/btc/block/586">Block 586</a>, in file <a href="blk00000-b586.blk">blk00000-b586.blk</a>, is the first block with 3 transactions</li>
<li><a href="https://www.blockchain.com/btc/block/546">Block 546</a>, in file <a href="blk00000-b546.blk">blk00000-b546.blk</a>, is the first block with 4 transactions</li>
<li><a href="https://www.blockchain.com/btc/block/26816">Block 26,816</a>, in file <a href="blk00000-b26816.blk">blk00000-b26816.blk</a>, is the first block with 5 transactions</li>
<li><a href="https://www.blockchain.com/btc/block/2812">Block 2,812</a>, in file <a href="blk00000-b2812.blk">blk00000-b2812.blk</a>, is the first block with 6 transactions</li>
<li><a href="https://www.blockchain.com/btc/block/49820">Block 49,820</a>, in file <a href="blk00000-b49820.blk">blk00000-b49820.blk</a>, is the first block with 7 transactions</li>
<li><a href="https://www.blockchain.com/btc/block/53066">Block 53,066</a>, in file <a href="blk00000-b53066.blk">blk00000-b53066.blk</a>, is the first block with 8 transactions</li>
</ul>
<h4 id="merkle-tree-example">Merkle tree example</h4>
<p>To help you ensure that you are computing the Merkle tree hash properly, here is a worked-out example. The code below is Python, but can be reproduced in any language. The intermediate values shown below will help you ensure each step works in whatever language you are developing this assignment in.</p>
<p>This is the data from the genesis block:</p>
<pre><code>$ hexdump -C blk00000-b0.blk
00000000  f9 be b4 d9 1d 01 00 00  01 00 00 00 00 00 00 00  |................| 
00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................| 
00000020  00 00 00 00 00 00 00 00  00 00 00 00 3b a3 ed fd  |............;...| 
00000030  7a 7b 12 b2 7a c7 2c 3e  67 76 8f 61 7f c8 1b c3  |z{..z.,&gt;gv.a....| 
00000040  88 8a 51 32 3a 9f b8 aa  4b 1e 5e 4a 29 ab 5f 49  |..Q2:...K.^J)._I| 
00000050  ff ff 00 1d 1d ac 2b 7c  01 01 00 00 00 01 00 00  |......+|........| 
00000060  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................| 
00000070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 ff ff  |................| 
00000080  ff ff 4d 04 ff ff 00 1d  01 04 45 54 68 65 20 54  |..M.......EThe T| 
00000090  69 6d 65 73 20 30 33 2f  4a 61 6e 2f 32 30 30 39  |imes 03/Jan/2009| 
000000a0  20 43 68 61 6e 63 65 6c  6c 6f 72 20 6f 6e 20 62  | Chancellor on b| 
000000b0  72 69 6e 6b 20 6f 66 20  73 65 63 6f 6e 64 20 62  |rink of second b| 
000000c0  61 69 6c 6f 75 74 20 66  6f 72 20 62 61 6e 6b 73  |ailout for banks| 
000000d0  ff ff ff ff 01 00 f2 05  2a 01 00 00 00 43 41 04  |........*....CA.| 
000000e0  67 8a fd b0 fe 55 48 27  19 67 f1 a6 71 30 b7 10  |g....UH&#39;.g..q0..| 
000000f0  5c d6 a8 28 e0 39 09 a6  79 62 e0 ea 1f 61 de b6  |\..(.9..yb...a..| 
00000100  49 f6 bc 3f 4c ef 38 c4  f3 55 04 e5 1e c1 12 de  |I..?L.8..U......| 
00000110  5c 38 4d f7 ba 0b 8d 57  8a 4c 70 2b 6b f1 1d 5f  |\8M....W.Lp+k.._| 
00000120  ac 00 00 00 00                                    |.....| 
00000125
$</code></pre>
<p>There is only one transaction in this block. With a preamble of 8 bytes, a header of 80 bytes, and a transaction count of 1 byte (since it’s a compactSize unsigned integer with value of 1), the transaction has to start at byte 89 (0x59). This is the row with address 0x00000050, and the start of the transaction is the last 7 bytes on that line (<code>01 00 00 00 01 00 00</code>), and continues until the end of the block.</p>
<p>Putting all those bytes together gives us the (ASCII) hex of the transaction, which is stored in a <code>txn</code> variable:</p>
<pre><code>txn=&quot;01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000&quot;</code></pre>
<p>In binary, the transaction is 204 bytes long. As the hex representation above uses two characters for one (binary) byte, the string above is 408 characters long.</p>
<p>Because there is only one transaction, the hash of the hash of that transaction is also the Merkle tree root. So we get the sha256(sha256()) hash of that data, which we have to convert to binary form first:</p>
<pre><code>$ python3
&gt;&gt;&gt; # enter txn = ... as above
&gt;&gt;&gt; from hashlib import sha256 
&gt;&gt;&gt; txn_data = bytes.fromhex(txn) 
&gt;&gt;&gt; hash1 = sha256(txn_data).digest() 
&gt;&gt;&gt; hash2 = sha256(hash1).hexdigest() 
&gt;&gt;&gt; hash2 
&#39;3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a&#39; 
&gt;&gt;&gt;</code></pre>
<p>In Python, given a hash, the <code>.digest()</code> method returns it in binary format, and the <code>.hexdigest()</code> method returns it in an ASCII hex representation.</p>
<p>This is the Merkle tree root in the <a href="https://en.bitcoin.it/wiki/Genesis_block">genesis block</a>, displayed in big-Endian format. Thus, our Endian-ness is reversed from what is displayed in the block. So we can un-reverse (?) it; note that we are recomputing <code>hash2</code> with <code>.digest()</code>, rather than <code>.hexdigest()</code>, to get it’s value in binary:</p>
<pre><code>&gt;&gt;&gt; hash2 = sha256(hash1).digest() 
&gt;&gt;&gt; hash2ba = bytearray(hash2) 
&gt;&gt;&gt; hash2ba.reverse() 
&gt;&gt;&gt; hash = &#39;&#39;.join(format(x, &#39;02x&#39;) for x in hash2ba)       
&gt;&gt;&gt; hash 
&#39;4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b&#39; 
&gt;&gt;&gt;</code></pre>
<p>Now that the hash is in little-Endian format, the hex of the hash exactly matches what is listed in the <a href="https://en.bitcoin.it/wiki/Genesis_block">genesis block</a>. This is also displayed in the block:</p>
<p>And then we can get all fancy and do all that in one line:</p>
<pre><code>&gt;&gt;&gt; # enter txn = ... as above
&gt;&gt;&gt; from hashlib import sha256 
&gt;&gt;&gt; &#39;&#39;.join(format(x, &#39;02x&#39;) for x in reversed(bytearray(sha256(sha256(bytes.fromhex(txn)).digest()).digest())))
&#39;4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b&#39; 
&gt;&gt;&gt;</code></pre>
<p>Got that? Good.</p>
<h3 id="part-3-output">Part 3: Output</h3>
<p>Your program must output the blockchain in JSON format. You can read about <a href="https://en.wikipedia.org/wiki/JSON">JSON on Wikipedia</a>. The format must be as described below, but your whitespace doesn’t matter. We are going to check it via a JSON parser.</p>
<p>You SHOULD be using the JSON library that comes with your programming language! No need to reinvent the wheel here. It is VERY tedious to hand-code JSON output. See the Languages section, above, for how to do this.</p>
<p>Your output for the genesis block (file blk00000-b0.blk), which is saved to a file, should look like the following:</p>
<pre><code>{
    &quot;blocks&quot;: [
        {
            &quot;height&quot;: 0,
            &quot;file_position&quot;: 0,
            &quot;version&quot;: 1,
            &quot;previous_hash&quot;: &quot;0000000000000000000000000000000000000000000000000000000000000000&quot;,
            &quot;merkle_hash&quot;: &quot;4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b&quot;,
            &quot;timestamp&quot;: 1231006505,
            &quot;timestamp_readable&quot;: &quot;2009-01-03 13:15:05&quot;,
            &quot;nbits&quot;: &quot;1d00ffff&quot;,
            &quot;nonce&quot;: 2083236893,
            &quot;txn_count&quot;: 1,
            &quot;transactions&quot;: [
                {
                    &quot;version&quot;: 1,
                    &quot;txn_in_count&quot;: 1,
                    &quot;txn_inputs&quot;: [
                        {
                            &quot;utxo_hash&quot;: &quot;0000000000000000000000000000000000000000000000000000000000000000&quot;,
                            &quot;index&quot;: 4294967295,
                            &quot;input_script_size&quot;: 77,
                            &quot;input_script_bytes&quot;: &quot;04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73&quot;,
                            &quot;sequence&quot;: 4294967295
                        }
                    ],
                    &quot;txn_out_count&quot;: 1,
                    &quot;txn_outputs&quot;: [
                        {
                            &quot;satoshis&quot;: 5000000000,
                            &quot;output_script_size&quot;: 67,
                            &quot;output_script_bytes&quot;: &quot;4104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac&quot;
                        }
                    ],
                    &quot;lock_time&quot;: 0
                }
            ]
        }
    ],
    &quot;height&quot;: 1
}</code></pre>
<p>A bunch of notes:</p>
<ul>
<li>We don’t need to list the magic number in the JSON file – it’s always the same, and was verified when the blockchain was read in (technically it’s not part of the block, it’s part of the file format)</li>
<li>Likewise, we don’t need to include the block size, since that’s not as important in JSON</li>
<li>You can put in additional fields if you would like – but the fields shown above must be there; the only exception is that, in the output above, both <code>timestamp_readable</code> and <code>file_position</code> are NOT required fields</li>
<li>Hexadecimal values should NOT have a leading ‘0x’</li>
<li>Integer values should not have quotes around them (that’s a JSON feature), but all other values should be enclosed in double quotes (not single quotes – a JSON restriction)</li>
<li>If you have a list if items in an array, JSON is not happy with a comma after the last one; you can see this after the ‘lock_time’ value – there is no comma after its value 0 (yes, this is stupid, but that’s JSON for you)</li>
<li>You’ll notice that the ‘height’ field is at the end – you won’t know, when starting to read the file, how many blocks are therein. So we put that at the end. This is just the total number of blocks in the file.</li>
<li>For the numerical values, the only ones that are in hex (again, without the leading ‘0x’) are the hashes (previous header, merkle, and utxo), the scripts (input and output), and nbits. All other numerical values, including the two times (timestamp and locktime) should be base-10.</li>
<li>All hash values should be printed in big-Endian. Note that they are stored in the file in little-Endian!</li>
<li>The height of the first block in the file should be displayed as 0, even if it is not the genesis block; the height increments from there.</li>
<li>The script data itself should be output in the exact order that it occurs in the file. You can see what that data is for the genesis block <a href="https://en.bitcoin.it/wiki/Genesis_block">here</a>.</li>
</ul>
<p>In particular, this JSON output need to be written to a file, NOT to standard output. The file name will just append “.json” to the input file name. If you are writing this file as you go, and you encounter an error, it’s fine if you have a partially written JSON file – we aren’t going to check it if there are errors.</p>
<p>You can verify that it is valid JSON by running it through JSON’s lint: <code>jsonlint-php blk00000-first10.blk.json</code>. This program is installed on the Linux VirtualBox image. If you not using VirtualBox, you can install it yourself, or use online sites such as <a href="https://jsonlint.com/">these</a>. You can also use a one-line Python command to test it:</p>
<pre><code>$ cat blk00000-b0.blk.json | python3 -c &quot;import json,sys; json.load(sys.stdin)&quot;
$</code></pre>
<p>If there is no output (specifically, no error output), then it was parsed correctly.</p>
<p>Make sure you test it with multiple blocks! However, the online site will probably not like you trying to upload a huge JSON file.</p>
<p>You should also use the <a href="check_genesis_json.py.html">check_genesis_json.py</a> (<a href="check_genesis_json.py">src</a>) program to ensure that your JSON is in the right format AND ALSO that the values are correct. This is intended to ensure that you have the right fields for when we grade the assignment. It just has a bunch of <code>assert()</code> calls to ensure that the format is what is shown above. Remember that white space doesn’t matter, so you are welcome to use any spacing that you want. And you can add fields, if you would like. This program will also be used as one of the visible submission tests in Gradescope.</p>
<h3 id="submission">Submission</h3>
<p>You must submit three files:</p>
<ul>
<li><code>Makefile</code>: if your program needs compilation, then running <code>make</code> will perform that compilation. If it does not need compiling, then just have something such as <code>echo "hello world"</code> as the action for the default target.</li>
<li><code>parse.sh</code>: a bash script that will execute your (compiled) program with any provided command-line options. An example of this is shown above.</li>
<li>The source code itself, likely something like <code>btcscript.py</code> or <code>BTCScript.java</code></li>
</ul>
</body>
</html>
