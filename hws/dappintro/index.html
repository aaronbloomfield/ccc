<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' lang='' xml:lang=''>
<head>
  <meta charset='utf-8'></meta>
  <meta name='generator' content='pandoc'></meta>
  <meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=yes'></meta>
  <title>dApp Introduction</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel='stylesheet' href='../../markdown.css'></link>
  <script>
  function openTab(evt, tabName) {
    // Declare all variables
    var i, tabcontent, tablinks;

    // Get all elements with class="tabcontent" and hide them
    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i < tabcontent.length; i++) {
      tabcontent[i].style.display = "none";
    }

    // Get all elements with class="tablinks" and remove the class "active"
    tablinks = document.getElementsByClassName("tablinks");
    for (i = 0; i < tablinks.length; i++) {
      tablinks[i].className = tablinks[i].className.replace(" active", "");
    }

    // Show the current tab, and add an "active" class to the button that opened the tab
    document.getElementById(tabName).style.display = "block";
    evt.currentTarget.className += " active";
  }
  </script>
  
</head>
<body>
<h1 id='dapp-introduction'>dApp Introduction</h1>
<p><a href='../index.html'>Go up to the CCC HW page</a> (<a href='../index.md'>md</a>) | <a href='index-full.html'>view one-page version</a></p><div class='tab'>
<button class='tablinks' onclick="openTab(event,'toverview')" id='defaultOpen'>Overview</button>
<button class='tablinks' onclick="openTab(event,'tchangelog')">Changelog</button>
<button class='tablinks' onclick="openTab(event,'tintroduction')">Introduction</button>
<button class='tablinks' onclick="openTab(event,'tcode-base')">Code Base</button>
<button class='tablinks' onclick="openTab(event,'thints')">Hints</button>
<button class='tablinks' onclick="openTab(event,'tpart-1-remix')">Remix</button>
<button class='tablinks' onclick="openTab(event,'tpart-2-testing')">Testing</button>
<button class='tablinks' onclick="openTab(event,'tpart-3-deployment')">Deployment</button>
<button class='tablinks' onclick="openTab(event,'tpart-4-web-interface')">Web Interface</button>
<button class='tablinks' onclick="openTab(event,'tpart-5-vote')">Vote</button>
<button class='tablinks' onclick="openTab(event,'tpart-6-closing-down')">Closing Down</button>
<button class='tablinks' onclick="openTab(event,'tsubmission')">Submission</button>
</div>
<div id='toverview' class='tabcontent'><h3 id='overview'>Overview</h3>
<p>This homework will take you through the process of compiling, deploying, and running a decentralized application (dApp) on our private Ethereum blockchain. This assignment does not focus on the programming aspects of Solidity – that’s in a future assignment, as well as the lectures.</p>
<p>You will have to have completed the <a href='../ethprivate/index.html'>connecting to the private Ethereum blockchain</a> assignment. You should have a few (fake) ETH from the faucet. For some of the tasks below you will need to launch your geth node, connecting to the course server, and start up a geth Javascript terminal; how to do all that is all described in the <a href='../ethprivate/index.html'>connecting to the private Ethereum blockchain</a> (<a href='../ethprivate/index.md'>md</a>) assignment. If you have not successfully completed that assignment then you will not be able to complete this assignment.</p>
<p>Warning to Mac OS X users: there is one part in this assignment that Safari seems to have issues with. This part is indicated when you get to it, and you may have to switch to a different browser (Firefox or Chrome) to complete that part.</p>
<p>Giving credit where credit is due: The particular smart contract being used here was inspired by the one in <a href='https://github.com/dappuniversity/election'>this github repo</a> by Dapp University (disclaimer: they are not an actual accredited university; but they do have great online tutorials).</p>
</div><div id='tchangelog' class='tabcontent'><h3 id='changelog'>Changelog</h3>
<p>Any changes to this page will be put here for easy reference. Typo fixes and minor clarifications are not listed here. So far there aren’t any significant changes to report.</p>
</div><div id='tintroduction' class='tabcontent'><h3 id='introduction'>Introduction</h3>
<p>To deploy and run a smart contract, you need to be able to the standard development tasks – editing, compilation, testing, and deployment. The third one – testing – is tricky, as you have to be running in an environment that simulates a blockchain and (fake) accounts with (fake) ETH. Once it’s compiled, you have to then be able to load it onto the blockchain, whether that blockchain is simulated (for testing) or real (for deployment).</p>
<p>For the development tasks, we are going to use <a href='http://remix.ethereum.org'>Remix</a>, which is an IDE designed specifically for Solidity smart contracts on an Ethereum blockchain. You can use it online at <a href='http://remix.ethereum.org'>remix.ethereum.org</a>, or you can download the latest version on your computer via <a href='https://github.com/ethereum/remix-desktop/releases'>remix’s github repo</a>. Each method has it’s pros and cons.</p>
<ul>
<li><strong>Online Remix:</strong> The online site, at <a href='https://remix.ethereum.org'>remix.ethereum.org</a>, is quick to use, doesn’t require installation, but does not save your changes to your local drive – you have to edit it locally and then copy/paste it into Remix. The files that it saves remotely are tied to a cookie in your browser, which will mean you cannot edit those online files from a different browser (but you can copy/paste them in again if you have saved them locally). If you do want to go this route, we suggest editing your code with <a href='https://www.sublimetext.com/'>sublime</a> with the <a href='https://packagecontrol.io/packages/Ethereum'>Ethereum package</a> installed. And if you make edits to the file on the Remix web page, you have to cut-and-paste that back into the local file on your computer so that you have an updated local copy. In the past, people have had issues with different browsers. Chrome and Firefox are known to work, but Safari seems to have issues with deployment. For the last assignment in this course you will have to use Chrome.</li>
<li><strong>Desktop Remix:</strong> The other option – installing Remix locally – requires going through the installation process (which is really quick), but makes it much easier to develop locally. In the past there were some bugs that caused issues, but they were solvable. To download the package for your OS, see the <a href='https://github.com/ethereum/remix-desktop/releases'>Remix download page</a>. If the desktop version starts running really slowly, try restarting the application.</li>
</ul>
<p>We recommend to download and install the desktop version, despite the occasional issues, but the choice is yours. If you do try the desktop version, and it is not working well, you can always switch to the online version. The directions herein will apply to both options, as the user interface is the same. Note that all of these tools (the Remix IDE and Sublime with the Ethereum package) are already installed on the VirtualBox image. Remix’s source code is <a href='https://github.com/ethereum/remix-project'>available on github</a>, and it is <a href='https://github.com/ethereum/remix-project/blob/master/LICENSE'>released under the MIT license</a>; some of the Remix icons are included herein.</p>
<p>Remix allows you to develop, compile, and test your code on a simulated blockchain with fake accounts. It cannot, all by itself, deploy to a blockchain. For that, we are going to use geth. We will connect Remix to geth for our deployment, and geth will be the conduit to deploy to the blockchain. More on this later in the assignment.</p>
<p>There are many different tool chains that one can use to compile and deploy smart contracts – Truffle and Ganache, command-line compilation with solc and deployment with geth, etc. We had to pick one, and Remix seemed the most straight-forward and logical choice. We will see how to interact with the blockchain through the geth Javascript console in an in-class activity in the <a href='../../slides/solidity.html#/'>Solidity lecture slide set</a>.</p>
<p>The same process described herein can be used to deploy on the real Ethereum blockchain. The only difference is that you would run geth to connect to the real Ethereum blockchain, rather than our private course blockchain. And of course you would need real Ethereum to pay for the gas fees. Everything else stays exactly the same.</p>
</div><div id='tcode-base' class='tabcontent'><h3 id='code-base'>Code base</h3>
<p>For this assignment we will be providing the Solidity code to use: the interface <a href='IPoll.sol.html'>IPoll.sol</a> (<a href='IPoll.sol'>src</a>) and a smart contract that implements that interface: <a href='Poll.sol.html'>Poll.sol</a> (<a href='Poll.sol'>src</a>). The code will allow voting for <em>something</em> via the blockchain – an election, your favorite color, or anything else. Election dApps are fairly common as first examples of Solidity programs. Note that while you should be able to gain a rough idea of what is going on in the code, the tasks herein are not to necessarily understand the code, but to be able to compile and deploy it. Understanding the code, and writing your own, is in the next assignment and upcoming course lectures.</p>
<p>The IPoll interface, and the implementing Poll contract, allows for only a single election per deployed contract. This is inefficient – a better implementation would be to allow a single contract to host many polls. However, to keep this initial example simple, the contract presented only allows one poll per contract.</p>
<p>While we provide the necessary code, you will need to make two small modifications. You are going to start an election on something <em>other</em> than the default (which is one’s favorite color). Pick something interesting to host a poll for. Edit the Poll source code to add your own choices to your Poll contract. In particular, you should ONLY change two things: the <code>addChoice()</code> calls in the constructor (you can add more or remove some, as needed) and the value of the <code>purpose</code> string. It is important that you do not change any other code in the contract, else it will not work properly when we are testing and grading it! Please choose something that is not controversial – there are many great ways to fight for, and to voice opinions for, things that you believe in and that others may find controversial. Our private Ethereum blockchain for this course is not one of them.</p>
<p>In addition to your Poll.sol source file, you will have to submit the <a href='dappintro.py.html'>dappintro.py</a> (<a href='dappintro.py'>src</a>) file. This file will contain the various transaction hashes and account information that you will be generating as you work through this assignment.</p>
</div><div id='thints' class='tabcontent'><h3 id='hints'>Hints</h3>
<p>There are a few very important hints that will make your life <strong>SO MUCH</strong> easier if you follow them throughout the semester.</p>
<p><strong>Directories:</strong> Keep all your Solidity code, for all your assignments in this course, in the same directory. Much of the code will be re-used between assignments. There will never be two different files that have the same name. Some of the later assignments will have a dozen or so files that are included (imported). And many assignments will use the same set of imported files. And many assignments will import the same (large) set of files. Having everything in the same directory will make it much easier to manage.</p>
<p><strong>Desktop Remix:</strong> Sometimes the desktop version of Remix has issues. Last semester, about a month after we started using it, it just decided to only present a white screen. If issues happen, try to solve it, but be willing to switch to the web browser version if this occurs. (As a side note, the solution to this white screen issue can be found <a href='https://github.com/ethereum/remix-desktop/issues/122'>here</a>). If the desktop version starts running really slowly, try restarting the application.</p>
<p><strong>Web Remix:</strong> The web version of Remix also has issues – in particular, it saves your code on remote servers, and is tied to a cookie in your web browser. If you lose the computer, reset your cookies, or are using a different machine, then you will not be able to access your files. This means you will have to cut-and-paste the code to a locally saved file to ensure you can access it elsewhere.</p>
<p><strong>Geth node:</strong> You will have to start a local geth node to deploy your contracts. You did this in the <a href='../ethprivate/index.html'>private Ethereum Blockchain</a> (<a href='../ethprivate/index.md'>md</a>) assignment. In the Deployment section, below, you will be adding a number of command-line parameters that will allow you to deploy a smart contract through your local geth node to the private course blockchain. Later assignments will be adding yet more command-line parameters to this command to launch a geth node. Save all these flags in a shell script or batch file, as – by the end of the semester – the command will be quite long.</p>
</div><div id='tpart-1-remix' class='tabcontent'><h3 id='part-1-remix'>Part 1: Remix</h3>
<p>Remix is the IDE for developing Ethereum smart contracts in Solidity. Remix provides easy to read compiler error messages and makes it really easy to test your smart contract as you are developing it. You can either use the online editor at <a href='http://remix.ethereum.org'>remix.ethereum.org</a> or you can install it locally via the <a href='https://github.com/ethereum/remix-desktop/releases'>Remix download page</a>. It is already installed on the VirtualBox image. The web interface on <a href='http://remix.ethereum.org'>remix.ethereum.org</a> is designed to look just like the IDE, and you are welcome to use either – the directions herein apply the same to both, as they have the same user interface. However, if you do use the web interface, make sure you save your text file back to your computer.</p>
<ol type='1'>
<li>Load up Remix. The far left column has a number of icons at the top – the Remix logo (<img src='img/remixLogo.webp' class='icon'>), a file explorer icon (<img src='img/fileManager.webp' class='icon'>), a search icon (<img src='img/search_icon.webp' class='icon'>), a compilation icon (<img src='img/solidityLogo.webp' class='icon'>), and a deploy & run icon (<img src='img/deployAndRun.webp' class='icon'>). At various times in this tutorial, you may see a debugging icon (<img src='img/debuggerLogo.webp' class='icon'>) beneath these, but we are not going to focus on the debugger in this assignment. The desktop version may have an additional icon or two, but we can ignore those. On the bottom are two more icons – a plugin manager icon (<img src='img/pluginManager.webp' class='icon'>) and settings icon (<img src='img/settings.webp' class='icon'>).</li>
<li>Click on the file explorer icon (<img src='img/fileManager.webp' class='icon'>), click on the contracts folder (if it exists; if not, pick a directory where you want to store the files), and select ‘New File’ – name it ‘Poll.sol’. Copy and paste the <a href='Poll.sol.html'>Poll.sol</a> (<a href='Poll.sol'>src</a>) program there. Do the same with <a href='IPoll.sol.html'>IPoll.sol</a> (<a href='IPoll.sol'>src</a>). You should now have two Solidity files – Poll.sol and IPoll.sol.
<ul>
<li>If you are using the desktop version, you can browse the local file system (select ‘localhost’ in the Workspaces drop-down box) to find the directory where you are going to keep IPoll.sol and Poll.sol</li>
</ul></li>
<li>To compile it, click on the compilation icon (<img src='img/solidityLogo.webp' class='icon'>) in the far-left pane. You may notice a green check mark on the compilation icon – it might automatically compile it as you type (this does not seem to be consistent across all platforms). Click on the compilation icon, and click “Compile Poll.sol” (NOT IPoll.sol). It should compile without errors.
<ul>
<li>Remix does allow for compiler optimizations, but we are not going to explore them in this assignment. For now, don’t select any optimizations (meaning leave it as the default options).</li>
</ul></li>
<li>Click on the “deploy & run” icon (<img src='img/deployAndRun.webp' class='icon'>) in the far-left pane. For the Environment, we will stay with “Remix VM (London)”, which means that Remix will simulate, in Javascript, a fake Ethereum blockchain and 10 fake accounts for us. You can see the accounts in the ‘Account’ drop-down list.</li>
<li>Click the orange “Deploy” button. It’s now running on the (simulated) Ethereum blockchain, deployed from the selected (and also simulated) account shown in the “Account” drop-down list.</li>
<li>Test out the deployment
<ul>
<li>Look under “Deployed Contracts”, below the “Deploy” button – click on the arrow to the left of “Poll at …”. It will show you various buttons to test out your smart contract.
<ul>
<li>Blue buttons are <code>view</code> or <code>pure</code> functions – they do not require writing a transaction to the blockchain</li>
<li>Orange buttons are functions that require sending a transaction to the blockchain</li>
<li>Red buttons (not present in the current contract) are functions that you send some ether along with the transaction tot he blockchain; we’ll see these later in the semester</li>
</ul></li>
<li>Click on “num_choices”. The console (under the code window; you can make it bigger to see what’s going on) will state, “call to Poll.num_choices”. The line below that will have a “Debug” button and a down arrow – click on that arrow. In the various items that appear, you will see a “decoded output” field that lists the number of choices for this smart contract.
<ul>
<li>This output will also appear below the blue “num_choices” button. However, it only appears below the button for <code>view</code> and <code>pure</code> functions; if it’s a regular transaction, you have to look at the decoded output section described above</li>
</ul></li>
<li>The “choices” button requires a number – put any valid number in there (non-negative and less than the number of choices), and click that button. Again, if you expand the returned result, under “decoded output”, you will see the values in the Choice struct that was returned. Note the number of votes is 0.</li>
<li>Let’s vote! Pick the same option you picked above, enter that value into the box. Then click on the orange “vote” button.
<ul>
<li>Note that this button is orange, meaning this requires sending your vote as a transaction to the (simulated) blockchain</li>
</ul></li>
<li>View the output. You’ll notice that there is nothing in the “decoded output” field (this had no return value – it’s the equivalent of a <code>void</code> return type), but there is now a “transaction hash” field.<br></br>
</li>
<li>Pull up the data on that choice (enter the same choice number next to “choices”, and click that blue “choices” button). You will notice that the number of votes is now 1.</li>
<li>Try to vote again, for any choice. Notice that it doesn’t work – the console states that “The transaction has been reverted to the initial state”. This particular smart contract prevents double-voting. It does this by keeping track of who has voted (in the <code>voted</code> mapping on line 32), and then ensuring that the current voter has not already voted (the first line of the <code>vote()</code> method via a <code>require()</code> call). If a <code>require()</code> call fails, then the state of everything is reverted back to what it was before the transaction occurs (although you still lose your gas fees).</li>
<li>Switch accounts (choose a different one in the drop-down list under “Account”), and try to vote – this time it will work, since that (new) account number has not already voted.</li>
</ul></li>
<li>Explore compilation again
<ul>
<li>Click on the compilation icon (<img src='img/solidityLogo.webp' class='icon'>). At the bottom of the left pane click on “Compilation Details”. This is showing all the results of the compilation.
<ul>
<li>Expand the ‘bytecode’ button. There is a lot here, and we can ignore most of it. Scroll down to the very bottom of what just appeared – the two fields we care about are the “object” field and the “opcodes” field.
<ul>
<li>The bytecode -&gt; opcodes field are the Ethereum bytecode that the smart contract was compiled down to. This is similar in concept to the Bitcoin Script, although it has the ability to perform looks (via <code>JUMP</code> commands and similar), and is a lot more complex.</li>
<li>The bytecode -&gt; object field is the raw hex of the compiled program itself – the bytecodes were compiled to their hexadecimal equivalents. This very long string (over 5,000 bytes) is what is actually loaded onto the blockchain. When we deploy our code to the blockchain, below, you will be able to see that bytecode in the transaction via the blockchain explorer.</li>
</ul></li>
</ul></li>
<li>Back in the left-hand pane, under the “Compilation Details” button is a link to copy the ABI – click on the copy icon. In any editor, paste that into a blank file. This is the Application Binary Interface – it specifies how to interact with the smart contract. Think of it like a C++ header file – it gives the interface, but not the implementation. One cannot interact with a smart contract without having the ABI. As you scroll through the ABI, you will notice that all the fields and method are listed there, along with all the various types.
<ul>
<li><strong>THIS IS IMPORTANT!</strong> In future assignments, when you are going to write your own smart contracts, you may have to submit the ABI for each of them along with the source code. Without the ABI, we will not be able to interact with your smart contract!</li>
</ul></li>
</ul></li>
<li>Explore Remix on your own. You are going to be spending a lot of time developing smart contracts in Remix. Spending a bit of time learning how it works, and becoming comfortable with the interface, will save you a lot of time in the future.</li>
</ol>
</div><div id='tpart-2-testing' class='tabcontent'><h3 id='part-2-testing'>Part 2: Testing</h3>
<p>Testing a blockchain application is very counter-intuitive. There are no print statements and no viable debuggers. We can deploy it and then try it out, but that’s not a great way to test.</p>
<p>You should ensure you are familiar with the <a href='../../slides/solidity.html#/debugging'>Testing and Debugging section of the Solidity slide set</a>.</p>
<p>This task will show you how to develop unit tests for your Solidity application. To set this up:</p>
<ol type='1'>
<li><p>Click on the plugin manager icon (<img src='img/pluginManager.webp' class='icon'>) in the bottom of the far-left column of icons in the Remix window. In the search box enter ‘test’. The Solidity Unit Testing plugin will appear; click the green activate button.</p></li>
<li><p>Remix will now display a unit testing icon (<img src='img/unitTesting.webp' class='icon'>) in the left-most pane; click on that.</p></li>
<li><p>The plugin will automatically create a sample unit test class for you – to do this, click on “Generate”. You will see a Poll_test.sol file created.</p>
<ul>
<li>Remix has a bizarre directory choice for where to put this file – on Linux systems, it goes in <code>~/tests/</code>. You will need to find where it is on your OS via a file search.</li>
</ul></li>
<li><p>Click on the blue “Run” button – this will run the unit tests. Some will pass and some will fail, which is expected at this point. Note that, for unit tests, you do not have to re-compile it each time – the Run button will do that, if necessary, for you.</p></li>
<li><p>Let’s make the existing tests pass. In the <code>checkFailure()</code> function, change <code>Assert.notEquals()</code> to <code>Assert.equals()</code>, and re-run the tests. They should all pass now.</p></li>
<li><p>Add the following method to the Poll_test class</p>
<pre><code>function checkChioceCreation() public {
   Poll p = new Poll();
   p.addChoice("test1");
   Assert.equal(uint(p.num_choices()),uint(7),"Choice not added");
}</code></pre>
<ul>
<li>That method checks that there are 7 choices, as 6 were created by the constructor, and one more was added in this method; you will have to adjust this value if you changed the number of choices in your constructor</li>
<li>If you re-run the unit tests, this test should also pass</li>
</ul></li>
<li><p>Look at the comments just above the <code>checkSenderAndValue()</code> function. These comments specify the particular account that is passed in, and how much ether (actually wei) that is passed in as well. You can see a full definition of these types of comments <a href='https://remix-ide.readthedocs.io/en/latest/unittesting.html#customization'>here</a>.</p></li>
</ol>
<p>You do not need to submit the Poll_test.sol file. The purpose of this section was to show you how to start writing unit tests. You will need this when you start developing Solidity applications in the next assignment.</p>
<p>The Poll_test.sol file that was auto-generated from the default Poll.sol file is as follows. You do not need to read through this code; it’s only here as a reference.</p>
<pre><code>// SPDX-License-Identifier: GPL-3.0
        
pragma solidity &gt;=0.4.22 &lt;0.9.0;

// This import is automatically injected by Remix
import "remix_tests.sol"; 

// This import is required to use custom transaction context
// Although it may fail compilation in 'Solidity Compiler' plugin
// But it will work fine in 'Solidity Unit Testing' plugin
import "remix_accounts.sol";
import "../Dropbox/git/ccc/hws/dappintro/Poll.sol";

// File name has to end with '_test.sol', this file can contain more than one testSuite contracts
contract testSuite {

    /// 'beforeAll' runs before all other tests
    /// More special functions are: 'beforeEach', 'beforeAll', 'afterEach' & 'afterAll'
    function beforeAll() public {
        // &lt;instantiate contract&gt;
        Assert.equal(uint(1), uint(1), "1 should be equal to 1");
    }

    function checkSuccess() public {
        // Use 'Assert' methods: https://remix-ide.readthedocs.io/en/latest/assert_library.html
        Assert.ok(2 == 2, 'should be true');
        Assert.greaterThan(uint(2), uint(1), "2 should be greater than to 1");
        Assert.lesserThan(uint(2), uint(3), "2 should be lesser than to 3");
    }

    function checkSuccess2() public pure returns (bool) {
        // Use the return value (true or false) to test the contract
        return true;
    }
    
    function checkFailure() public {
        Assert.notEqual(uint(1), uint(1), "1 should not be equal to 1");
    }

    /// Custom Transaction Context: https://remix-ide.readthedocs.io/en/latest/unittesting.html#customization
    /// #sender: account-1
    /// #value: 100
    function checkSenderAndValue() public payable {
        // account index varies 0-9, value is in wei
        Assert.equal(msg.sender, TestsAccounts.getAccount(1), "Invalid sender");
        Assert.equal(msg.value, 100, "Invalid value");
    }
}</code></pre>
</div><div id='tpart-3-deployment' class='tabcontent'><h3 id='part-3-deployment'>Part 3: Deployment</h3>
<p>At this point we can edit, compile, and test our program on Remix. We have also made changes to the <code>addChoice()</code> calls in the Poll.sol constructor, as well as to the <code>purpose</code> string. Now we are going to use Remix to deploy to our private Ethereum blockchain.</p>
<h4 id='start-geth'>Start geth</h4>
<p>We need to start geth, as we did in the <a href='../ethprivate/index.html'>connecting to the private Ethereum blockchain</a> assignment. However, we need to add a few more command-line parameters:</p>
<ul>
<li><code>--http</code>: This enables the HTTP-RPC server. What this means is that it will open a port (8545) that programs – in our case, Remix – can connect to to interact with geth (and, eventually, deploy to the blockchain)
<ul>
<li>RPC stands for Remote Procedure Call. It’s a way for one program to call a procedure running in some other program. In this case, the client is trying to call the procedure, and the geth node is receiving, and then executing, the procedure call.</li>
</ul></li>
<li><code>--http.corsdomain="https://remix.ethereum.org"</code>: This allows that particular site to connect to the HTTP-RPC server. Normally all sites are blocked for security reasons, so we have to specifically grant permission for individual sites to connect.
<ul>
<li><strong>NOTE:</strong> if you are using the Remix IDE, you will have to enter some other value instead of <code>https://remix.ethereum.org</code>; the pop-up window in Remix (that pop-up window is described below) will tell you what the value is. For now, use the the flag as specified here, and know that you will have to make a change to it below; the assignment steps below will tell you when and how.</li>
<li>We do NOT recommend using the <code>--dev console</code> flags</li>
</ul></li>
<li><code>--http.api web3,eth,debug,personal,net</code>: These are the APIs that are made available on the HTTP-RPC server. For example, by enabling <code>eth</code> (one of the ones listed), then <code>eth.blockNumber</code> can be called. This is only for the HTTP-RPC server; an attached geth node has access to all the APIs.</li>
<li><code>--vmdebug</code>: This records information useful for debugging, which is an option that Remix will allow us to do.</li>
<li><code>--allow-insecure-unlock</code>: This will allow us to unlock our <code>eth.coinbase</code> account via <code>personal.unlockAccount()</code>. Normally this is disabled if the HTTP-RPC server is enabled. Our particular configuration does not allow any <em>other</em> machines to connect to the HTTP-RPC server, and our (fake) ETH is not worth any money, so it is safe enough for us to use for this course.</li>
<li>If you are using the desktop version, you will have an additional flag, such as <code>--http.corsdomain="package://0123456789abcdef0123456789abcdef.mod"</code>. HOWEVER, the particular package hex string will vary by OS and version. This flag will be presented to you when you switch over to deploy through the local geth node, described below. If you are using the Desktop version, you will have to restart your geth node with that flag.</li>
</ul>
<p>Our full geth call will look like the following. The first line contains exactly the flags from the geth command in the <a href='../ethprivate/index.html'>connecting to the private Ethereum blockchain</a> (<a href='../ethprivate/index.md'>md</a>) assignment; recall that you have to change the <code>/path/to/ethprivate</code> path to match your directory, the userid <code>mst3k</code> to your userid, and the chainID (aka the networkid) to match the one for our private Ethereum blockchain. The second line contains the five additional flags added in this assignment and described above.</p>
<pre><code>geth --identity "mst3k" --datadir /path/to/ethprivate --networkid 12345678 --maxpeers 1 --nodiscover --syncmode full --gcmode "archive" \
     --vmdebug --http --http.corsdomain="https://remix.ethereum.org" --http.api web3,eth,debug,personal,net --allow-insecure-unlock</code></pre>
<p>As mentioned above, you may have to add another parameter or two if you are using the desktop version. And you should save this in a shell script or batch file.</p>
<p>Moving forward, this will be the standard command to start a geth node; later assignments will add yet more flags. As before, we recommend that you put that command in a shell script or batch file. The backslash (<code>\</code>) is to handle word wrap on the page – those two lines work on Linux and Mac OS X, but you may have to put it all on one line and remove the backslash (<code>\</code>) in Windows. Once that command is run to start the local node, you will see a line that says, “HTTP server started”, which is what our additional options did. Note that these particular options will only allow the Remix that we are using – either as a stand-alone IDE or through the browser – <em>on the same machine</em> to connect. So you can’t run geth in VirtualBox (or on Amazon AWS) and Remix on your host machine, for example.</p>
<p>Now that geth is started, we have to attach to it IN A SEPARATE WINDOW via <code>geth attach /path/to/ethprivate/geth.ipc</code> (or, in Windows, either <code>geth attach ipc:\\\\.\\pipe\\geth.ipc</code> or <code>geth attach \\.\pipe\geth.ipc</code>). Wait for it to finish sync’ing (check <code>eth.syncing</code>). Then <code>eth.blockNumber</code> should match the highest block number on our Ethereum blockchain explorer.</p>
<p>Just to check: at this point, you should have TWO geth processes running in separate windows. The first is the full node with the five or six additional flags as above. The second is a geth terminal via <code>geth attach</code>.</p>
<h4 id='configure-remix'>Configure Remix</h4>
<p>You should have Poll.sol loaded into Remix, and you should have made the modifications to the <code>addChoice()</code> calls in the constructor and the value of the <code>purpose</code> string. You should have compiled it WITHOUT optimizations.</p>
<p>Read these instructions through before starting them!</p>
<ol type='1'>
<li>Change to the Remix deployment tab (<img src='img/deployAndRun.webp' class='icon'>).
<ul>
<li>Under ‘Environment’ select “External Http Provider”. The pop-up window will tell you the options to run geth with, and you have already done that, above. Ensure that the “Web3 Provider Endpoint”, in the pop-up box, says <code>http://127.0.0.1:8545</code>.
<ul>
<li>If you are using the Remix IDE, the pop-up window in Remix will tell you what you will ned to use as your endpoint value (meaning what value to put after the <code>--http.corsdomain</code> flag). See a screen shot of that value <a href='remix-cors.webp'>here</a>. You will need to restart the geth node with that flag (and possibly re-attach the geth Javascript terminal). Save that additional flag in your shell script or batch file that you use to start a geth node.</li>
<li>Click OK to close that pop-up window</li>
<li>Note to Mac OS X users: if you are doing this assignment on remix.etherem.org in Safari, then this is the part that Safari seems to have issues with. If it is not working for you, then please switch to a different browser (Firefox or Chrome both seem to work fine). You can then cut-and-paste your code from Remix in Safari to remix in Firefox / Chrome.</li>
</ul></li>
<li>Underneath the “Environment” drop-down box, it should now say, “Custom (12345678) network”, with the chain number of our private blockchain instead of 12345678.</li>
<li>You should see your geth account address(es) populated in the “Account” drop-down box, with your <code>eth.coinbase</code> one selected</li>
<li>If there are any entries listed under “Deployed contracts” (in the left-hand pane), you can delete them – this way we won’t mix up any previous deployments (to the simulated blockchain) with the one we are about to do (to the private course blockchain)</li>
</ul></li>
<li>Unlock your account in geth
<ul>
<li>In the geth terminal, run the <code>personal.unlockAccount()</code> command. You can run it as <code>personal.unlockAccount(eth.coinbase,"password",0)</code> – filling in your own password – to unlock it until the end of the session. It should report back <code>true</code>.</li>
<li>Note your balance – enter <code>web3.fromWei(eth.getBalance(eth.coinbase), "ether")</code></li>
</ul></li>
<li>Hit Deploy!
<ul>
<li>This what this party is all about! Click the orange Deploy button.</li>
<li>The Remix console (under the editing box) should say, “creation of Poll pending… view on etherscan”</li>
<li>Note that this submitted it as a transaction, but it is not (at that moment) on the blockchain</li>
<li>As our blockchain auto-mines all transactions, it should take effect very quickly</li>
</ul></li>
<li>See what happened
<ul>
<li>Look at your new balance in the geth terminal via <code>web3.fromWei(eth.getBalance(eth.coinbase), "ether")</code>. You will see that your gas fees were deducted.
<ul>
<li>Look back at the Remix console – it will say something like, <code>[block:12345 txIndex:0] from: 0x123...bcdef to: Poll.(constructor) value: 0 wei data: 0x608...57221 logs: 0 hash: 0x123...bcdef</code>
<ul>
<li>Note the block number (shown in the previous line as 12345) where the transaction occurred</li>
</ul></li>
<li>Click on the arrow to the right of the “Debug” button in the console – this will list the details of the transaction that was mined into the blockchain</li>
<li>The <em>contract address</em> is listed in the left-hand pane, under the deploy button (in the “Deployed Contracts”) section)
<ul>
<li>Save the contract address – there is a copy icon to easily copy it – as you will need to submit that</li>
</ul></li>
<li>You can view the information for that transaction on our blockchain explorer – the block that contained the transaction that deployed your smart contract, the transaction itself, and the account that is the contract address
<ul>
<li>You may have to wait up to a minute for the explorer to refresh the information from the blockchain</li>
</ul></li>
</ul></li>
</ul></li>
<li>Call some methods on your contract
<ul>
<li>If you expand the specific deployed contract, you can see the various methods that it provides. Call the blue buttoned methods, which are the ones that are read-only methods (and thus do not require writing a transaction to the blockchain) – <code>num_choices()</code>, <code>choices()</code>, <code>voters()</code>, and <code>unnecessaryFunction()</code>.
<ul>
<li>To see if you have voted, click the copy icon to the right of your account drop-down box to copy your account address, then paste that into the ‘voters’ box and click ‘voters’ – it should show false, but you will have to click on the down arrow to the right of the ‘debug’ button that appeared to see that return value</li>
</ul></li>
<li>Vote for your choice! Enter a number in the ‘vote’ box for your choice, and click ‘vote’ - You will see “transact to Poll.vote pending …” in the console – it’s waiting for the transaction to make it onto the blockchain - It should be auto-mined very quickly - In the console, click the down-arrow to the right of the ‘debug’ button that appeared – it lists the transaction hash. You can view that on the explorer as well - You will need to submit the transaction hash where you voted</li>
<li>You can call ‘voters’ again with your coinbase account; it should return true this time</li>
</ul></li>
<li>View in the explorer
<ul>
<li>We are going to see some additional functionality in the blockchain explorer</li>
<li>Search for the particular contract – enter the contract address for your deployed Poll contract in the search box in the upper-right of any page</li>
<li>In the page for the contract, notice that the explorer is able to identify that this contract implements the IPoll interface (the <code>interfacesImplemented</code> entry). We’ll discuss the IERC165 interface later in the course. It does this by checking the result of calling <code>supportsInterface()</code>, which we provided the code for in Poll.sol</li>
<li>Look at the transaction list at the bottom of the contract page. The lowest one is the deployment of the contract itself (it will have a value in the contract address field). The other entry is when you voted on it.</li>
<li>Click on the transaction hash value for the deployment transaction (the bottom entry in the transaction table). This brings up the transaction page; of the fields there, notice that the <code>input</code> field lists the size of the contract – about 5.5 Kb. If we had optimized it during compilation, it would be about 3 Kb.</li>
<li>Go back to the page for the contract. Click on the transaction hash for the other transaction (the one where you voted).</li>
<li>Notice that there are two new fields being shown – <code>functionCall</code> and <code>inputDecode</code>.
<ul>
<li>Because the IPoll interface is known to the explorer, it can determine which function was called, which is displayed in the <code>functionCall</code> field</li>
<li>The actual parameters passed in during the call is shown in the <code>inputDecode</code> field</li>
<li>If there was a return value, that would be shown in a <code>returnValue</code> field, which is not present in this example</li>
<li>These two (or three) fields are only displayed when the transaction is a function call</li>
</ul></li>
</ul></li>
<li>Don’t close down Remix!
<ul>
<li>You are going to need it open and with the Poll.sol compiled, for task 5, below</li>
</ul></li>
</ol>
</div><div id='tpart-4-web-interface' class='tabcontent'><h3 id='part-4-web-interface'>Part 4: Web Interface</h3>
<p>We wanted to show you that you can create a web page to interact with a smart contract on the blockchain. The code of the poll viewing web page uses the web3 Javascript library, which is what allows you to connect to the blockchain from Javascript. In our case, we use it to connect to a node running geth that is connected to our private course blockchain. The URL for this web page is on the Collab landing page – once there, enter your smart contract’s contract address (with the leading <code>0x</code>) for your deployed smart contract, and it will display the choices.</p>
<p>You are not expected to understand any of the code on that web page. This will be gone over in future assignments, and you will be writing multiple web pages toward the end of the semester to interact with the blockchain. But not now.</p>
<p>On the course blockchain explorer, you can find other contract addresses – look at the transactions page, and see which ones have a value listed in the ‘contract address’ column. You can also view just the contract accounts as well. You can click on a contract address to see which interfaces it implements – if it implements the IPoll interface, then you can copy that address and use it in the poll viewer web page. This allows you to see what choices your classmates selected. You are welcome to vote on their polls, but that is not necessary (see the next section for how to do this). Note that you won’t know who deployed that particular smart contract. Also note that this web page will only work with the version of the Poll code used in this assignment. Specifically, it will only work with a smart contract that has the same ABI that IPoll.sol generates; you can see that ABI in the Javascript source code of the poll viewer web page.</p>
<p>How this all works is beyond the scope of this assignment, but will be something we will be going over later in the semester. Feel free to look over the Javascript code in that web page – the only other requirement is that a local geth node has to be running with a few specific additional flags to enable this web page to connect to it (we have not seen those flags yet). One can also have a web page initiate a transaction onto the blockchain, such as casting a vote – we will see that in a future assignment as well; that requires a browser plugin, such as <a href='https://metamask.io/'>MetaMask</a>, that allows for posting of transactions to a web page using a specific Ethereum account.</p>
</div><div id='tpart-5-vote' class='tabcontent'><h3 id='part-5-vote'>Part 5: Vote!</h3>
<p>I have loaded the Poll smart contract onto our private Ethereum blockchain, and you all must vote! The only information we will tell you is that the contract address for this is on the Collab landing page, and that it fulfills the <a href='IPoll.sol.html'>IPoll.sol</a> (<a href='IPoll.sol'>src</a>) interface. You have to figure out what the options are, and then vote for one. You will need to submit the transaction hash where you voted.</p>
<p>In Remix, you can call a different contract <em>with the same codebase</em>. In particular, it has to have the same ABI. For this, you can (and should) use the IPoll.sol file. Specifically, you should NOT use Poll.sol, as you do not know if additional functions (such as <code>unnecessaryFunction()</code>) are in the deployed contract; only that it implements the functions in IPoll.sol. On the Collab landing page is the address of a deployed Poll contract – copy that address.</p>
<p>In Remix, in the Deployment pane, switch to IPoll. Switch to the compilation pane, and click “Compile IPoll.sol”. Then switch to the deployment pane. At the bottom, and above the “Deployed contracts” list is a blue “At Address” button – copy the contract address there, and click that button. This now gives us a connection to a different IPoll implementing contract. Use this to vote. You have to vote on the course poll. You are welcome to vote (or not) on your fellow classmates polls; how to find their contract addresses is described above.</p>
<p>Note that Remix may complain if an Ethernet address is not <a href='../../slides/ethereum.html#/checksum'>checksummed</a>. This is a warning, not an error, and it should still work fine. But you still have to remove the warning, otherwise the compilation when you submit it will appear to fail. Remix will provide, in the warning, the checksummed address – you are welcome to use that value (cut-and-paste it into your code) instead to silence this warning. You can also use <a href='https://ethsum.netlify.app/'>ethsum.netlify.app</a> to checksum an Ethernet address.</p>
<p>The assumption is that the account you will vote with is your <code>eth.coinbase</code> account. It’s fine if you want to use a different account address than you used in the last assignment, but when you submit your information at the end of this assignment, be sure to submit the account that you used for the deployment and voting herein. As your account information will be in the <code>voted</code> mapping, we will be able to determine who has voted and who has not. You get credit for this part as along as you vote on the course smart contract; it does not matter what choice you vote for.</p>
</div><div id='tpart-6-closing-down' class='tabcontent'><h3 id='part-6-closing-down'>Part 6: Closing down</h3>
<p>Please turn off your geth node when you are done with this assignment. You can always turn it back on again when needed.</p>
</div><div id='tsubmission' class='tabcontent'><h3 id='submission'>Submission</h3>
<p>You will need to fill in the various values from this assignment into the <a href='dappintro.py.html'>dappintro.py</a> (<a href='dappintro.py'>src</a>) file. That file clearly indicates all the values that need to be filled in. That file, along with your Solidity source code (only Poll.sol), are the only files that must be submitted. The <code>sanity_checks</code> dictionary is intended to be a checklist to ensure that you perform the various other aspects to ensure this assignment is fully submitted.</p>
<p>There are <em>three</em> forms of submission for this assignment; you must do all three. Other than the Gradescope submission, they are all listed in the <code>sanity_checks</code> dictionary.</p>
<p>Submission 1: You must deploy your Poll smart contract to our private Ethereum blockchain. It’s fine if you deploy it a few times to test it. The contract address of this deployment are entered into the <code>dappintro.py</code> file that you submit.</p>
<p>Submission 2: You must vote on both your Poll contract <em>and also</em> on the course-wide Poll contract. The transaction hashes for these two transactions are entered into the <code>dappintro.py</code> file.</p>
<p>Submission 3: You should submit your <code>Poll.sol</code> file and your completed <code>dappintro.py</code> file, and ONLY those two files, to Gradescope (don’t submit <code>IPoll.sol</code>). All your Solidity code should be in the first file, and you should specifically import the <code>IPoll.sol</code> interface. Those interface file will be placed in the same directory on Gradescope when you submit. <strong>NOTE:</strong> Gradescope cannot fully test this assignment, as it does not have access to the private blockchain. So it can only do a few sanity tests (correct files submitted, successful compilation, valid values in dappintro.py, etc.).</p>
</div><script>document.getElementById('defaultOpen').click();</script></body>
</html>

