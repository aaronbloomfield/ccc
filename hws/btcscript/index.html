<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' lang='' xml:lang=''>
<head>
  <meta charset='utf-8'></meta>
  <meta name='generator' content='pandoc'></meta>
  <meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=yes'></meta>
  <title>Bitcoin Scripting Homework</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel='stylesheet' href='../../markdown.css'></link>
  <script>
  function openTab(evt, tabName) {
    // Declare all variables
    var i, tabcontent, tablinks;

    // Get all elements with class="tabcontent" and hide them
    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i < tabcontent.length; i++) {
      tabcontent[i].style.display = "none";
    }

    // Get all elements with class="tablinks" and remove the class "active"
    tablinks = document.getElementsByClassName("tablinks");
    for (i = 0; i < tablinks.length; i++) {
      tablinks[i].className = tablinks[i].className.replace(" active", "");
    }

    // Show the current tab, and add an "active" class to the button that opened the tab
    document.getElementById(tabName).style.display = "block";
    evt.currentTarget.className += " active";
  }
  </script>
  
</head>
<body>
<h1 id='bitcoin-scripting-homework'>Bitcoin Scripting Homework</h1>
<p><a href='../index.html'>Go up to the CCC HW page</a> (<a href='../index.md'>md</a>) | <a href='index-full.html'>view one-page version</a></p><div class='tab'>
<button class='tablinks' onclick="openTab(event,'toverview')" id='defaultOpen'>Overview</button>
<button class='tablinks' onclick="openTab(event,'tchangelog')">Changelog</button>
<button class='tablinks' onclick="openTab(event,'tlanguages')">Languages</button>
<button class='tablinks' onclick="openTab(event,'thints')">Hints</button>
<button class='tablinks' onclick="openTab(event,'ttestnet')">Testnet</button>
<button class='tablinks' onclick="openTab(event,'tpython-library')">Python Library</button>
<button class='tablinks' onclick="openTab(event,'tpart-1-p2pkh')">P2PKH</button>
<button class='tablinks' onclick="openTab(event,'tpart-2-puzzle-script')">Puzzle Script</button>
<button class='tablinks' onclick="openTab(event,'tpart-3-multisig')">Multisig</button>
<button class='tablinks' onclick="openTab(event,'tpart-4-cross-chain')">Cross Chain</button>
<button class='tablinks' onclick="openTab(event,'tpart-5-return-tbtc')">Return tBTC</button>
<button class='tablinks' onclick="openTab(event,'tsubmission')">Submission</button>
</div>
<div id='toverview' class='tabcontent'><h3 id='overview'>Overview</h3>
<p>In this assignment you will be writing a series of Bitcoin scripts to enact transfers. You will be using a Bitcoin test network to do so. While regular Bitcoin uses the abbreviation BTC, we will use the abbreviation ‘tBTC’ for the Bitcoin on our test network.</p>
<p>There are four separate Bitcoin scripts that you will need to write. You will need to be familiar with the <a href='../../slides/bitcoin.html#/'>Bitcoin slide set</a>, specifically the <a href='../../slides/bitcoin.html#/script'>Bitcoin Script</a> and <a href='../../slides/bitcoin.html#/xchain'>Cross-Chain Transactions</a> sections. You will also need to refer to the <a href='https://en.bitcoin.it/wiki/Script'>Bitcoin Script page</a>.</p>
<p>You will need to be familiar with the <a href='../../slides/bitcoin.html#/'>Bitcoin slide set</a>, specifically the discussion about the format for the blockchain.</p>
</div><div id='tchangelog' class='tabcontent'><h3 id='changelog'>Changelog</h3>
<p>Any changes to this page will be put here for easy reference. Typo fixes and minor clarifications are not listed here. So far there aren’t any significant changes to report.</p>
</div><div id='tlanguages' class='tabcontent'><h3 id='languages'>Languages</h3>
<p>This assignment uses the <a href='https://pypi.org/project/python-bitcoinlib/'>Python bitcoinlib package</a>; (documentation is <a href='https://python-bitcoinlib.readthedocs.io/en/latest/'>here</a>, if you are interested, but you probably won’t need it). Thus, this assignment must be completed in Python. You can install the package via <code>pip install python-bitcoinlib</code> (you may need to use <code>pip3</code> on your system). This is installed on the VirtualBox image.</p>
<p>We provide you with a few files to use:</p>
<ul>
<li><a href='scripts.py.html'>scripts.py</a> (<a href='scripts.py'>src</a>): you will modify this file throughout this assignment. The progression of items in that file mirrors the progression of the assignment steps herein. This is the only file that you will submit. We would expect that you would be able to understand everything in this file by the end of the assignment</li>
<li><a href='bitcoinctl.py.html'>bitcoinctl.py</a> (<a href='bitcoinctl.py'>src</a>): this is the driver file that will run the various parts of the assignment using the values in the above scripts.py. You are of course welcome to look at the details, but you are not expected to understand what is in that file.</li>
</ul>
</div><div id='thints' class='tabcontent'><h3 id='hints'>Hints</h3>
<h4 id='development-tips'>Development Tips</h4>
<ul>
<li>You can, and should, use a site such as <a href='https://siminchen.github.io/bitcoinIDE/build/editor.html'>https://siminchen.github.io/bitcoinIDE/build/editor.html</a> to test your code. Note that this site is, by necessity, limited in what it can do. It will try to execute the scripts, but it doesn’t always know if there is enough balance, if the corresponding UTXO script matches, etc. So use that site to get started, but be sure to test your scripts via the means specified in this assignment.</li>
</ul>
<h4 id='general-hints'>General Hints</h4>
<ol type='1'>
<li><strong>UTXO indices:</strong> each transaction has one more more UTXO indices – each transaction output creates a separate UTXO index. To find out what UTXO index you need to use, <em>view the transaction on the blockcypher.com website</em>. All UTXO indices start from 0, like arrays. In particular, for your funding transaction, your UTXO index will probably not be 0. You need to set the <code>utxo_index</code> variable for <strong>EACH</strong> transaction to the right UTXO index.</li>
<li>After each transaction, there is a place to store the transaction hash. Be diligent about doing this – it’s really easy to lose track of which of a dozen transaction hashes is which. Keeping them in the stated variables will help with this.</li>
<li>Don’t modify the variable or function names in the scripts.py file. Otherwise the provided functions, and our grading routines, will not work. You can <em>add</em> functions and variables, but don’t change the ones currently there.</li>
<li>For <em>EACH</em> transaction, you will need to set the <code>utxo_index</code> variable – there is just one such variable in the scripts.py file. If you get an error stating that the UTXO index is already spent, it’s likely that you forgot to set this variable.</li>
<li>Some errors with Bitcoin scripts can be determined prior to broadcasting it on the Bitcoin test network. This is done by the <code>VerifyScript()</code> method, which the provided code base calls for you before any attempted broadcast transaction. So if you see an error such as, <code>verifyerror: "bitcoin.core.scripteval.VerifyOpFailedError: EvalScript: OP_EQUALVERIFY failed</code>, or similar, it means that the Bitcoin library was able to detect that your script would not work, and did not broadcast the transaction.</li>
<li>We provide you with a <code>create_CHECKSIG_signature()</code> function in the scripts.py file – use it! See the comments there for details as to how.</li>
<li>To save you the tedious task of having to learn the <a href='https://pypi.org/project/python-bitcoinlib/'>Python Bitcoin library</a> (documentation is <a href='https://python-bitcoinlib.readthedocs.io/en/latest/'>here</a>) – which you probably would never use again – much of the library interaction has been handled for you by the provided code. But in order for that to work, you have to proceed through this homework in the order written.</li>
<li>If you want to put the number 2 onto the stack, you can’t just use the integer value 2. Instead, you have to use the <code>OP_2</code> opcode. In fact, <code>OP_2</code> happens to have integer value 82, and the integer value 2 has a different meaning.</li>
</ol>
<h4 id='common-errors'>Common Errors</h4>
<ul>
<li>“Error validating transaction: Transaction … referenced by input 0 has lesser than 3 outputs” means the UTXO index you provided is too high</li>
<li>“Error validating transaction: Error running script for input 0 referencing … at 0: Script was NOT verified successfully” is when the scripts don’t work together</li>
</ul>
<h4 id='mac-os-x-issues'>Mac OS X issues</h4>
<p>If you have a M1 Mac, there are a few issues you should be aware of.</p>
<p>Installing OpenSSL via homebrew would still lead to errors in past semesters. These errors report a problem with the “libeay32” library. Here are some solutions that helped in the past:</p>
<ul>
<li>Installing OpenSSL as per <a href='https://www.davidseek.com/ruby-on-m1/'>https://www.davidseek.com/ruby-on-m1/</a></li>
<li>You can replace the OpenSSL library that bitcoinlib calls. In the bitcoin package, in <code>/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages/bitcoin</code> (that may differ on your machine), in <code>core/key.py</code>, replace <code>_ssl = ctypes.cdll.LoadLibrary(ctypes.util.find_library('ssl.35')</code> or <code>ctypes.util.find_library('ssl')</code> or <code>ctypes.util.find_library('libeay32')</code> with <code>_ssl = ctypes.cdll.LoadLibrary(ctypes.util.find_library('ssl.35')</code> or <code>ctypes.util.find_library('ssl'))</code>.</li>
</ul>
<p>We cannot vouch for any of these solutions; we just collected a bunch of Piazza responses from the previous semester.</p>
</div><div id='ttestnet' class='tabcontent'><h3 id='testnet'>Testnet</h3>
<p>As we do not want to have to buy, and possibly lose, real BTC, we are going to use a test network. Because the coins we are going to be using are not “real” Bitcoins, we will use the abbreviation ‘tBTC’ instead of ‘BTC’. When using a test network, you get coins for free via a “faucet” – in the same way that a water faucet provides water once turned on, so does a testnet faucet provide tBTC when requested. The particular one we are using is <a href='https://testnet-faucet.mempool.co/'>Yet Another Bitcoin Testnet Faucet</a>.</p>
<ol type='1'>
<li>You will need to generate a tBTC key pair. Run <code>./bitcoinctl.py genkey</code>, and record both the public and private keys. While these keys are not valid on the main Bitcoin test network – the have a different value for the <a href='../../slides/bitcoin.html#/btcaddress'>version byte</a> in the invoice address – you will need them throughout this assignment.
<ul>
<li>Save both the tBTC private key and the tBTC address into the scripts.py file into <code>private_key_str</code> and <code>invoice_address</code>, respectively</li>
</ul></li>
<li>Go to the <a href='https://testnet-faucet.mempool.co/'>Testnet Faucet</a> page and enter the tBTC address key provided in the previous step. You will be provided a transaction ID. You can then view your transaction at <a href='https://live.blockcypher.com/'>https://live.blockcypher.com/</a> – put the transaction ID in the search box and be sure to select ‘Bitcoin Testnet’ for the search.
<ul>
<li>Enter the transaction ID in scripts.py in <code>txid_initial</code></li>
<li>Verify that you can view your account information at https://live.blockcypher.com/btc-testnet/address/&lt;address&gt; where &lt;address&gt; is your tBTC address – the amount that address holds should be the amount that the faucet provided to you (likely 0.001 tBTC)
<ul>
<li>It may take up to 10 minutes or so for the transaction that funded your wallet to be mined into the blockchain</li>
</ul></li>
<li>Verify that you can view the transaction at https://live.blockcypher.com/btc-testnet/tx/&lt;txid&gt; where &lt;txid&gt; is your transaction id
<ul>
<li>Note that the testnets often perform many transfers in one transaction – so the total amount transacted may be more than 0.001 tBTC, but the amount paid to your wallet should be 0.001 tBTC</li>
</ul></li>
<li>You can also get these URLs by running <code>./bitcoinctl.py geturls</code>. As you fill in more transaction hashes throughout this assignment, re-running this will show an increasing list of URLs.</li>
</ul></li>
<li>That transaction gave only one UTXO, and we would like multiple UTXOs to use – this way we can use one per question part, and we have a few extra if something ends up not working correctly.
<ul>
<li>Look at the section of scripts.py that deals with splitting coins. The default values there are probably correct, but check anyway – see the comments therein for details
<ul>
<li>Check the transaction – via the URL from above – that gave you the coins, and make sure you have the right UTXO index (which is stored in the <code>utxo_index</code> variable in scripts.py). If you get an error such as “witness script detected in tx without witness data”, then it probably means your UTXO index is wrong.</li>
</ul></li>
<li>Run <code>./bitcoinctl.py split</code> to split your coins. This uses the values in the splitting coins section of scripts.py.
<ul>
<li>If this works properly, it will present back a Python dictionary that will take up many lines. If it doesn’t work, it will give you an error in just a few lines.</li>
</ul></li>
<li>Look at the wallet info URL (run <code>./bitcoinctl.py geturls</code> to get the URL), and note the transaction hash of the split transaction – it should be the top transaction listed, and will have 10 different outputs. The transaction hash itself is also listed in the output from the split transaction – it’s the <code>hash</code> field of the dictionary, and is about a half a dozen lines down. Record that transaction id in scripts.py as <code>txid_split</code></li>
</ul></li>
</ol>
<p>Be careful not to lose the information (keys and TXIDs) that you recorded above. To prevent abuse, the faucet only allows one transaction per 12 hours for a given IP address or tBTC address. If you need more during that 12 hour window, or you are running into ‘exceeded limit’ issues, you can try requesting it through your cell phone. If you put it on cellular (meaning disconnect from UVA’s network), it will report a very different IP address to the faucet.</p>
</div><div id='tpython-library' class='tabcontent'><h3 id='python-library'>Python library</h3>
<p>The <code>python-bitcoinlib</code> library for Python handles much of the heavy lifting – conversion from one type to another, encryption, signing, verification, etc. If you were to enter actual keys that have real BTC then you could use this library to make real BTC transactions.</p>
<p>While the library can do many things, below is a quick summary of the relevant aspects that you will need to know for this assignment.</p>
<ul>
<li><p>Creating Bitcoin scripts is really just putting everything into a list. All the opcodes are named the same as on the <a href='https://en.bitcoin.it/wiki/Script'>Bitcoin Script page</a>. Creating a script is just as simple as putting the opcodes in a Python list: <code>[ OP_RETURN ]</code> is how you would create the <a href='../../slides/bitcoin.html#/unspendable'>provably unspendable transaction</a> discussed in the lecture slides. Other things that go into scripts – signatures and public key hashes – are also just included in such a list. Assuming you got the types correct, then the library will create the full script from such a list.</p></li>
<li><p>You will enter your private key into scripts.py as a string. To convert it to the private key format that the library uses, you pass it to <code>CBitcoinSecret()</code>. The object returned has a <code>.pub</code> field, which is the public key (the type of that public key is <code>CPubKey</code>). And that public key can be converted into a Bitcoin address by calling <code>P2PKHBitcoinAddress.from_pubkey(public_key)</code>. In fact, this is almost the exact code used by the provided files to generate keys. For that we just used random data – via <code>os.urandom(32)</code> – instead of a pre-defined public key string. An example:</p>
<pre><code>private_key = CBitcoinSecret(private_key_str)
public_key = private_key.pub
address = P2PKHBitcoinAddress.from_pubkey(public_key)</code></pre>
<ul>
<li>If a public key is to be put into a script, as happens in most of the scripts, then the type of that should be <code>CPubKey</code> – the type of the <code>.pub</code> field of the object returned by <code>CBitcoinSecret()</code></li>
</ul></li>
<li><p>Creating a signature is a bit more involved.</p>
<ul>
<li>Given the following parameters:
<ul>
<li><code>txin</code>: the transaction input from the transaction that created the UTXO that is being redeemed</li>
<li><code>txout</code>: the transaction output from the transaction that created the UTXO that is being redeemed</li>
<li><code>txin_scriptPubKey</code>: the pubKey script (aka output script) of the UTXO being redeemed</li>
<li><code>private_key</code>: the secret key being used to sign this transaction</li>
</ul></li>
<li>Then we create a signature with the following three lines of code:
<ul>
<li><code>tx = CMutableTransaction([txin], [txout])</code>:</li>
<li><code>sighash = SignatureHash(CScript(txin_scriptPubKey), tx, 0, SIGHASH_ALL)</code>:</li>
<li><code>sig = private_key.sign(sighash) + bytes([SIGHASH_ALL])</code>:</li>
</ul></li>
<li>This signature can be put into a list when providing a script</li>
<li>We provide a helper function, called <code>create_CHECKSIG_signature()</code>, in scripts.py to perform these calls.</li>
</ul></li>
</ul>
</div><div id='tpart-1-p2pkh' class='tabcontent'><h3 id='part-1-p2pkh'>Part 1: P2PKH</h3>
<p>The UTXO indices that you created when you split your tBTC are paid to a standard <a href='../../slides/bitcoin.html#/p2pkh'>P2PKH transaction</a>. Your task is to redeem them by writing the appropriate scripts (pubkey and sigscript) to redeem the coins from one of the UTXOs. It should be paid back to the faucet – use the <code>faucet_adress</code> variable, defined at the top of the <code>scripts.py</code> file, as the receiver of this transaction.</p>
<p>To complete this transaction, you need to complete four things:</p>
<ul>
<li>The <code>P2PKH_scriptSig(...)</code> function provides the sigscript needed to redeem the UTXO being spent. The UTXO that is being redeemed – one of the split UTXO indices from above – requires a P2PKH sigScript to redeem one of the indices.</li>
<li>The <code>P2PKH_scriptPubKey(address)</code> function defines the pubKey script (aka output script). This was discussed in lecture in the <a href='../../slides/bitcoin.html#/p2pkh'>P2PKH transaction</a> slides. This script creates a new UTXO, payable to the faucet address, that is also a P2PKH script. The parameter is of type <code>P2PKHBitcoinAddress</code>, which is what the <code>P2PKHBitcoinAddress.from_pubkey(public_key)</code> call (shown above) returns; a variable this type can be put directly into a script.</li>
<li>Set the transaction to be spent via the <code>txid_utxo</code> variable; the default is the transaction ID that was split (i.e., the <code>txid_split</code>).</li>
<li>Set the output index to spend via <code>utxo_index</code>; it is currently set to 0. Recall that output indices start from 0, not 1. Be sure to pick an unspent index! If you have to run this multiple times, you may have to change this value to an unspent index.</li>
</ul>
<p>When you have finished the script, you can run it via <code>./bitcoinctl.py part1</code>; it will report an error if you get it wrong. If it works, you will see a JSON dictionary printed to the screen. Record the transaction ID of that transaction in <code>txid_p2pkh</code>. The TXID is the ‘hash’ field in the dictionary that is printed to the screen when run. You can then run <code>./bitcoinctl.py geturls</code> to get the URL for the transaction that you just executed. It may take up to 10 minutes for it to be mined into the blockchain.</p>
<p>You should notice your wallet balance has decreased.</p>
</div><div id='tpart-2-puzzle-script' class='tabcontent'><h3 id='part-2-puzzle-script'>Part 2: Puzzle script</h3>
<p>For this tBTC transaction, you are going to create an algebraic puzzle script – one that anybody can redeem as long as they complete the numerical puzzle.</p>
<p>You will first need to pick two 4-digit base-10 numbers (meaning between 1,000 and 10,000 in value). You can take your UVA SIS ID and split the digits in half. These will be the solutions to the linear equations below. You will likely need to tweak these numbers in a moment. You will need to store those values into <code>puzzle_txn_p</code> and <code>puzzle_txn_q</code> in scripts.py.</p>
<p>The puzzle transaction will deal with the solution to the following two linear equations:</p>
<p><span class='math display'>3<em>x</em> + <em>y</em> = <em>p</em></span> <span class='math display'><em>x</em> + 3<em>y</em> = <em>q</em></span></p>

<p>You can use an online linear question solver, such as <a href='https://onsolver.com/system-equations.php'>this one</a>, to find the solution. And <strong><em>make sure</em></strong> that the solutions are integer values! If not, then tweak one (or both) of your solutions (<span class='math inline'><em>p</em></span> and/or <span class='math inline'><em>q</em></span>) until you have integer solutions. Once you know those values, put them into <code>puzzle_txn_x</code> and <code>puzzle_txn_y</code> in scripts.py</p>
<p>For this part, you will create a transaction to redeem one of the split UTXO indices that were created, above. The pubKey (output) script of that newly created transaction will be specified in the <code>puzzle_scriptPubKey()</code> function in scripts.py. Note that because this output script does not depend on the receiver’s public key, that is not provided as a parameter to the function. Also note that the <code>OP_MUL</code> opcode has been disabled on the Bitcoin networks, so you can’t use that. This pubKey script should verify that the two values specified by the redeemer fulfill those two equations. Once this is created, run <code>./bitcoinctl.py part2a</code> – remember to choose an unspent UTXO index first via the <code>utxo_index</code> variable. As above, record the transaction hash into the <code>txid_puzzle_txn1</code> variable.</p>
<p>You will also need to create the sigScript that redeems this transaction. This should <strong>ONLY</strong> contain the two values <span class='math inline'><em>x</em></span> and <span class='math inline'><em>y</em></span> – their order is up to you, as long as it works with the script you created above. That script goes into <code>puzzle_scriptSig()</code>. This also does not depend on any signatures, which is why there are no parameters to that function. Ensure that the previous transaction has been mined into the blockchain, which may take up to 10 minutes – if you have entered the previous transaction’s URL into the <code>txid_puzzle_txn1</code> variable, you can get the URL of that transaction via <code>./bitcoinctl.py geturls</code>. When ready, you can send the redeeming trasnaction to the tBTC network via <code>./bitcoinctl.py part2b</code> (remember to choose an unspent UTXO index first). Record the transaction hash into <code>txid_puzzle_txn2</code>.</p>
<p>You will notice that the amount in each UTXO index from the split transaction is 0.0001 tBTC. For the first half of this puzzle transaction, the amount transacted is slightly less (90% of that, or 0.00009). The difference – 0.00001 tBTC – is the transaction fee. Even though this is a test network, and no actual money is involved, your transaction will not be mined into the blockchain unless you have a transaction fee. For the second half of this, we need to lower the amount even further, so the amount transacted is 90% of 0.00009, or 0.000081; this lowering is done automatically by the code base provided. The difference here – 0.000009 tBTC – is the transaction fee. While the test network requires there be <em>some</em> transaction fees, it doesn’t seem to care much about how much those fees are, which is different than with the real BTC network. This automatic lowering of the transaction amount will recur elsewhere in this assignment.</p>
<p><strong>NOTE:</strong> The purpose of this part is for your redeeming script to actually check if the values passed in for <span class='math inline'><em>x</em></span> and <span class='math inline'><em>y</em></span> fulfill the equation. You need to actually make that computation, not just check for equality for some pre-set values for <span class='math inline'><em>x</em></span> and <span class='math inline'><em>y</em></span>. This is something we explicitly check for when grading the assignment.</p>
<p>IMPORTANT NOTE: There are occasionally people who redeeming all of our puzzle transactions (part 2a) on the Bitcoin test network – they are parsing the output script, computing the answers, and redeeming the transaction. Because this script does not have a signature, anybody can redeem it. If you keep getting oddball errors, and you have set your transaction hash and UTXO index correctly, check the transaction page itself to see if it’s already spent. For the puzzle transactions, blockcyper.com just says “unknown script type”, and does not indicate if it’s spent or not, but blockchain.com does show this – search for the transaction hash, and in the outputs section, the Details item (on the right) will indicate if it’s spent or not. If it is spent, you can click on the word ‘Spent’ to got the transaction that redeemed it. When grading it, we will look at (1) if the transaction from part 2a was broadcast, (2) whether it was redeemed (by you or somebody else), and (3) whether the two scripts verify with each other. Thus, it does not have to be <em>your</em> transaction that redeems part 2a in part 2b, but your part 2b does have to verify with your part 2a.</p>
</div><div id='tpart-3-multisig' class='tabcontent'><h3 id='part-3-multisig'>Part 3: Multisig</h3>
<p>You are going to create a multi-signature transaction, which must use the <a href='../../slides/bitcoin.html#/checkmultisig'>OP_CHECKMULTISIG opcode</a>.</p>
<p>To set this up, you will need to create three more key pairs using <code>./bitcoinctl.py keygen</code>. Save these in the variables for Alice, Bob, and Charlie in part 3 of the <code>scripts.py</code> file. These addresses don’t need any tBTC – we just need the key pairs to perform digital signatures.</p>
<p>The scenario is this: you are taking on the role of a bank. Three siblings (Alice, Bob, and Charlie) have deposited money into an account, and it can be redeemed if two of the three – and also the bank! – agree to it. Formally, the transaction must be signed by the bank (i.e., you – via the keys in the <code>my_private_key_str</code> variable) and any two of the three siblings (via their private keys).</p>
<p>This will actually require two transactions. The first redeems one of the split UTXOs and creates a multi-signature pubKey (output) script. The second redeems that multi-signature script and pays it to the faucet address.</p>
<ol type='1'>
<li>Transaction 1: tBTC funds are taken from one of your split UTXO indices and put into a new UTXO whose output script requires the multiple signatures
<ul>
<li>The sigScript for this will be taken from your part (1), above – specifically from <code>P2PKH_scriptSig()</code>. So you don’t have to write this again. If your part (1) worked, then this should work as well.</li>
<li>The pubKey script for this you will be writing in the <code>multisig_scriptPubKey()</code> function.</li>
<li>Once successfully executed, record the transaction hash in the <code>txid_multisig_txn1</code> variable.</li>
</ul></li>
<li>Transaction 2: tBTC the funds from the multisig UTXO are redeemed and paid back to the faucet address.
<ul>
<li>The sigScript for this you will be writing in the <code>multisig_scriptSig()</code> function.</li>
<li>The pubKey script for this will be taken from your part (1) above – specifically from <code>P2PKH_scriptPubKey()</code>. So you don’t have to write this again. If you part (1) worked, then this should work as well.</li>
<li>Once successfully executed, record the transaction hash in the <code>txid_multisig_txn2</code> variable.</li>
</ul></li>
</ol>
<p>You only have to write the pubKey (output) script of the first transaction, and the sigScript (input) script of the second transaction. The other two parts (sigScript of the first and pubKey script of the second) are taken from your code in part (1) – so if that is not working, then this will not work either.</p>
<p>The first step is to create the transaction that sets up the multi-signature requirement in the pubKey script. This must use the <code>OP_CHECKMULTISIG</code> opcode! See the description of <a href='../../slides/bitcoin.html#/checkmultisig'>OP_CHECKMULTISIG opcode</a> in the lecture slides. Fill in the <code>multisig_scriptPubKey()</code> function. Recall that the sigScript will be used from your code for part (1). We recommend that you write this and the next script – the redeeming script – together, and trace its stack execution (on paper or similar). When you are ready to run it, be sure to set the <code>utxo_index</code> variable is set to the UTXO index you want to spend, and run <code>./bitcoinctl.py part3a</code>. Once successful, record the transaction ID in the <code>txid_multisig_txn1</code> variable in scripts.py.</p>
<p>The second step is to create a transaction that will redeem it. You will have to wait until the previous transaction receives at least one confirmation before you can execute this part, which can take up to 10 minutes. This part requires that the <code>txid_multisig_txn1</code> variable, from the first step above, is set properly, as that is the UTXO that is going to redeem. You will fill in your sigScript into <code>multisig_scriptSig()</code>. Recall that the pubKey script for this transaction will be used from your answer for part (1). When you are ready to run it, be sure to set the <code>utxo_index</code> variable at the top to the UTXO index you want to spend; this is likely 0, since there is only one output from the UTXO from the transaction just above. You run it via <code>./bitcoinctl.py part3b</code>. Once successful, record the transaction hash in the <code>txid_multisig_txn2</code> variable in scripts.py.</p>
<p>IMPORTANT NOTE: For the <code>OP_CHECKMULTISIG</code>, it should have ONLY the keys/signatures of Alice, Bob, and Charlie; the bank signature should not be in there. Instead, the bank signature should be separate and verified with an <code>OP_CHECKSIG</code>. The reason is that if everything is in the <code>OP_CHECKMULTISIG</code>, then an empty set of signatures and keys will verify correctly. This is relevant because there is some user on the Bitcoin test network who is trying to redeem your UTXOs. In particular, it has been observed when the UTXO was only verified with a single <code>OP_CHECKMULTISIG</code>.</p>
</div><div id='tpart-4-cross-chain' class='tabcontent'><h3 id='part-4-cross-chain'>Part 4: Cross-chain</h3>
<p>In this part you will create the scripts for a <a href='../../slides/bitcoin.html#/xchain'>cross-chain transaction</a>. Typically this would be for two different cryptocurrencies. However, since we only have learned Bitcoin Script, we will use that for both parts. There are many cryptocurrencies that are forks of Bitcoin, and thus have the same scripting language, so the same program could work for them. Or a completely different cryptocurrency, with a different scripting language, would have an analogous script. However, to test this we will be using two <em>different</em> Bitcoin testing blockchains.</p>
<p>In addition to the lecture slides, you may want to refer to the <a href='https://en.bitcoin.it/wiki/Atomic_swap'>Atomic swap article</a> in the <a href='https://en.bitcoin.it/wiki/Main_Page'>Bitcoin wiki</a>.</p>
<p>So far we have been using tBTC on the Bitcoin Testnet. For this part we will also be using the BlockCypher Testnet – this is also a fake Bitcoin network for testing, and it operates just like the Bitcoin Testnet we’ve been using. Bitcoin on this other testnet will be abbreviated as BCY (for BlockCYpher testnet). Note that we have been using <a href='https://live.blockcypher.com/'>blockcypher.com</a> to view all of our transactions, since that site can view both of these Bitcoin test networks.</p>
<p>In this part, you and Bob will be exchanging coins through a cross-chain transaction. You will need to be familiar with the <a href='../../slides/bitcoin.html#/xchain'>cross-chain transaction section of the Bitcoin slide set</a>. You are going to take on the role of Alice in the lecture slides.</p>
<p>As an overview, this is what is going to happen.</p>
<ol type='1'>
<li>You (Alice) are going to create a transaction to send tBTC to Bob. You will send it from the account you have been using so far (saved in <code>my_private_key_str</code> and <code>my_invoice_address_str</code> in scripts.py). Bob will receive it in the account that was created for him in the previous part (<code>bob_private_key_str</code> and <code>bob_invoice_address_str</code> in scripts.py). This corresponds to <a href='../../slides/bitcoin.html#/xchainpt1'>part 1 of the cross-chain transaction</a> – again, you are taking on the role of Alice. You will only be creating TXN1 from that slide; we are omitting TXN2.</li>
<li>Bob will create a transaction to send BCY to you. Both you and Bob will need to create invoice addresses and public keys for the BCY testnet, which we guide you through below. This corresponds to <a href='../../slides/bitcoin.html#/xchainpt2'>part 2 of the cross-chain transaction</a> – again, you are taking on the role of Alice. You will only be creating TXN3 from that slide; we are omitting TXN4.</li>
<li>You (Alice) will redeem TXN3 on the BCY network, exposing the hidden secret.</li>
<li>Bob, now knowing the hidden secret, will then redeem TXN1 on the tBTC network.</li>
</ol>
<h4 id='setup'>Setup</h4>
<p>To set this up, we need to create Bitcoin keypairs for the BlockCypher testnet, and use a faucet to give us some coins. The process for creating keys and funding the accounts is different for the BCY test network.</p>
<ol type='1'>
<li><p>Create an account at <a href='https://accounts.blockcypher.com/'>https://accounts.blockcypher.com/</a>, which will allow you to get an API token. Your token will be a hex number such as 0123456789abcdef0123456789abcdef. Save this token somewhere safe! You are welcome to record it in scripts.py (<code>blockcypher_api_token</code> is set aside for that), but that’s completely optional.</p></li>
<li><p>To create keys, you will need to run the following from the command line, putting your token in there instead of <code>API_TOKEN</code>. You should do this twice, one for you and once for Bob.</p>
<pre><code>curl -X POST 'https://api.blockcypher.com/v1/bcy/test/addrs?token=API_TOKEN'</code></pre></li>
<li><p>Save those tokens in scripts.py; yours go into <code>my_private_key_bcy_str</code> and <code>my_invoice_address_bcy_str</code>, and Bob’s go into <code>bob_private_key_bcy_str</code> and <code>bob_invoice_address_bcy_str</code>. Note that the <code>curl</code> command returns 4 values, but we only need to save two for each of the accounts. Also note that the format of the private key is different for this network – this one is hex encoded, whereas the one for the tBTC network was base-58 encoded. The provided code base properly handles this difference.</p></li>
<li><p>Only Bob needs BCY funds. You can fund his account via the following command, replacing both Bob’s address for <code>BOB_BCY_ADDRESS</code> and your token for <code>API_TOKEN</code>:</p>
<pre><code>curl -d '{"address": "BOB_BCY_ADDRESS", "amount": 100000}' https://api.blockcypher.com/v1/bcy/test/faucet?token=API_TOKEN</code></pre></li>
<li><p>The above command will return a transaction hash; save that in <code>txid_bob_bcy_funding</code>. If you run <code>./bitcoinctl.py geturls</code> it will display the full URL that you can use to view that funding transaction.</p></li>
<li><p>We will need to split Bob’s funds into parts, just like we did in the setup, above. Make sure that you have Bob’s private key and invoice address set in scripts.py (in <code>bob_private_key_bcy_str</code> and <code>bob_invoice_address_bcy_str</code>), as well as the transaction hash that funded the wallet (in <code>txid_bob_bcy_funding</code>). Lastly, look at the URL for that funding transaction (you can get that via <code>./bitcoinctl.py geturls</code>) and determine the UTXO index – that needs to be set in <code>utxo_index</code>. The run <code>./bitcoinctl.py splitbcy</code> – notice that the command is <code>splitbcy</code>, not <code>split</code>! Record the transaction hash returned from that execution run in <code>txid_bob_bcy_split</code>.</p></li>
</ol>
<p>Whew! The setup for this part is all done! Now onto the scripting part….</p>
<h4 id='cross-chain-atomic-swap'>Cross-chain atomic swap</h4>
<p>Because we are swapping between two different Bitcoin test networks, the atomic swap code is really the same – both are in Bitcoin script. TXN 1 (from <a href='../../slides/bitcoin.html#/xchainpt1'>here in the slides</a>) and TXN 3 (from <a href='../../slides/bitcoin.html#/xchainpt2'>here in the slides</a>) differ only by the public keys:</p>
<ul>
<li>TXN 1: Pay <em>w</em> BTC to &lt;B’s public key&gt; if (<em>x</em> for <em>h(x)</em> known and signed by B) or (signed by A & B)</li>
<li>TXN 3: Pay <em>v</em> BTC to &lt;A’s public key&gt; if (<em>x</em> for <em>h(x)</em> known and signed by A) or (signed by A & B)</li>
</ul>
<p>Your script code for this will go into the <code>atomicswap_scriptPubKey()</code> function.</p>
<p><strong>NOTE:</strong> the hash that is used in this part is RIPEMD-160, <em>not</em> SHA-256. So be sure to use the <code>OP_HASH160</code> opcode to get the hash, and not the <code>OP_SHA256</code> opcode.</p>
<p>To help you with this code, we provide the two redeeming functions:</p>
<ul>
<li><code>atomcswap_scriptSig_redeem()</code> is when Alice or Bob, knowing the secret, wants to redeem the transaction. The <code>OP_TRUE</code> is for use in an <code>OP_IF</code> statement in the script you have to write.</li>
<li><code>atomcswap_scriptSig_refund()</code> is used when the transaction times out – that’s when the sender can get a refund on his/her transaction; this has to be signed by both Alice and Bob. The particular script sent to redeem this would be TXN 2 (from <a href='../../slides/bitcoin.html#/xchainpt1'>here</a>) or TXN 4 (from <a href='../../slides/bitcoin.html#/xchainpt2'>here</a>). You do not have to implement TXN 2 or TXN 4.</li>
</ul>
<p>The last thing to do before you write the <code>atomicswap_scriptPubKey()</code> function is to determine what the secret is – <strong>pick a number between 17 million and 2 billion</strong>, and save that in <code>atomic_swap_secret</code>. (It needs to be in that range to ensure it’s encoded as a 4-byte integer). Keep in mind that this secret is only known to Alice initially; Bob is only given the hash of the secret (the bitcoinctl.py file handles that part for you).</p>
<p>Once you have written the script in the <code>atomicswap_scriptPubKey()</code> function, you can perform your cross-chain transaction. This involves four steps, which are outlined below. After you perform each step, enter the transaction hash into the variable as specified, and then get the URL via <code>./bitcoinctl.py geturls</code>. You can check that URL to ensure that it works properly. As with the previous transactions, you have to wait up to 10 minutes for at least one confirmation before you can redeem that UTXO.</p>
<ol type='1'>
<li>You (Alice) transmits <a href='../../slides/bitcoin.html#/xchainpt1'>TXN 1</a> to the tBTC network, which was created by the <code>atomicswap_scriptPubKey()</code> function. Be sure to set the <code>utxo_index</code> variable in scripts.py to a valid index before running this part! This is run via <code>./bitcoinctl.py part4a</code>. Save the transaction hash for this in the <code>txid_atomicswap_alice_send_tbtc</code> variable.</li>
<li>Bob transmits <a href='../../slides/bitcoin.html#/xchainpt2'>TXN 3</a> to the BCY network, which was also created by the <code>atomicswap_scriptPubKey()</code> function. Be sure to set the <code>utxo_index</code> variable in scripts.py to a valid index before running this part! This is run via <code>./bitcoinctl.py part4b</code>. Save the transaction hash for this in the <code>txid_atomicswap_bob_send_bcy</code> variable.</li>
<li>Alice (you) can redeem TXN 3 on the BCY network, which reveals the secret. Be sure to set the <code>utxo_index</code> variable in scripts.py to a valid index before running this part! This is run via <code>./bitcoinctl.py part4c</code>. Save the transaction hash into <code>txid_atomicswap_alice_redeem_bcy</code>.</li>
<li>Bob can new redeem TXN 1 on the tBTC network, since he knows the secret which Alice just revealed via her redemption above. Be sure to set the <code>utxo_index</code> variable in scripts.py to a valid index before running this part! This is run via <code>./bitcoinctl.py part4d</code>. Save the transaction hash into <code>txid_atomicswap_bob_redeem_tbtc</code>.</li>
</ol>
</div><div id='tpart-5-return-tbtc' class='tabcontent'><h3 id='part-5-return-tbtc'>Part 5: Return tBTC</h3>
<p>Once you have completed this assignment, you should pay any unspent tBTC UTXOs back to the faucet address. You can use the script from part 1 for this – just change the <code>utxo_index</code> value and re-run it until all the UTXO indices are spent. If you have any other inputs – perhaps you used the faucet multiple times – just change the <code>txid_split</code> variable (and the <code>utxo_index</code> and the <code>send_amount</code>), and then call <code>./bitcoinctl.py part1</code>. But be sure to change those values back!!!</p>
<p>When done, there should not be any unspent UTXOs remaining! We are going to test this by seeing if the amount of tBTC left in your wallet address is zero.</p>
<p>You do not need to do this for the extra BCY in your account(s).</p>
</div><div id='tsubmission' class='tabcontent'><h3 id='submission'>Submission</h3>
<p>The only file you need to submit to Gradescope is scripts.py. There will be a few sanity checks made when you submit it. Those checks are:</p>
<ul>
<li>Ensure that the <code>userid</code> returns a non-zero length string</li>
<li>Ensure that the three values set during setup (<code>my_private_key_str</code>, <code>my_invoice_address_str</code>, and <code>txid_initial</code>)</li>
<li>Ensure that all the transaction hashes (all the variables that start with <code>txid_</code>) are of the expected length (64 characters)</li>
<li>Ensure that the split transaction was split into at least 5 different UTXO indices</li>
<li>Ensure that the four parts verify via <code>VerifyScript()</code>. This does NOT mean they work correctly! It just means that the <code>VerifyScript()</code> function did not detect errors. For one example, the <code>VerifyScript()</code> has no way of knowing the actual signature required on the blockchain. This is the same function that is run before broadcasting the transactions to the network. The full grading will check what is on the blockchain itself.</li>
<li>Ensure that the final balance of the tBTC wallet (from <code>my_invoice_address_str</code>) is zero</li>
</ul>
<p><strong>Rate Limiter:</strong> The various aspects of this program are verified by checking via blockcyper.com’s API to obtain the wallet, transaction, balance, etc. As with most websites, there is a rate limiter, and if there are too many requests in too little a time period, then it will block requests to that IP address for some period. If everybody submits the assignment around the same time, this rate limiter will kick in, and the auto-grader will reports lots of errors. We will re-run the auto-grader at a later point to ensure that it is evaluated properly, but you will not see useful results when you submit your assignment. We have set up a proxy to help this issue (it caches previously made requests). However, if there are still too many requests, it will still run into the rate limiter. Unfortunately, there is nothing more we can do about this.</p>
</div><script>document.getElementById('defaultOpen').click();</script></body>
</html>

