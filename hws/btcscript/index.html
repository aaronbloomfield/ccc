<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' lang='' xml:lang=''>
<head>
  <meta charset='utf-8'></meta>
  <meta name='generator' content='pandoc'></meta>
  <meta name='viewport' content='width=device-width, initial-scale=1.0, user-scalable=yes'></meta>
  <title>Bitcoin Scripting</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel='stylesheet' href='../../markdown.css'></link>
  <script>
  function openTab(evt, tabName) {
    // Declare all variables
    var i, tabcontent, tablinks;

    // Get all elements with class="tabcontent" and hide them
    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i < tabcontent.length; i++) {
      tabcontent[i].style.display = "none";
    }

    // Get all elements with class="tablinks" and remove the class "active"
    tablinks = document.getElementsByClassName("tablinks");
    for (i = 0; i < tablinks.length; i++) {
      tablinks[i].className = tablinks[i].className.replace(" active", "");
    }

    // Show the current tab, and add an "active" class to the button that opened the tab
    document.getElementById(tabName).style.display = "block";
    evt.currentTarget.className += " active";
  }

  function insertCopyLink(text) {
    document.write("<span class=\"copylink copy_img\" onclick=\"navigator.clipboard.writeText('" + text.replace(/\"/g,"\\'") + "')\"></span>");
  }
  </script>
  
</head>
<body>
<h1 id='bitcoin-scripting'>Bitcoin Scripting</h1>
<p><a href='../index.html'>Go up to the CCC HW page</a> (<a href='../index.md'>md</a>) | <a href='index-full.html'>view one-page version</a></p><div class='tab'>
<button class='tablinks' onclick="openTab(event,'toverview')" id='defaultOpen'>Overview</button>
<button class='tablinks' onclick="openTab(event,'tchangelog')">Changelog</button>
<button class='tablinks' onclick="openTab(event,'tlanguages')">Languages</button>
<button class='tablinks' onclick="openTab(event,'thints')">Hints</button>
<button class='tablinks' onclick="openTab(event,'ttestnet')">Testnet</button>
<button class='tablinks' onclick="openTab(event,'tpython-library')">Python Library</button>
<button class='tablinks' onclick="openTab(event,'tpart-1-p2pkh')">P2PKH</button>
<button class='tablinks' onclick="openTab(event,'tpart-2-puzzle')">Puzzle</button>
<button class='tablinks' onclick="openTab(event,'tpart-3-multisig')">Multisig</button>
<button class='tablinks' onclick="openTab(event,'tpart-4-cross-chain')">Cross Chain</button>
<button class='tablinks' onclick="openTab(event,'tpart-5-return-tbtc')">Return tBTC</button>
<button class='tablinks' onclick="openTab(event,'tsubmission')">Submission</button>
</div>
<div id='toverview' class='tabcontent'><h3 id='overview'>Overview</h3>
<p>In this assignment you will be writing a series of Bitcoin scripts to enact transfers. You will be using a Bitcoin test network to do so. While regular Bitcoin uses the abbreviation BTC, we will use the abbreviation ‘tBTC’ (for test-BTC) for the Bitcoin on our test network.</p>
<p>There are four separate Bitcoin scripts that you will need to write. You will need to be familiar with the <a href='../../slides/bitcoin.html#/'>Bitcoin slide set</a>, specifically the <a href='../../slides/bitcoin.html#/script'>Bitcoin Script</a> and <a href='../../slides/bitcoin.html#/xchain'>Cross-Chain Transactions</a> sections. You will also likely need to refer to the <a href='https://en.bitcoin.it/wiki/Script'>Bitcoin Script wiki page</a>.</p>
<p>You will be submitting an edited version of <a href='scripts.py.html'>scripts.py</a> (<a href='scripts.py'>src</a>).</p>
</div><div id='tchangelog' class='tabcontent'><h3 id='changelog'>Changelog</h3>
<p>Any changes to this page will be put here for easy reference. Typo fixes and minor clarifications are not listed here. So far there aren’t any significant changes to report.</p>
</div><div id='tlanguages' class='tabcontent'><h3 id='languages'>Languages</h3>
<p>This assignment uses the <a href='https://pypi.org/project/python-bitcoinlib/'>python-bitcoinlib package</a> (documentation is <a href='https://python-bitcoinlib.readthedocs.io/en/latest/'>here</a>, if you are interested, but you probably won’t need it). Thus, this assignment must be completed in Python. You can install the Python package via <code>pip install python-bitcoinlib</code> (you may need to use <code>pip3</code> on your system). Note that bitcoinlib, python-bitcoinlib, and bitcoin are all different libraries! We are specifically using python-bitcoinlib.</p>
<p>You also will have to install the <code>requests</code> library: <code>pip install requests</code>, as one of the provided files, below, uses that library.</p>
<p>We provide you with a few files to use:</p>
<ul>
<li><a href='scripts.py.html'>scripts.py</a> (<a href='scripts.py'>src</a>): you will modify this file throughout this assignment. The progression of items in that file mirrors the progression of the assignment steps herein. This is the only file that you will submit. We would expect that you would be able to understand everything in this file by the end of the assignment</li>
<li><a href='bitcoinctl.py.html'>bitcoinctl.py</a> (<a href='bitcoinctl.py'>src</a>): this is the driver file that will run the various parts of the assignment using the values in the above scripts.py. You are of course welcome to look at the details, but you are not expected to understand the code that is in that file.</li>
</ul>
</div><div id='thints' class='tabcontent'><h3 id='hints'>Hints</h3>
<p>This can be a tricky assignment, and there are a lot of ways to run into problems. We include a number of hints here to try to head that off – please read through all of these!</p>
<h4 id='development-tips'>Development Tips</h4>
<ul>
<li>You will often have to wait until a previous transaction has been confirmed before you can run a successive transaction. If you look at the page for the wallet or the transaction (both described below), you need at least one confirmation (not 6, like with real BTC). Many of the follow-on transactions will not work properly if the funding UTXO transaction has not been confirmed.
<ul>
<li>Confirmation can take some time – 10-20 minutes is not unreasonable. Start early and plan to work on other things while it’s bouncing around the mempool waiting to be confirmed.</li>
</ul></li>
<li>You can, and should, use a site such as <a href='https://siminchen.github.io/bitcoinIDE/build/editor.html'>https://siminchen.github.io/bitcoinIDE/build/editor.html</a> to test your code. Note that this site is, by necessity, limited in what it can do. It will try to execute the scripts, but it doesn’t always know if there is enough balance, if the corresponding UTXO script matches, etc. So use that site to get started, but be sure to test your scripts via the means specified in this assignment.</li>
</ul>
<h4 id='general-hints'>General Hints</h4>
<ol type='1'>
<li><strong>UTXO indices:</strong> each transaction has one more more UTXO indices – each transaction output creates a separate UTXO index. To find out what UTXO index you need to use, <em>view the transaction on the blockcypher.com website</em> (the URL for that will be discussed shortly). All UTXO indices start from 0, like arrays. In particular, for your funding transaction, your UTXO index will probably not be 0. You need to set the UTXO variable for <strong>EACH</strong> transaction to the correct UTXO index. The preferred way to do this is via the second command line parameter, but can also be set via the <code>utxo_index</code> value in scripts.py. Note that the command-line parameter will override the <code>utxo_index</code> value.</li>
<li>After each transaction, there is a place to store the transaction hash. Be diligent about doing this – it’s really easy to lose track of which of a dozen transaction hashes is which. Keeping them in the stated variables will help with this. You are welcome to store values in additional variables, as long as they are different names than the ones currently in scripts.py.</li>
<li>Don’t modify the variable or function names in the scripts.py file. Otherwise the provided functions, and our grading routines, will not work. You can <em>add</em> functions and variables with different names, but don’t change the ones currently there.</li>
<li>For <em>EACH</em> transaction, you will need to set the UTXO. If you get an error stating that the UTXO index is already spent, it’s likely that you forgot to set this variable. If it sounds like we are repeating this, it is because this is, by far, the most common mistake made in this assignment.</li>
<li>Some errors with the Bitcoin scripts can be determined prior to broadcasting it on the Bitcoin test network. This is done by the <code>VerifyScript()</code> method, which the provided code base calls for you before any attempted broadcast transaction. So if you see an error such as, <code>verifyerror: "bitcoin.core.scripteval.VerifyOpFailedError: EvalScript: OP_EQUALVERIFY failed</code>, or similar, it means that the Bitcoin library was able to detect that your script would not work, and did not broadcast the transaction.</li>
<li>We provide you with a <code>create_CHECKSIG_signature()</code> function in the scripts.py file – use it! See the comments in that file for details as to how. We also describe its usage below (the end of the Python Library section).</li>
<li>To save you the tedious task of having to learn the <a href='https://pypi.org/project/python-bitcoinlib/'>Python Bitcoin library</a> (documentation is <a href='https://python-bitcoinlib.readthedocs.io/en/latest/'>here</a>, if you are interested) – which you probably will never need to use again – much of the library interaction has been handled for you by the provided code in <a href='bitcoinctl.py.html'>bitcoinctl.py</a> (<a href='bitcoinctl.py'>src</a>). But in order for that to work, you have to proceed through this homework in the order written.</li>
<li>If you want to put the number 2 onto the stack, you can’t just use the integer value 2. Instead, you have to use the <code>OP_2</code> opcode. In fact, <code>OP_2</code> happens to have integer value 82, and the integer value 2 has a different meaning.</li>
</ol>
<h4 id='common-errors'>Common Errors</h4>
<p>We will add to this list as more errors (and their solutions) are reported to us.</p>
<ul>
<li>“Error validating transaction: Transaction … referenced by input 0 has lesser than 3 outputs” means the UTXO index you provided is wrong (probably too high)</li>
<li>“Error validating transaction: Transaction … referenced by input 0 has already been spent” means the UTXO index you provided is wrong (probably too low)</li>
<li>“Error validating transaction: Error running script for input 0 referencing … at 0: Script was NOT verified successfully” is when the scripts don’t work together</li>
<li>A “409 Conflict {}” error occurs when you attempt to spend a UTXO that’s already been spent; this usually happens when you forget to set the UTXO to an unspent index</li>
<li>“witness script detected in tx without witness data”: your UTXO is wrong</li>
<li>“unsupported hash type ripemd160”: see <a href='https://stackoverflow.com/questions/72409563/unsupported-hash-type-ripemd160-with-hashlib-in-python'>here</a> for how to fix this</li>
</ul>
<h4 id='mac-os-x-issues'>Mac OS X issues</h4>
<p>If you have a M1 Mac, there are a few issues you should be aware of.</p>
<p>Installing OpenSSL via homebrew has caused errors in past semesters. These errors report a problem with the “libeay32” library. Here are some possible solutions that have helped in the past:</p>
<ul>
<li>Installing OpenSSL as per <a href='https://www.davidseek.com/ruby-on-m1/'>https://www.davidseek.com/ruby-on-m1/</a></li>
<li>You can replace the OpenSSL library that python-bitcoinlib calls. In the bitcoin package, in <code>/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages/bitcoin</code> (that may differ on your machine), in <code>core/key.py</code>, replace <code>_ssl = ctypes.cdll.LoadLibrary(ctypes.util.find_library('ssl.35')</code> or <code>ctypes.util.find_library('ssl')</code> or <code>ctypes.util.find_library('libeay32')</code> with <code>_ssl = ctypes.cdll.LoadLibrary(ctypes.util.find_library('ssl.35')</code> or <code>ctypes.util.find_library('ssl'))</code>.</li>
</ul>
<p>We cannot vouch for any of these solutions; we just collected a bunch of Piazza responses from previous semesters.</p>
</div><div id='ttestnet' class='tabcontent'><h3 id='testnet'>Testnet</h3>
<p>As we do not want to have to buy, and likely lose, real BTC, we are going to use a Bitcoin test network. Because the coins we are going to be using are not “real” Bitcoins, we will use the abbreviation ‘tBTC’ (for testnet-BTC) instead of ‘BTC’. When using a test network, you get coins for free via a <em>faucet</em> – in the same way that a water faucet provides water once turned on, so does a testnet faucet provide free tBTC when requested.</p>
<p>You will need around 0.001 (<span class='math inline'>10<sup>−3</sup></span>) tBTC for this assignment. You can obtain this all at once, or as needed throughout the assignment. You will likely have to use multiple faucets, or use the same faucet multiple times (there is a multiple-hour wait between requests to a given faucet) to obtain this amount.</p>
<ol type='1'>
<li>You will need to generate a tBTC key pair. Run <code>python3 bitcoinctl.py genkey</code>, and note both the public and private keys. While these keys are not valid on the main Bitcoin test network – the have a different value for the <a href='../../slides/bitcoin.html#/btcaddress'>version byte</a> in the invoice address – you will need them throughout this assignment.
<ul>
<li>Save both the tBTC private key and the tBTC address into the scripts.py file into the <code>private_key_str</code> and <code>invoice_address</code> fields</li>
</ul></li>
<li>Using multiple faucets, or multiple requests to the same faucet, you need to obtain around 0.001 (<span class='math inline'>10<sup>−3</sup></span>) tBTC. This can be done all at once or as needed throughout the assignment. A list of faucets is below, but read the through the next step herein before using them. For each of the faucets below, you will be provided a transaction hash – save that hash! You may have to search down the web page for the specific transaction hash that pays to your tBTC address. And see the next step, below, for how to find your current balance.
<ul>
<li>USE THIS ONE: <a href='https://coinfaucet.eu/en/btc-testnet/'>Faucet at coinfaucet.eu</a>: pays quickly and relatively large amounts</li>
<li>Only if that one is not working should you use: <a href='https://testnet-faucet.com/btc-testnet/'>Faucet at testnet-faucet.com</a>: pays quickly, but pays a very small amount</li>
<li>Feel free to find other faucets via an <a href='https://duckduckgo.com/?q=bitcoin+testnet+faucet'>appropriate web search</a>, but if they ask you for any information other than your Bitcoin wallet address and a CAPTCHA, then it’s a shady site, and you should use a different one</li>
</ul></li>
<li>Each faucet will provide you with a transaction hash where it gave you the tBTC.
<ul>
<li>Enter each faucet funding transaction hash in scripts.py in <code>txid_funding_list</code>; each one is just a separate string in that list</li>
<li>Verify that you can view your account information at https://live.blockcypher.com/btc-testnet/address/&lt;address&gt; where &lt;address&gt; is your tBTC address – the amount that address holds should be the sum of the amounts that the faucet provided to you.
<ul>
<li>You can also go to <a href='https://live.blockcypher.com'>https://live.blockcypher.com</a> and enter the wallet address in the search box – just be sure to select “Bitcoin Testnet” in the blue drop-down box</li>
<li>It may take up to 20 minutes or so for a transaction that funded your wallet to be mined into the blockchain</li>
</ul></li>
<li>You can also view individual transactions at <a href='https://live.blockcypher.com/'>https://live.blockcypher.com/</a> – put the transaction hash in the search box and be sure to select ‘Bitcoin Testnet’ for the search. Verify that you can view the transaction at https://live.blockcypher.com/btc-testnet/tx/&lt;txid&gt; where &lt;txid&gt; is your transaction hash
<ul>
<li>Note that the testnets often perform many transfers in one transaction – so the total amount transacted may be more than 0.001 (<span class='math inline'>10<sup>−3</sup></span>) tBTC, but the rest was paid back to the faucet</li>
</ul></li>
<li>You can also get these URLs by running <code>python3 bitcoinctl.py urls</code>. As you fill in more transaction hashes throughout this assignment, re-running this command will show an increasing list of URLs.</li>
</ul></li>
<li>Each faucet transaction paid to the invoice address via only one UTXO, and we would like multiple UTXO indices to use – this way we can use one per question part, and we have a few extra if something ends up not working correctly.
<ul>
<li>We are going to split the incoming UTXO into multiple smaller UTXOs. Each of the smaller UTXOs will need to be for 0.0001 (<span class='math inline'>10<sup>−4</sup></span>) tBTC.
<ul>
<li>Important: if split into smaller amounts, then the transaction fees will be insufficient to have your transaction mined into the blockchain.</li>
<li>This means if the amount from the faucet is not more than twice this amount (meaning more than <span class='math inline'>2 * 10<sup>−4</sup></span>), then you should NOT split that UTXO.</li>
</ul></li>
<li>Look at the section of scripts.py that deals with splitting coins. The default values there will need to be changed
<ul>
<li>The <code>txid_split</code> is the particular transaction hash that you are splitting, which should be in the <code>txid_funding_list</code> list – you may have to run this multiple times to split multiple faucet funding UTXOs, each with a different transaction hash from the faucet</li>
<li>The <code>split_amount_to_split</code> is how much is in the incoming UTXO; look this up on <a href='https://live.blockcypher.com'>https://live.blockcypher.com</a> to get the correct amount</li>
<li>The <code>split_amount_after_split</code> is how much you want in each UTXO after the split – it should not be less than 0.0001 BTC (<span class='math inline'>10<sup>−4</sup></span>), and 0.001 (<span class='math inline'>10<sup>−3</sup></span>) – the default – is ideal</li>
<li>The <code>split_into_n</code> attempts to determine how many UTXOs to split it into, and you should not need to change it</li>
<li>Do NOT change <code>utxo_index</code> – the UTXO index is set via a command-line parameter, described below</li>
<li><strong>SET YOUR UTXO INDEX</strong>: this is done via the second command-line parameter, and you must set it for the particular UTXO index for the transaction where that you are splitting. Most faucets pay themselves in UTXO index 0, and then pay out the requested invoice address in index 1.</li>
<li>Check the transaction – via the URL from above – that gave you the coins, and make sure you have the right UTXO index (via the second command-line parameter). If you get an error such as “witness script detected in tx without witness data”, then it probably means your UTXO index is wrong.</li>
</ul></li>
<li>Run <code>python3 bitcoinctl.py split &lt;utxo&gt;</code> to split your coins. The <code>&lt;utxo&gt;</code> field is the integer UTXO index, which is indexed from 0. This uses the values in the splitting coins section of scripts.py that were just discussed.
<ul>
<li>If this works properly, it will present back a Python dictionary that will take up many lines. If it doesn’t work, it will give you an error in just a few lines.</li>
</ul></li>
<li>You need to put the hash of that transaction in the <code>txid_split_list</code> list – there are two ways to determine that hash:
<ul>
<li>It’s the 6th (or so) line printed in the output when you called the split command, above – it’s the <code>hash</code> line</li>
<li>Look at the <em>wallet</em> info URL (run <code>python3 bitcoinctl.py urls</code> to get the URL), and note the transaction hash of the split transaction – it should be the top transaction listed, and will have 9 or 10 different outputs. The transaction hash itself is also listed in the output from the split transaction – it’s the <code>hash</code> field of the dictionary, and is about a half a dozen lines down. Record that transaction hash in scripts.py in <code>txid_split_list</code></li>
</ul></li>
</ul></li>
</ol>
<p>Be careful not to lose the information (keys and TXIDs) that you recorded above. To prevent abuse, the faucets only allows one request every so often (1 to 12 hours, depending on the faucet) for a given IP address or tBTC address. If you need more during that 12 hour window, or you are running into ‘exceeded limit’ issues, you can try requesting it through a different faucet or through your cell phone. If you put it on cellular (meaning disconnect from UVA’s network), it will report a different IP address to the faucet.</p>
</div><div id='tpython-library' class='tabcontent'><h3 id='python-library'>Python library</h3>
<p>The <code>python-bitcoinlib</code> library for Python handles much of the heavy lifting – conversion from one type to another, encryption, signing, verification, etc. If you were to enter actual keys that have real BTC then you could use this library to make real BTC transactions.</p>
<p>While the library can do many things, below is a quick summary of the relevant aspects that you will need to know for this assignment.</p>
<ul>
<li><p>Creating Bitcoin scripts is really just putting everything into a list. All the opcodes are named the same as on the <a href='https://en.bitcoin.it/wiki/Script'>Bitcoin Script page</a>. For example, here is the the <a href='../../slides/bitcoin.html#/unspendable'>provably unspendable transaction</a> discussed in the lecture slides: <code>[ OP_RETURN ]</code>. Other things that go into scripts – signatures and public key hashes – are also just included in such a list. Assuming you got the types correct, then the library will create the full script from such a list.</p></li>
<li><p>You will enter your private key into scripts.py as a string. To convert it to the private key format that the library uses, you pass it to <code>CBitcoinSecret()</code>. The object returned has a <code>.pub</code> field, which is the public key (the type of that public key is <code>CPubKey</code>). And that public key can be converted into a Bitcoin address by calling <code>P2PKHBitcoinAddress.from_pubkey(public_key)</code>. In fact, this is almost the exact code used by the <a href='bitcoinctl.py.html'>bitcoinctl.py</a> (<a href='bitcoinctl.py'>src</a>) file to generate keys (although for that it just used random data – via <code>os.urandom(32)</code> – instead of a pre-defined public key string). Here is an example as to how to convert your keys:</p>
<pre><code>my_private_key_str="..." # fill this in
from bitcoin.wallet import CBitcoinSecret, P2PKHBitcoinAddress
from bitcoin import SelectParams
SelectParams('testnet')
private_key = CBitcoinSecret(my_private_key_str)
public_key = private_key.pub
address = P2PKHBitcoinAddress.from_pubkey(public_key)</code></pre>
<ul>
<li>If a public key is to be put into a script, as happens in most of the scripts, then the type of that should be <code>CPubKey</code> – the type of the <code>.pub</code> field of the object returned by <code>CBitcoinSecret()</code></li>
</ul></li>
<li><p>Creating a signature is a bit more involved.</p>
<ul>
<li>Given the following parameters:
<ul>
<li><code>txin</code>: the transaction input from the transaction that created the UTXO that is being redeemed</li>
<li><code>txout</code>: the transaction output from the transaction that created the UTXO that is being redeemed</li>
<li><code>txin_scriptPubKey</code>: the pubKey script (aka output script) of the UTXO being redeemed</li>
<li><code>private_key</code>: the secret key being used to sign this transaction</li>
</ul></li>
<li>Then we create a signature with the following three lines of code:
<ul>
<li><code>tx = CMutableTransaction([txin], [txout])</code>:</li>
<li><code>sighash = SignatureHash(CScript(txin_scriptPubKey), tx, 0, SIGHASH_ALL)</code>:</li>
<li><code>sig = private_key.sign(sighash) + bytes([SIGHASH_ALL])</code>:</li>
</ul></li>
<li>This signature can be put into a list when providing a script</li>
<li>We provide a helper function, called <code>create_CHECKSIG_signature()</code>, in scripts.py to perform these calls.</li>
</ul></li>
</ul>
</div><div id='tpart-1-p2pkh' class='tabcontent'><h3 id='part-1-p2pkh'>Part 1: P2PKH</h3>
<p>The UTXO indices that you created when you split your tBTC are paid to a standard <a href='../../slides/bitcoin.html#/p2pkh'>P2PKH transaction</a>. Your task is to redeem them by writing the appropriate scripts (pubkey and sigscript) to redeem the coins from one of the UTXOs. It should be paid back to the designated return address – use the <code>tbtc_return_address</code> variable, defined at the top of the <code>scripts.py</code> file, as the receiver of this transaction.</p>
<p>To complete this transaction, you need to complete four things:</p>
<ul>
<li>The <code>P2PKH_scriptSig(...)</code> function provides the sigscript needed to redeem the UTXO being spent. The UTXO that is being redeemed – one of the split UTXO indices from above – requires a P2PKH sigScript to redeem one of the indices.</li>
<li>The <code>P2PKH_scriptPubKey(address)</code> function defines the pubKey script (aka output script). This was discussed in lecture in the <a href='../../slides/bitcoin.html#/p2pkh'>P2PKH transaction</a> slides. This script creates a new UTXO, payable to the tBTC return address, that is also a P2PKH script. The parameter is of type <code>P2PKHBitcoinAddress</code>, which is what the <code>P2PKHBitcoinAddress.from_pubkey(public_key)</code> call (shown above) returns; a variable this type can be put directly into a script.</li>
<li>Set the output index to spend via the second command line parameter. Recall that output indices start from 0, not 1. Be sure to pick an unspent index! If you have to run this multiple times, you may have to change this value to an unspent index.</li>
</ul>
<p><strong>IMPORTANT NOTE:</strong> For the sigScript, the public key used in the P2PKH script must come from the <code>private_key</code> parameter to the <code>P2PKH_scriptSig()</code> (it’s <code>private_key.pub</code>). If you use your global public key, it will work for this part, but it will fail for successive parts of this assignment.</p>
<p>When you have finished the script, you can run it via <code>python3 bitcoinctl.py part1 &lt;utxo&gt;</code>, where <code>&lt;utxo&gt;</code> is the particular UTXO index from the split transaction that you are using to fund this one; it will report an error if you get it wrong. The <code>&lt;utxo&gt;</code> field is the integer UTXO index, which is indexed from 0. Some common errors at this point are:</p>
<ul>
<li>“Error validating transaction: Transaction … referenced by input 0 has lesser than 3 outputs” means the UTXO index you provided is wrong (probably too high)</li>
<li>“Error validating transaction: Transaction … referenced by input 0 has already been spent” means the UTXO index you provided is wrong (probably too low)</li>
<li>“unsupported hash type ripemd160”: see <a href='https://stackoverflow.com/questions/72409563/unsupported-hash-type-ripemd160-with-hashlib-in-python'>here</a> for how to fix this</li>
</ul>
<p>If it works, you will see a JSON dictionary printed to the screen. Record the transaction hash of that transaction in <code>txid_p2pkh</code>. The TXID is the ‘hash’ field in the dictionary that is printed to the screen when run. You can then run <code>python3 bitcoinctl.py urls</code> to get the URL for the transaction that you just executed. It may take up to 10 minutes for it to be mined into the blockchain.</p>
<p>You should notice your wallet balance has decreased.</p>
</div><div id='tpart-2-puzzle' class='tabcontent'><h3 id='part-2-puzzle'>Part 2: Puzzle</h3>
<p>For this tBTC transaction, you are going to create an algebraic puzzle script – one that anybody can redeem as long as they complete the numerical puzzle.</p>
<p>You will first need to pick two 4-digit base-10 numbers (meaning between 1,000 and 10,000 in value) for the values of <span class='math inline'><em>p</em></span> and <span class='math inline'><em>q</em></span> in the equations below. You can take your UVA SIS ID and split the digits in half. These will be the solutions to the linear equations below. You will likely need to tweak these numbers in a moment. You will need to store those values into <code>puzzle_txn_p</code> and <code>puzzle_txn_q</code> in scripts.py.</p>
<p>The puzzle transaction will deal with the solution to the following two linear equations:</p>
<p><span class='math display'>2<em>x</em> + <em>y</em> = <em>p</em></span> <span class='math display'><em>x</em> + <em>y</em> = <em>q</em></span></p>




<p>You can use an online linear question solver, such as <a href='https://onsolver.com/system-equations.php'>this one</a>, to find the solution. And <strong><em>make sure</em></strong> that the solutions are positive integer values! If not, then tweak one (or both) of your solutions (<span class='math inline'><em>p</em></span> and/or <span class='math inline'><em>q</em></span>) until you have integer solutions. You can also change which of the equations has the higher of <span class='math inline'><em>p</em></span> and <span class='math inline'><em>q</em></span> to see if that will help as well. Once you know those values, put them into <code>puzzle_txn_p</code> and <code>puzzle_txn_q</code> in scripts.py. You will also want to <span class='math inline'><em>x</em></span> and <span class='math inline'><em>y</em></span> solutions to these equations into <code>puzzle_txn_x</code> and <code>puzzle_txn_y</code>.</p>
<h4 id='send-the-puzzle-transaction'>Send the puzzle transaction</h4>
<p>For this part, you will create a transaction to redeem one of the split UTXO indices that were created, above. The pubKey (output) script of that newly created transaction will be specified in the <code>puzzle_scriptPubKey()</code> function in scripts.py. Note that because this output script does not depend on the receiver’s public key, that is not provided as a parameter to the function. Also note that the <code>OP_MUL</code> opcode has been disabled on the Bitcoin networks, so you can’t use that. This pubKey script should verify that the two values specified by the redeemer fulfill those two equations. Once this is created, run <code>python3 bitcoinctl.py part2a &lt;utxo&gt;</code> – remember to choose an unspent UTXO index first via the second command line parameter. That <code>&lt;utxo&gt;</code> field is the integer UTXO index from the split transaction, which is indexed from 0. As above, record the transaction hash into the <code>txid_puzzle_txn1</code> variable.</p>
<h4 id='redeem-the-puzzle-transaction'>Redeem the puzzle transaction</h4>
<p>You will also need to create the sigScript that redeems this transaction. This should <strong>ONLY</strong> contain the two values <span class='math inline'><em>x</em></span> and <span class='math inline'><em>y</em></span> – their order is up to you, as long as it works with the script you created above. That script goes into <code>puzzle_scriptSig()</code>.</p>
<p><strong>IMPORTANT:</strong> Your your pubKey script should actually do the math to test that the two values (that will be provided in the sigScript) do, in fact, fulfill those linear equations. Just testing for equality to your pre-specified <span class='math inline'><em>x</em></span> and <span class='math inline'><em>y</em></span> is not the point of this portion of the assignment. This is something we explicitly check for when grading the assignment.</p>
<p>This also does not depend on any signatures, which is why there are no parameters to that function. Ensure that the previous transaction has been mined into the blockchain, which may take up to 10 minutes – if you have entered the previous transaction’s URL into the <code>txid_puzzle_txn1</code> variable, you can get the URL of that transaction via <code>python3 bitcoinctl.py urls</code>. When ready, you can send the redeeming trasnaction to the tBTC network via <code>python3 bitcoinctl.py part2b &lt;utxo&gt;</code> (remember to choose an unspent UTXO index first). The <code>&lt;utxo&gt;</code> field is the integer UTXO index, which is indexed from 0. As this UTXO is from the above transaction, and that transaction only created one UTXO index, the <code>&lt;utxo&gt;</code> value should be 0.</p>
<p>Record the transaction hash into <code>txid_puzzle_txn2</code>.</p>
<h4 id='notes'>Notes</h4>
<p>WARNING: There are occasionally people who redeeming all of our puzzle transactions (part 2a) on the Bitcoin test network – they are parsing the output script, computing the answers, and redeeming the transaction. Because this script does not have a signature, anybody can redeem it. If you keep getting oddball errors, and you have set your transaction hash and UTXO index correctly, check the transaction page itself to see if it’s already spent. When running <code>part2b</code> it might also report that the UTXO has been spent. For the puzzle transactions, blockcyper.com just says “unknown script type”, and does not indicate if it’s spent or not, but <a href='https://blockstream.info'>https://blockstream.info</a> does; search for the transaction from part 2a, and in the lower-right of that page where it lists the output, click on the “Details +” link – it will list the hash of the spending transaction. You should include that transaction hash in your scripts.py, even though you were not the entity that redeemed it. When grading it, we will look at (1) if the transaction from part 2a was broadcast, (2) whether it was redeemed (by you or somebody else), and (3) whether the two scripts verify with each other. Thus, it does not have to be <em>your</em> transaction that redeems part 2a in part 2b, but your part 2b script does have to verify with your part 2a script.</p>
<p>You will notice that the amount in each UTXO index from the split transaction is 0.001 tBTC. For the first half of this puzzle transaction, the amount transacted is slightly less (90% of that, or 0.0009). The difference – 0.0001 tBTC – is the transaction fee. Even though this is a test network, and no actual money is involved, your transaction will not be mined into the blockchain unless you have a sufficient transaction fee. For the second half of this, we need to lower the amount even further, so the amount transacted is 90% of 0.0009, or 0.00081; this lowering is done automatically by the code base provided. The difference here – 0.00009 tBTC – is the transaction fee. This automatic lowering of the transaction amount will recur elsewhere in this assignment.</p>
</div><div id='tpart-3-multisig' class='tabcontent'><h3 id='part-3-multisig'>Part 3: Multisig</h3>
<p>You are going to create a multi-signature transaction, which must use the <a href='../../slides/bitcoin.html#/checkmultisig'>OP_CHECKMULTISIG opcode</a> (or the <a href='../../slides/bitcoin.html#/checkmultisig'>OP_CHECKMULTISIGVERIFY opcode</a>).</p>
<p>To set this up, you will need to create three more key pairs using <code>python3 bitcoinctl.py keygen</code>. Save these in the variables for Alice, Bob, and Charlie in part 3 of the <code>scripts.py</code> file. These addresses don’t need any tBTC – we just need the key pairs to perform digital signatures.</p>
<p>The scenario is this: you are taking on the role of a bank. Three siblings (Alice, Bob, and Charlie) have deposited money into an account, and it can be redeemed if two of the three – and also the bank! – agree to it. Formally, the transaction must be signed by the bank (i.e., you – via the keys in the <code>my_private_key_str</code> variable) and any two of the three siblings (via their private keys).</p>
<p>This will actually require two transactions. The first redeems one of the split UTXOs and creates a multi-signature pubKey (output) script. The second redeems that multi-signature script and pays it to the tBTC return address.</p>
<ol type='1'>
<li>Transaction 1: tBTC funds are taken from one of your split UTXO indices and put into a new UTXO whose output script requires the multiple signatures
<ul>
<li>The sigScript for this will be taken from your part 1 (P2PKH), above – specifically from <code>P2PKH_scriptSig()</code>. So you don’t have to write this again. If your part 1 (P2PKH) worked, then this should work as well.</li>
<li>The pubKey script for this you will be writing in the <code>multisig_scriptPubKey()</code> function.</li>
<li>Once successfully executed, record the transaction hash in the <code>txid_multisig_txn1</code> variable.</li>
</ul></li>
<li>Transaction 2: tBTC the funds from the multisig UTXO are redeemed and paid back to the tBTC return address.
<ul>
<li>The sigScript for this you will be writing in the <code>multisig_scriptSig()</code> function.</li>
<li>The pubKey script for this will be taken from your part 1 (P2PKH) above – specifically from <code>P2PKH_scriptPubKey()</code>. So you don’t have to write this again. If you part 1 (P2PKH) worked, then this should work as well.</li>
<li>Once successfully executed, record the transaction hash in the <code>txid_multisig_txn2</code> variable.</li>
</ul></li>
</ol>
<p>You only have to write the pubKey (output) script of the first transaction, and the sigScript (input) script of the second transaction. The other two parts (sigScript of the first and pubKey script of the second) are taken from your code in part 1 (P2PKH) – so if that is not working, then this will not work either.</p>
<p>The first step is to create the transaction that sets up the multi-signature requirement in the pubKey script. This must use either the <code>OP_CHECKMULTISIG</code> or <code>OP_CHECKMULTISIGVERIFY</code>opcode! See the <a href='../../slides/bitcoin.html#/checkmultisig'>description of these opcodes</a> in the lecture slides. The task, then, is to fill in the <code>multisig_scriptPubKey()</code> function. Recall that the sigScript will be used from your code for part 1 (P2PKH). We recommend that you write this and the next script – the redeeming script – together, and trace its stack execution (on paper or similar). When you are ready to run it, run <code>python3 bitcoinctl.py part3a &lt;utxo&gt;</code>. The <code>&lt;utxo&gt;</code> field is the integer UTXO index, which is indexed from 0. Once successful, record the transaction hash in the <code>txid_multisig_txn1</code> variable in scripts.py.</p>
<p>The second step is to create a transaction that will redeem it. You will have to wait until the previous transaction receives at least one confirmation before you can execute this part, which can take up to 10 minutes. This part requires that the <code>txid_multisig_txn1</code> variable, from the first step above, is set properly, as that is the UTXO that is going to redeem. You will fill in your sigScript into <code>multisig_scriptSig()</code>. Recall that the pubKey script for this transaction will be used from your answer for part 1 (P2PKH). When you are ready to run it, run <code>python3 bitcoinctl.py part3b &lt;utxo&gt;</code>. The <code>&lt;utxo&gt;</code> field is the integer UTXO index, which is indexed from 0; it is likely 0, since there is only one output from the UTXO from the transaction from part 3a. Once successful, record the transaction hash in the <code>txid_multisig_txn2</code> variable in scripts.py.</p>
<p>IMPORTANT NOTE: For the <code>OP_CHECKMULTISIG</code> (or <code>OP_CHECKMULTISIGVERIFY</code>), it should have ONLY the keys/signatures of Alice, Bob, and Charlie; the bank signature should not be in there. Instead, the bank signature should be separate and verified with an <code>OP_CHECKSIG</code> (or <code>OP_CHECKSIGVERIFY</code>). The reason is that if everything is in the <code>OP_CHECKMULTISIG</code>, then an empty set of signatures and keys will verify correctly. This is relevant because there is some user on the Bitcoin test network who is trying to redeem your UTXOs. In particular, it has been observed when the UTXO was only verified with a single <code>OP_CHECKMULTISIG</code>.</p>
</div><div id='tpart-4-cross-chain' class='tabcontent'><h3 id='part-4-cross-chain'>Part 4: Cross-chain</h3>
<p>In this part you will create the scripts for a <a href='../../slides/bitcoin.html#/xchain'>cross-chain transaction</a>. Typically this would be for two different cryptocurrencies. However, since we have only learned Bitcoin Script, we will use that for both parts. There are many cryptocurrencies that are forks of Bitcoin, and thus have the same scripting language, so the same program could work for any of them. A completely different cryptocurrency, with a different scripting language, would have an analogous script. However, to test this we will be using two <em>different</em> Bitcoin testing blockchains.</p>
<p>Below you will be obtaining a Bitcoin key pair and funds on a separate Bitcoin blockchain. There will be <em>three</em> script producing functions in scripts.py, although you only have to create one. The first one, <code>atomicswap_scriptPubKey()</code>, will create the <a href='../../slides/bitcoin.html#/xchainpt1'>TXN 1 and TXN 3 from the slides</a>; this is the one that you have to create. This script will be used for BOTH of these transactions (with different parameters, of course) on the two different blockchains by the provided code in <a href='bitcoinctl.py.html'>bitcoinctl.py</a> (<a href='bitcoinctl.py'>src</a>). The second function, <code>atomcswap_scriptSig_redeem()</code>, will be when Alice or Bob knows the secret value and is redeeming the BTC; we provide this function for you in scripts.py. This is used in steps 5 and 6 on <a href='../../slides/bitcoin.html#/atomicsteps'>cross-chain atomic swap procedure slide</a>. The third function, <code>atomcswap_scriptSig_refund()</code>, will create the time-out redeeming script, which is <a href='../../slides/bitcoin.html#/xchainpt1'>TXN 2 and TXN 4 from the slides</a>; we also provide this function for you in scripts.py. Again, this will be used on both blockchains by the provided code. There are some requirements for what has to be in these scripts, described below (in “Notes and hints”).</p>
<p>In addition to the lecture slides, you may want to refer to the <a href='https://en.bitcoin.it/wiki/Atomic_swap'>Atomic swap article</a> in the <a href='https://en.bitcoin.it/wiki/Main_Page'>Bitcoin wiki</a>.</p>
<p>So far we have been using tBTC on the Bitcoin Testnet. For this part we will also be using the BlockCypher Testnet – this is also a Bitcoin network for testing, and it operates just like the Bitcoin Testnet we’ve been using. Bitcoin on this other testnet will be abbreviated as BCY (for BlockCYpher testnet). Note that we have been using <a href='https://live.blockcypher.com/'>blockcypher.com</a> to view all of our transactions, since that site can display transactions and invoice addresses on both of these Bitcoin test networks.</p>
<p>In this part, you (Alice) and Bob will be exchanging coins through a cross-chain transaction. You will need to be familiar with the <a href='../../slides/bitcoin.html#/xchain'>cross-chain transaction section of the Bitcoin slide set</a>. You are going to take on the role of Alice in the lecture slides.</p>
<p>As an overview, this is what is going to happen.</p>
<ol type='1'>
<li>You (Alice) are going to create a transaction to send tBTC to Bob. You will send it from the account you have been using so far (saved in <code>my_private_key_str</code> and <code>my_invoice_address_str</code> in scripts.py). Bob will receive it in the account that was created for him above (<code>bob_private_key_str</code> and <code>bob_invoice_address_str</code> in scripts.py). This corresponds to <a href='../../slides/bitcoin.html#/xchainpt1'>part 1 of the cross-chain transaction</a> – again, you are taking on the role of Alice. You will only be creating TXN1 from that slide; we are omitting TXN2.</li>
<li>Bob will create a transaction to send BCY to you. Both you and Bob will need to create invoice addresses and public keys for the BCY testnet, which we guide you through below. This corresponds to <a href='../../slides/bitcoin.html#/xchainpt2'>part 2 of the cross-chain transaction</a> – again, you are taking on the role of Alice. You will only be creating TXN3 from that slide; we are omitting TXN4.</li>
<li>You (Alice) will redeem TXN3 on the BCY network, exposing the hidden secret.</li>
<li>Bob, now knowing the hidden secret, will then redeem TXN1 on the tBTC network.</li>
</ol>
<p>Note that you are only creating one function, called <code>atomicswap_scriptPubKey()</code>. This is going to be used for both of the steps 1 (where you (Alice) send tBTC to Bob) and 2 (where Bob send BCY to you (Alice), above.</p>
<h4 id='bcy-setup'>BCY Setup</h4>
<p>To set this up, we need to create Bitcoin keypairs for the BlockCypher testnet, and use a faucet to give us some coins. The process for creating keys and funding the accounts is different for the BCY test network. The BCY blockchain uses a different <a href='../../slides/bitcoin.html#/btcaddress'>version byte</a> in the invoice address, so we cannot re-use the invoice addresses generated above for the BCY blockchain.</p>
<ol type='1'>
<li><p>Create an account at <a href='https://accounts.blockcypher.com/'>https://accounts.blockcypher.com/</a>, which will allow you to get an API token. Your token will be a hex number such as 0123456789abcdef0123456789abcdef. Save this token somewhere safe! You are welcome to record it in scripts.py (<code>blockcypher_api_token</code> is set aside for that), but that’s completely optional.</p></li>
<li><p>You will need to be able to run the <code>curl</code> program from the command-line. Try running it without any parameters to see if it is installed. If not, you will have to install it – <a href='https://duckduckgo.com/?q=how+to+install+curl'>web searches for how to install curl</a> will guide your way.</p></li>
<li><p>To create keys, you will need to run the following from the command line, putting your token in there instead of <code>API_TOKEN</code>. You should do this twice, one for you and once for Bob.</p>
<pre><code>curl -X POST 'https://api.blockcypher.com/v1/bcy/test/addrs?token=API_TOKEN'</code></pre></li>
<li><p>Save those tokens in scripts.py; yours go into <code>my_private_key_bcy_str</code> and <code>my_invoice_address_bcy_str</code>. Note that the <code>curl</code> command returns 4 values, but we only need to save two for each of the accounts (you are welcome to save the others, if you would like – just name the variables appropriately, or put them into comments). Also note that the format of the private key is different for this network – this one is hex encoded, whereas the one for the tBTC network was base-58 encoded. The provided assignment code properly handles this difference.</p></li>
<li><p>Run that <code>curl</code> command again for Bob’s keys, and save them into <code>bob_private_key_bcy_str</code> and <code>bob_invoice_address_bcy_str</code>. We only need to save the private key and the address, but you are welcome to save the other two parts as well.</p></li>
<li><p>Only Bob needs BCY funds. You can fund his account via the following command, replacing both Bob’s address for <code>BOB_BCY_ADDRESS</code> and your token for <code>API_TOKEN</code>:</p>
<pre><code>curl -d '{"address": "BOB_BCY_ADDRESS", "amount": 100000}' "https://api.blockcypher.com/v1/bcy/test/faucet?token=API_TOKEN"</code></pre></li>
<li><p>The above command will return a transaction hash; save that in <code>txid_bob_bcy_funding</code>. If you run <code>python3 bitcoinctl.py urls</code> it will display the full URL that you can use to view that funding transaction.</p></li>
<li><p>We will need to split Bob’s funds into parts, just like we did in the setup, above. Make sure that you have Bob’s private key and invoice address set in scripts.py (in <code>bob_private_key_bcy_str</code> and <code>bob_invoice_address_bcy_str</code>), as well as the transaction hash that funded the wallet (in <code>txid_bob_bcy_funding</code>). Lastly, look at the URL for that funding transaction (you can get that via <code>python3 bitcoinctl.py urls</code>) and determine the UTXO index – that needs to be set in the second command line parameter. You will also need to change <code>split_amount_to_split</code> and <code>split_amount_after_split</code> (the latter can be 0.0001 (<span class='math inline'>10<sup>−4</sup></span> for this). Then run <code>python3 bitcoinctl.py splitbcy &lt;utxo&gt;</code> – notice that the command is <code>splitbcy</code>, not <code>split</code>! The <code>&lt;utxo&gt;</code> field is the integer UTXO index, which is indexed from 0. Record the transaction hash returned from that execution run in <code>txid_bob_bcy_split</code>.</p></li>
</ol>
<p>Whew! The setup for this part is all done! Now onto the scripting part….</p>
<h4 id='cross-chain-atomic-swap'>Cross-chain atomic swap</h4>
<p>Because we are swapping between two different Bitcoin test networks, the atomic swap code is the same – both are in Bitcoin script. TXN 1 (from <a href='../../slides/bitcoin.html#/xchainpt1'>here in the slides</a>) and TXN 3 (from <a href='../../slides/bitcoin.html#/xchainpt2'>here in the slides</a>) differ only by the public keys:</p>
<ul>
<li>TXN 1: Pay <em>w</em> BTC if either (<em>x</em> for <em>h(x)</em> known and signed by B) or (signed by A & B)</li>
<li>TXN 3: Pay <em>v</em> BTC if either (<em>x</em> for <em>h(x)</em> known and signed by A) or (signed by A & B)</li>
</ul>
<p>Your script code for this will go into the <code>atomicswap_scriptPubKey()</code> function.</p>
<p><strong>NOTE:</strong> the hash that is used in this part is RIPEMD-160, <em>not</em> SHA-256. So be sure to use the <code>OP_HASH160</code> opcode to get the hash, and not the <code>OP_SHA256</code> opcode.</p>
<p>To help you with this code, we provide the two redeeming functions:</p>
<ul>
<li><code>atomcswap_scriptSig_redeem()</code> is when Alice or Bob, knowing the secret, wants to redeem the transaction. The <code>OP_TRUE</code> is for use in an <code>OP_IF</code> statement in the script you have to write.</li>
<li><code>atomcswap_scriptSig_refund()</code> is used when the transaction times out – that’s when the sender can get a refund on his/her transaction; this has to be signed by both Alice and Bob. The particular script sent to redeem this would be TXN 2 (from <a href='../../slides/bitcoin.html#/xchainpt1'>here</a>) or TXN 4 (from <a href='../../slides/bitcoin.html#/xchainpt2'>here</a>). You do not have to implement TXN 2 or TXN 4. In practice, this would be time-locked in the future – it would include a timestamp and call <code>OP_CHECKLOCKTIMEVERIFY</code>. Because the time can not be known when the assignment is written, and as it will vary for each student, that part is omitted from the script.</li>
</ul>
<p>The last thing to do before you write the <code>atomicswap_scriptPubKey()</code> function is to determine what the secret is – <strong>pick a number between 17 million and 2 billion</strong>, and save that in <code>atomic_swap_secret</code>. (It needs to be in that range to ensure it’s encoded as a 4-byte integer). Keep in mind that this secret is only known to Alice initially; Bob is only given the hash of the secret (the bitcoinctl.py file handles that part for you).</p>
<p>Once you have written the script in the <code>atomicswap_scriptPubKey()</code> function, you can perform your cross-chain transaction. This involves four steps, which are outlined below. After you perform each step, enter the transaction hash into the variable as specified, and then get the URL via <code>python3 bitcoinctl.py urls</code>. You can check that URL to ensure that it works properly. As with the previous transactions, you have to wait up to 10 minutes for at least one confirmation before you can redeem that UTXO.</p>
<ol type='1'>
<li>You (Alice) transmits <a href='../../slides/bitcoin.html#/xchainpt1'>TXN 1</a> to the tBTC network, which was created by the <code>atomicswap_scriptPubKey()</code> function. Be sure to set the correct UTXO before running this part! This is sending tBTC, so the UTXO index is from the very first split of tBTC. This is run via <code>python3 bitcoinctl.py part4a &lt;utxo&gt;</code>. The <code>&lt;utxo&gt;</code> field is the integer UTXO index, which is indexed from 0. Save the transaction hash for this in the <code>txid_atomicswap_alice_send_tbtc</code> variable.</li>
<li>Bob transmits <a href='../../slides/bitcoin.html#/xchainpt2'>TXN 3</a> to the BCY network, which was also created by the <code>atomicswap_scriptPubKey()</code> function. Be sure to set the correct UTXO before running this part! This is sending BCY, so it’s the split that was done earlier in this section. This is run via <code>python3 bitcoinctl.py part4b &lt;utxo&gt;</code>. The <code>&lt;utxo&gt;</code> field is the integer UTXO index, which is indexed from 0. Save the transaction hash for this in the <code>txid_atomicswap_bob_send_bcy</code> variable.</li>
<li>Alice (you) can redeem TXN 3 on the BCY network, which reveals the secret. Be sure to set the correct UTXO before running this part! This is run via <code>python3 bitcoinctl.py part4c &lt;utxo&gt;</code>. The <code>&lt;utxo&gt;</code> field is the integer UTXO index, which is indexed from 0. As this is from TXN 2 above, the UTXO index is probably 0. Save the transaction hash into <code>txid_atomicswap_alice_redeem_bcy</code>.</li>
<li>Bob can new redeem TXN 1 on the tBTC network, since he knows the secret which Alice just revealed via her redemption above. Be sure to set the correct UTXO before running this part! As this is from TXN 1 above, the UTXO index is probably 0. This is run via <code>python3 bitcoinctl.py part4d &lt;utxo&gt;</code>. The <code>&lt;utxo&gt;</code> field is the integer UTXO index, which is indexed from 0. Save the transaction hash into <code>txid_atomicswap_bob_redeem_tbtc</code>.</li>
</ol>
<h4 id='hints-and-notes'>Hints and notes</h4>
<ul>
<li>The <code>atomicswap_scriptPubKey()</code> function will create <a href='../../slides/bitcoin.html#/xchainpt1'>TXN 1 and TXN 3 from the slides</a>; because this has to check for two cases, it has to have an if/else structure
<ul>
<li>The first case (providing the hash) has to check the hash of the passed secret and also verify that it’s signed by B (for TXN 1) or A (for TXN 2)</li>
<li>The second case (timeout) has to check that it’s signed by A and B (multi-sig!)</li>
</ul></li>
<li>The <code>atomcswap_scriptSig_redeem()</code>, used in steps 5 and 6 on <a href='../../slides/bitcoin.html#/atomicsteps'>cross-chain atomic swap procedure slide</a>, just provides the hash and signature; this is provided to you in scripts.py. You should design your function above to work with this as the redeeming script.</li>
<li>The <code>atomcswap_scriptSig_refund()</code>, which is <a href='../../slides/bitcoin.html#/xchainpt1'>TXN 2 and TXN 2 from the slides</a>, is also provided to you. You should design your function above to work with this as the refund script.</li>
</ul>
</div><div id='tpart-5-return-tbtc' class='tabcontent'><h3 id='part-5-return-tbtc'>Part 5: Return tBTC</h3>
<p>Once you have completed this assignment, you should pay any unspent tBTC UTXOs back to the tBTC return address, which is in the the <code>tbtc_return_address</code> variable in scripts.py. You can use the script from part 1 (P2PKH) for this, as it already pays the tBTC return address – just change the UTXO value and re-run it; repeat until all the UTXO indices are spent. If you have any other inputs – perhaps you used the faucet multiple times – just change the <code>txid_split</code> variable (and the UTXO and the <code>send_amount</code>), and then call <code>python3 bitcoinctl.py part1 &lt;utxo&gt;</code>. The <code>&lt;utxo&gt;</code> field is the integer UTXO index, which is indexed from 0. But be sure to change those values back!!!</p>
<p>You do not need to save the hashes from these transactions – we are going to verify it by checking the wallet’s balance.</p>
<p>When done, there should not be any unspent UTXOs remaining! We are going to test this by seeing if the amount of tBTC left in your wallet address is zero.</p>
<p>You do not need to do this for the extra BCY in your account(s).</p>
</div><div id='tsubmission' class='tabcontent'><h3 id='submission'>Submission</h3>
<p><strong>NOTE:</strong> Make sure all the transactions are mined into the blockchain BEFORE you submit them. If you go to the URL for that particular transaction, as long as it has at least one confirmation, it is considered mined into the blockchain.</p>
<p>The only file you need to submit to Gradescope is scripts.py. There will be a few sanity checks made when you submit it. Those checks are:</p>
<ul>
<li>Ensure that the <code>userid</code> returns a non-zero length string</li>
<li>Ensure that the three values set during setup (<code>my_private_key_str</code>, <code>my_invoice_address_str</code>, and <code>txid_initial</code>)</li>
<li>Ensure that all the transaction hashes (all the variables that start with <code>txid_</code>) are of the expected length (64 characters)</li>
<li>Ensure that the split transaction was split into at least 5 different UTXO indices</li>
<li>Ensure that the four parts verify via <code>VerifyScript()</code>. This does NOT mean they work correctly! It just means that the <code>VerifyScript()</code> function did not detect errors. For one example, the <code>VerifyScript()</code> has no way of knowing the actual signature required on the blockchain. This is the same function that is run before broadcasting the transactions to the network. The full grading will check what is on the blockchain itself.</li>
<li>Ensure that the final balance of the tBTC wallet (from <code>my_invoice_address_str</code>) is zero</li>
</ul>
<p><strong>Rate Limiter:</strong> The various aspects of this program are verified by checking via blockcyper.com’s API to obtain the wallet, transaction, balance, etc. As with most websites, there is a rate limiter, and if there are too many requests in too little a time period, then it will block requests to that IP address for some period. If everybody submits the assignment around the same time, this rate limiter will kick in, and the auto-grader will reports lots of errors. We will re-run the auto-grader at a later point to ensure that it is evaluated properly, but you will not see useful results when you submit your assignment. We have set up a proxy to help this issue (it caches previously made requests). However, if there are still too many requests, it will still run into the rate limiter. Unfortunately, there is nothing more we can do about this.</p>
<p><strong>Autograder notes:</strong> As we know, a transaction is not considered valid until it is mined into the blockchain. It may be that your transaction has not yet been mined, which means it will report as not having happened. This means some of the visible tests when you submit your assignment could fail. As long as you submitted the transaction, you do not need to worry about it – we will re-run the auto-grader a day or two later to catch all these cases.</p>
</div><script>document.getElementById('defaultOpen').click();</script></body>
</html>

