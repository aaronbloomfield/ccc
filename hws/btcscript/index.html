<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Bitcoin Scripting Homework</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../../markdown.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="bitcoin-scripting-homework">Bitcoin Scripting Homework</h1>
<p><a href="../index.html">Go up to the CCC HW page</a> (<a
href="../index.md">md</a>)</p>
<h3 id="overview">Overview</h3>
<p>In this assignment you will be writing a series of Bitcoin scripts to
enact transfers. You will be using a Bitcoin test network to do so.
While regular Bitcoin uses the abbreviation BTC, we will use the
abbreviation ‘tBTC’ for the Bitcoin on our test network.</p>
<p>There are four separate Bitcoin scripts that you will need to write.
You will need to be familiar with the <a
href="../../slides/bitcoin.html#/">Bitcoin slide set</a>. You will also
need to refer to the <a href="https://en.bitcoin.it/wiki/Script">Bitcoin
Script page</a>.</p>
<h3 id="languages">Languages</h3>
<p>This assignment uses the <a
href="https://pypi.org/project/bitcoin/">Python bitcoin package</a>.
Thus, this assignment must be completed in Python. You can install the
package via <code>pip install python-bitcoinlib</code> (you may need to
use <code>pip3</code> on your system). This is NOT installed on the
VirtualBox image, so you will have to install it there as well.</p>
<h3 id="provided-files">Provided files</h3>
<ul>
<li><a href="scripts.py.html">scripts.py</a> (<a
href="scripts.py">src</a>): you will modify this file throughout this
assignment. The progression of items in that file mirrors the
progression of the assignment steps in this assignment. This is the only
file that you will submit. We would expect that you would be able to
understand everything this file by the end of the assignment</li>
<li><a href="bitcoinctl.py.html">bitcoinctl.py</a> (<a
href="bitcoinctl.py">src</a>): this is the driver file that will run the
various parts of the assignment using the values in the above
scripts.py. You are of course welcome to look at the details, but you
are not expected to understand what is in that file.</li>
</ul>
<h3 id="hints">Hints</h3>
<p>There are a few really important things to remember in this
assignment.</p>
<ol type="1">
<li>After each transaction, there is a place to store the transaction
hash. Be diligent about doing this – it’s really easy to lose track of
which of a dozen transaction hashes is which. Keeping them in the stated
variables will help with this.</li>
<li>Don’t modify the variable or function names in the scripts.py file.
Otherwise the provided functions, and our grading routines, will not
work. You can <em>add</em> functions and variables, but don’t change the
ones currently there.</li>
<li>For <em>EACH</em> transaction, you will need to set the
<code>utxo_index</code> variable – there is just one such variable in
the scripts.py file. If you get an error stating that the UTXO index is
already spent, it’s likely that you forgot to set this variable.</li>
<li>Some errors with Bitcoin scripts can be determined prior to
broadcasting it on the Bitcoin test network. This is done by the
<code>VerifyScript()</code> method, which the provided code base calls
for you before any attempted broadcast transaction. So if you see an
error such as, <code>verifyerror:
"bitcoin.core.scripteval.VerifyOpFailedError: EvalScript: OP_EQUALVERIFY
failed</code>, or similar, it means that the Bitcoin library was able to
detect that your script would not work, and did not broadcast the
transaction.</li>
<li>We provide you with a <code>create_CHECKSIG_signature()</code>
function in the scripts.py file – use it! See the comments there for
details as to how.</li>
<li>To save you the tedious task of having to learn the <a
href="https://pypi.org/project/python-bitcoinlib/">Python Bitcoin
library</a> – which you probably would never use again – much of the
library interaction has been handled for you by the provided code. But
in order for that to work, you have to proceed through this homework in
the order written.</li>
</ol>
<h3 id="testnet-setup">Testnet Setup</h3>
<p>As we do not want to have to buy, and possibly lose, real BTC, we are
going to use a test network. Because the coins we are going to be using
are not “real” Bitcoins, we will use the abbreviation ‘tBTC’ instead of
‘BTC’. When using a test network, you get coins for free via a “faucet”
– in the same way that a water faucet provides water once turned on, so
does a testnet faucet provide tBTC when requested. The particular one we
are using is <a href="https://testnet-faucet.mempool.co/">Yet Another
Bitcoin Testnet Faucet</a>.</p>
<ol type="1">
<li>You will need to generate a tBTC key pair. Run <code>./bitcoinctl.py
genkey</code>, and record both the public and private keys. While these
keys are not valid on the main Bitcoin test network – the have a
different value for the <a
href="../../slides/bitcoin.html#/btcaddress">version byte</a> in the
invoice address – you will need them throughout this assignment.
<ul>
<li>Save both the tBTC private key and the tBTC address into the
scripts.py file into <code>private_key_str</code> and
<code>invoice_address</code>, respectively</li>
</ul></li>
<li>Go to the <a href="https://testnet-faucet.mempool.co/">Testnet
Faucet</a> page and enter the tBTC address key provided in the previous
step. You will be provided a transaction ID. You can then view your
transaction at <a
href="https://live.blockcypher.com/">https://live.blockcypher.com/</a> –
put the transaction ID in the search box and be sure to select ‘Bitcoin
Testnet’ for the search.
<ul>
<li>Enter the transaction ID in scripts.py in
<code>txid_initial</code></li>
<li>Verify that you can view your account information at
https://live.blockcypher.com/btc-testnet/address/&lt;address&gt; where
&lt;address&gt; is your tBTC address – the amount that address holds
should be the amount that the faucet provided to you (likely 0.001 tBTC)
<ul>
<li>It may take up to 10 minutes or so for the transaction that funded
your wallet to be mined into the blockchain</li>
</ul></li>
<li>Verify that you can view the transaction at
https://live.blockcypher.com/btc-testnet/tx/&lt;txid&gt; where
&lt;txid&gt; is your transaction id
<ul>
<li>Note that the testnets often perform many transfers in one
transaction – so the total amount transacted may be more than 0.001
tBTC, but the amount paid to your wallet should be 0.001 tBTC</li>
</ul></li>
<li>You can also get these URLs by running <code>./bitcoinctl.py
geturls</code>. As you fill in more transaction hashes throughout this
assignment, re-running this will show an increasing list of URLs.</li>
</ul></li>
<li>That transaction gave only one UTXO, and we would like multiple
UTXOs to use – this way we can use one per question part, and we have a
few extra if something ends up not working correctly.
<ul>
<li>Look at the section of scripts.py that deals with splitting coins.
The default values there are probably correct, but check anyway – see
the comments therein for details
<ul>
<li>Check the transaction – via the URL from above – that gave you the
coins, and make sure you have the right UTXO index (which is stored in
the <code>utxo_index</code> variable in scripts.py). If you get an error
such as “witness script detected in tx without witness data”, then it
probably means your UTXO index is wrong.</li>
</ul></li>
<li>Run <code>./bitcoinctl.py split</code> to split your coins. This
uses the values in the splitting coins section of scripts.py.
<ul>
<li>If this works properly, it will present back a Python dictionary
that will take up many lines. If it doesn’t work, it will give you an
error in just a few lines.</li>
</ul></li>
<li>Look at the wallet info URL (run <code>./bitcoinctl.py
geturls</code> to get the URL), and note the transaction hash of the
split transaction – it should be the top transaction listed, and will
have 10 different outputs. The transaction hash itself is also listed in
the output from the split transaction – it’s the <code>hash</code> field
of the dictionary, and is about a half a dozen lines down. Record that
transaction id in scripts.py as <code>txid_split</code></li>
</ul></li>
</ol>
<p>Be careful not to lose the information (keys and TXIDs) that you
recorded above. To prevent abuse, the faucet only allows one transaction
per 12 hours for a given IP address or tBTC address.</p>
<h3 id="python-bitcoin-library">Python Bitcoin library</h3>
<p>The Bitcoin library for Python handles much of the heavy lifting –
conversion from one type to another, encryption, signing, verification,
etc. If you were to enter actual keys that have real BTC then you could
use this library to make real BTC transactions.</p>
<p>While the library can do many things, below is a quick summary of the
relevant aspects that you will need to know for this assignment.</p>
<ul>
<li><p>Creating Bitcoin scripts is really just putting everything into a
list. All the opcodes are named the same as on the <a
href="https://en.bitcoin.it/wiki/Script">Bitcoin Script page</a>.
Creating a script is just as simple as putting the opcodes in a Python
list: <code>[ OP_RETURN ]</code> is how you would create the <a
href="../../slides/bitcoin.html#/unspendable">provably unspendable
transaction</a> discussed in the lecture slides. Other things that go
into scripts – signatures and public key hashes – are also just included
in such a list. Assuming you got the types correct, then the library
will create the full script from such a list.</p></li>
<li><p>You will enter your private key into scripts.py as a string. To
convert it to the private key format that the library uses, you pass it
to <code>CBitcoinSecret()</code>. The object returned has a
<code>.pub</code> field, which is the public key (the type of that
public key is <code>CPubKey</code>). And that public key can be
converted into a Bitcoin address by calling
<code>P2PKHBitcoinAddress.from_pubkey(public_key)</code>. In fact, this
is almost the exact code used by the provided files to generate keys.
For that we just used random data – via <code>os.urandom(32)</code> –
instead of a pre-defined public key string. An example:</p>
<pre><code>private_key = CBitcoinSecret(private_key_str)
public_key = private_key.pub
address = P2PKHBitcoinAddress.from_pubkey(public_key)</code></pre>
<ul>
<li>If a public key is to be put into a script, as happens in most of
the scripts, then the type of that should be <code>CPubKey</code> – the
type of the <code>.pub</code> field of the object returned by
<code>CBitcoinSecret()</code></li>
</ul></li>
<li><p>Creating a signature is a bit more involved.</p>
<ul>
<li>Given the following parameters:
<ul>
<li><code>txin</code>: the transaction input from the transaction that
created the UTXO that is being redeemed</li>
<li><code>txout</code>: the transaction output from the transaction that
created the UTXO that is being redeemed</li>
<li><code>txin_scriptPubKey</code>: the pubKey script (aka output
script) of the UTXO being redeemed</li>
<li><code>private_key</code>: the secret key being used to sign this
transaction</li>
</ul></li>
<li>Then we create a signature with the following three lines of code:
<ul>
<li><code>tx = CMutableTransaction([txin], [txout])</code>:</li>
<li><code>sighash = SignatureHash(CScript(txin_scriptPubKey), tx, 0,
SIGHASH_ALL)</code>:</li>
<li><code>sig = private_key.sign(sighash) +
bytes([SIGHASH_ALL])</code>:</li>
</ul></li>
<li>This signature can be put into a list when providing a script</li>
<li>We provide a helper function, called
<code>create_CHECKSIG_signature()</code>, in scripts.py to perform these
calls.</li>
</ul></li>
</ul>
<h3 id="part-1-standard-p2pkh-transaction">Part 1: Standard P2PKH
transaction</h3>
<p>The UTXO indices that you created when you split your tBTC are paid
to a standard <a href="../../slides/bitcoin.html#/p2pkh">P2PKH
transaction</a>. Your task is to redeem them by writing the appropriate
scripts (pubkey and sigscript) to redeem the coins from one of the
UTXOs. It should be paid back to the faucet – use the
<code>faucet_adress</code> variable, defined at the top of the
<code>scripts.py</code> file, as the receiver of this transaction.</p>
<p>To complete this transaction, you need to complete four things:</p>
<ul>
<li>The <code>P2PKH_scriptSig(...)</code> function provides the
sigscript needed to redeem the UTXO being spent. The UTXO that is being
redeemed – one of the split UTXO indices from above – requires a P2PKH
sigScript to redeem one of the indices.</li>
<li>The <code>P2PKH_scriptPubKey(address)</code> function defines the
pubKey script (aka output script). This was discussed in lecture in the
<a href="../../slides/bitcoin.html#/p2pkh">P2PKH transaction</a> slides.
This script creates a new UTXO, payable to the faucet address, that is
also a P2PKH script. The parameter is of type
<code>P2PKHBitcoinAddress</code>, which is what the
<code>P2PKHBitcoinAddress.from_pubkey(public_key)</code> call (shown
above) returns; a variable this type can be put directly into a
script.</li>
<li>Set the transaction to be spent via the <code>txid_utxo</code>
variable; the default is the transaction ID that was split (i.e., the
<code>txid_split</code>).</li>
<li>Set the output index to spend via <code>utxo_index</code>; it is
currently set to 0. Recall that output indices start from 0, not 1. Be
sure to pick an unspent index! If you have to run this multiple times,
you may have to change this value to an unspent index.</li>
</ul>
<p>When you have finished the script, you can run it via
<code>./bitcoinctl.py part1</code>; it will report an error if you get
it wrong. If it works, you will see a JSON dictionary printed to the
screen. Record the transaction ID of that transaction in
<code>txid_p2pkh</code>. The TXID is the ‘hash’ field in the dictionary
that is printed to the screen when run. You can then run
<code>./bitcoinctl.py geturls</code> to get the URL for the transaction
that you just executed. It may take up to 10 minutes for it to be mined
into the blockchain.</p>
<p>You should notice your wallet balance has decreased.</p>
<h3 id="part-2-puzzle-script">Part 2: Puzzle script</h3>
<p>For this tBTC transaction, you are going to create an algebraic
puzzle script – one that anybody can redeem as long as they complete the
numerical puzzle.</p>
<p>You will need to pick two 4-digit base-10 numbers. You can take your
UVA SIS ID and split the digits in half. You <strong>MUST</strong> make
sure that the numbers have the same parity – both numbers are odd or
both numbers are even. We’ll call those numbers <span
class="math inline"><em>p</em></span> and <span
class="math inline"><em>q</em></span>. You will need to store those
values into <code>puzzle_txn_p</code> and <code>puzzle_txn_q</code> in
scripts.py.</p>
<p>The puzzle transaction will deal with the solution to the following
two linear equations:</p>
<p><span
class="math display">2<em>x</em> + <em>y</em> = <em>p</em></span> <span
class="math display"><em>x</em> + 2<em>y</em> = <em>q</em></span></p>
<p>You can use an online linear question solver, such as <a
href="https://onsolver.com/system-equations.php">this one</a>, to find
the solution. And make sure that the solutions are integer values! Once
you know those values, put them into <code>puzzle_txn_x</code> and
<code>puzzle_txn_y</code> in scripts.py</p>
<p>For this part, you will create a transaction to redeem one of the
split UTXO indices that were created, above. The pubKey (output) script
of that newly created transaction will be specified in the
<code>puzzle_scriptPubKey()</code> function in scripts.py. Note that
because this output script does not depend on the receiver’s public key,
that is not provided as a parameter to the function. Also note that the
<code>OP_MUL</code> opcode has been disabled on the Bitcoin networks, so
you can’t use that. This pubKey script should verify that the two values
specified by the redeemer fulfill those two equations. Once this is
created, run <code>./bitcoinctl.py part2a</code> – remember to choose an
unspent UTXO index first via the <code>utxo_index</code> variable. As
above, record the transaction hash into the
<code>txid_puzzle_txn1</code> variable.</p>
<p>You will also need to create the sigScript that redeems this
transaction. This should <strong>ONLY</strong> contain the two values
<span class="math inline"><em>x</em></span> and <span
class="math inline"><em>y</em></span> – their order is up to you, as
long as it works with the script you created above. That script goes
into <code>puzzle_scriptSig()</code>. This also does not depend on any
signatures, which is why there are no parameters to that function.
Ensure that the previous transaction has been mined into the blockchain,
which may take up to 10 minutes – if you have entered the previous
transaction’s URL into the <code>txid_puzzle_txn1</code> variable, you
can get the URL of that transaction via <code>./bitcoinctl.py
geturls</code>. When ready, you can send the redeeming trasnaction to
the tBTC network via <code>./bitcoinctl.py part2b</code> (remember to
choose an unspent UTXO index first). Record the transaction hash into
<code>txid_puzzle_txn2</code>.</p>
<p>You will notice that the amount in each UTXO index from the split
transaction is 0.0001 tBTC. For the first half of this puzzle
transaction, the amount transacted is slightly less (90% of that, or
0.00009). The difference – 0.00001 tBTC – is the transaction fee. Even
though this is a test network, and no actual money is involved, your
transaction will not be mined into the blockchain unless you have a
transaction fee. For the second half of this, we need to lower the
amount even further, so the amount transacted is 90% of 0.00009, or
0.000081; this lowering is done automatically by the code base provided.
The difference here – 0.000009 tBTC – is the transaction fee. While the
test network requires there be <em>some</em> transaction fees, it
doesn’t seem to care much about how much those fees are, which is
different than with the real BTC network. This automatic lowering of the
transaction amount will recur elsewhere in this assignment.</p>
<h3 id="part-3-multi-signature-transaction">Part 3: Multi-signature
transaction</h3>
<p>You are going to create a multi-signature transaction, which must use
the <a href="../../slides/bitcoin.html#/checkmultisig">OP_CHECKMULTISIG
opcode</a>.</p>
<p>To set this up, you will need to create three more key pairs using
<code>./bitcoinctl.py keygen</code>. Save these in the variables for
Alice, Bob, and Charlie in part 3 of the <code>scripts.py</code> file.
These addresses don’t need any tBTC – we just need the key pairs to
perform digital signatures.</p>
<p>The scenario is this: you are taking on the role of a bank. Three
siblings (Alice, Bob, and Charlie) have deposited money into an account,
and it can be redeemed if two of the three – and also the bank! – agree
to it. Formally, the transaction must be signed by the bank (i.e., you –
via the keys in the <code>my_private_key_str</code> variable) and any
two of the three siblings (via their private keys).</p>
<p>This will actually require two transactions. The first redeems one of
the split UTXOs and creates a multi-signature pubKey (output) script.
The second redeems that multi-signature script and pays it to the faucet
address.</p>
<ol type="1">
<li>Transaction 1: tBTC funds are taken from one of your split UTXO
indices and put into a new UTXO whose output script requires the
multiple signatures
<ul>
<li>The sigScript for this will be taken from your part (1), above –
specifically from <code>P2PKH_scriptSig()</code>. So you don’t have to
write this again. If your part (1) worked, then this should work as
well.</li>
<li>The pubKey script for this you will be writing in the
<code>multisig_scriptPubKey()</code> function.</li>
<li>Once successfully executed, record the transaction hash in the
<code>txid_multisig_txn1</code> variable.</li>
</ul></li>
<li>Transaction 2: tBTC the funds from the multisig UTXO are redeemed
and paid back to the faucet address.
<ul>
<li>The sigScript for this you will be writing in the
<code>multisig_scriptSig()</code> function.</li>
<li>The pubKey script for this will be taken from your part (1) above –
specifically from <code>P2PKH_scriptPubKey()</code>. So you don’t have
to write this again. If you part (1) worked, then this should work as
well.</li>
<li>Once successfully executed, record the transaction hash in the
<code>txid_multisig_txn2</code> variable.</li>
</ul></li>
</ol>
<p>You only have to write the pubKey (output) script of the first
transaction, and the sigScript (input) script of the second transaction.
The other two parts (sigScript of the first and pubKey script of the
second) are taken from your code in part (1) – so if that is not
working, then this will not work either.</p>
<p>The first step is to create the transaction that sets up the
multi-signature requirement in the pubKey script. This must use the
<code>OP_CHECKMULTISIG</code> opcode! See the description of <a
href="../../slides/bitcoin.html#/checkmultisig">OP_CHECKMULTISIG
opcode</a> in the lecture slides. Fill in the
<code>multisig_scriptPubKey()</code> function. Recall that the sigScript
will be used from your code for part (1). We recommend that you write
this and the next script – the redeeming script – together, and trace
its stack execution (on paper or similar). When you are ready to run it,
be sure to set the <code>utxo_index</code> variable is set to the UTXO
index you want to spend, and run <code>./bitcoinctl.py part3a</code>.
Once successful, record the transaction ID in the
<code>txid_multisig_txn1</code> variable in scripts.py.</p>
<p>The second step is to create a transaction that will redeem it. You
will have to wait until the previous transaction receives at least one
confirmation before you can execute this part, which can take up to 10
minutes. This part requires that the <code>txid_multisig_txn1</code>
variable, from the first step above, is set properly, as that is the
UTXO that is going to redeem. You will fill in your sigScript into
<code>multisig_scriptSig()</code>. Recall that the pubKey script for
this transaction will be used from your answer for part (1). When you
are ready to run it, be sure to set the <code>utxo_index</code> variable
at the top to the UTXO index you want to spend; this is likely 0, since
there is only one output from the UTXO from the transaction just above.
You run it via <code>./bitcoinctl.py part3b</code>. Once successful,
record the transaction hash in the <code>txid_multisig_txn2</code>
variable in scripts.py.</p>
<h3 id="part-4-cross-chain-transactions">Part 4: Cross-chain
transactions</h3>
<p>In this part you will create the scripts for a <a
href="../../slides/bitcoin.html#/xchain">cross-chain transaction</a>.
Typically this would be for two different cryptocurrencies. However,
since we only have learned Bitcoin Script, we will use that for both
parts. There are many cryptocurrencies that are forks of Bitcoin, and
thus have the same scripting language, so the same program could work
for them. Or a completely different cryptocurrency, with a different
scripting language, would have an analogous script. However, to test
this we will be using two <em>different</em> Bitcoin testing
blockchains.</p>
<p>In addition to the lecture slides, you may want to refer to the <a
href="https://en.bitcoin.it/wiki/Atomic_swap">Atomic swap article</a> in
the <a href="https://en.bitcoin.it/wiki/Main_Page">Bitcoin wiki</a>.</p>
<p>So far we have been using tBTC on the Bitcoin Testnet. For this part
we will also be using the BlockCypher Testnet – this is also a fake
Bitcoin network for testing, and it operates just like the Bitcoin
Testnet we’ve been using. Bitcoin on this other testnet will be
abbreviated as BCY (for BlockCYpher testnet). Note that we have been
using <a href="https://live.blockcypher.com/">blockcypher.com</a> to
view all of our transactions, since that site can view both of these
Bitcoin test networks.</p>
<p>In this part, you and Bob will be exchanging coins through a
cross-chain transaction. You will need to be familiar with the <a
href="../../slides/bitcoin.html#/xchain">cross-chain transaction section
of the Bitcoin slide set</a>. You are going to take on the role of Alice
in the lecture slides.</p>
<p>As an overview, this is what is going to happen.</p>
<ol type="1">
<li>You (Alice) are going to create a transaction to send tBTC to Bob.
You will send it from the account you have been using so far (saved in
<code>my_private_key_str</code> and <code>my_invoice_address_str</code>
in scripts.py). Bob will receive it in the account that was created for
him in the previous part (<code>bob_private_key_str</code> and
<code>bob_invoice_address_str</code> in scripts.py). This corresponds to
<a href="../../slides/bitcoin.html#/xchainpt1">part 1 of the cross-chain
transaction</a> – again, you are taking on the role of Alice. You will
only be creating TXN1 from that slide; we are omitting TXN2.</li>
<li>Bob will create a transaction to send BCY to you. Both you and Bob
will need to create invoice addresses and public keys for the BCY
testnet, which we guide you through below. This corresponds to <a
href="../../slides/bitcoin.html#/xchainpt2">part 2 of the cross-chain
transaction</a> – again, you are taking on the role of Alice. You will
only be creating TXN3 from that slide; we are omitting TXN4.</li>
<li>You (Alice) will redeem TXN3 on the BCY network, exposing the hidden
secret.</li>
<li>Bob, now knowing the hidden secret, will then redeem TXN1 on the
tBTC network.</li>
</ol>
<h4 id="setup">Setup</h4>
<p>To set this up, we need to create Bitcoin keypairs for the
BlockCypher testnet, and use a faucet to give us some coins. The process
for creating keys and funding the accounts is different for the BCY test
network.</p>
<ol type="1">
<li><p>Create an account at <a
href="https://accounts.blockcypher.com/">https://accounts.blockcypher.com/</a>,
which will allow you to get an API token. Your token will be a hex
number such as 0123456789abcdef0123456789abcdef. Save this token
somewhere safe! You are welcome to record it in scripts.py
(<code>blockcypher_api_token</code> is set aside for that), but that’s
completely optional.</p></li>
<li><p>To create keys, you will need to run the following from the
command line, putting your token in there instead of
<code>API_TOKEN</code>. You should do this twice, one for you and once
for Bob.</p>
<pre><code>curl -X POST &#39;https://api.blockcypher.com/v1/bcy/test/addrs?token=API_TOKEN&#39;</code></pre></li>
<li><p>Save those tokens in scripts.py; yours go into
<code>my_private_key_bcy_str</code> and
<code>my_invoice_address_bcy_str</code>, and Bob’s go into
<code>bob_private_key_bcy_str</code> and
<code>bob_invoice_address_bcy_str</code>. Note that the
<code>curl</code> command returns 4 values, but we only need to save two
for each of the accounts. Also note that the format of the private key
is different for this network – this one is hex encoded, whereas the one
for the tBTC network was base-58 encoded. The provided code base
properly handles this difference.</p></li>
<li><p>Only Bob needs BCY funds. You can fund his account via the
following command, replacing both Bob’s address for
<code>BOB_BCY_ADDRESS</code> and your token for
<code>API_TOKEN</code>:</p>
<pre><code>curl -d &#39;{&quot;address&quot;: &quot;BOB_BCY_ADDRESS&quot;, &quot;amount&quot;: 100000}&#39; https://api.blockcypher.com/v1/bcy/test/faucet?token=API_TOKEN</code></pre></li>
<li><p>The above command will return a transaction hash; save that in
<code>txid_bob_bcy_funding</code>. If you run <code>./bitcoinctl.py
geturls</code> it will display the full URL that you can use to view
that funding transaction.</p></li>
<li><p>We will need to split Bob’s funds into parts, just like we did in
the setup, above. Make sure that you have Bob’s private key and invoice
address set in scripts.py (in <code>bob_private_key_bcy_str</code> and
<code>bob_invoice_address_bcy_str</code>), as well as the transaction
hash that funded the wallet (in <code>txid_bob_bcy_funding</code>).
Lastly, look at the URL for that funding transaction (you can get that
via <code>./bitcoinctl.py geturls</code>) and determine the UTXO index –
that needs to be set in <code>utxo_index</code>. The run
<code>./bitcoinctl.py splitbcy</code> – notice that the command is
<code>splitbcy</code>, not <code>split</code>! Record the transaction
hash returned from that execution run in
<code>txid_bob_bcy_split</code>.</p></li>
</ol>
<p>Whew! The setup for this part is all done! Now onto the scripting
part….</p>
<h4 id="cross-chain-atomic-swap">Cross-chain atomic swap</h4>
<p>Because we are swapping between two different Bitcoin test networks,
the atomic swap code is really the same – both are in Bitcoin script.
TXN 1 (from <a href="../../slides/bitcoin.html#/xchainpt1">here in the
slides</a>) and TXN 3 (from <a
href="../../slides/bitcoin.html#/xchainpt2">here in the slides</a>)
differ only by the public keys:</p>
<ul>
<li>TXN 1: Pay <em>w</em> BTC to &lt;B’s public key&gt; if (<em>x</em>
for <em>h(x)</em> known and signed by B) or (signed by A &amp; B)</li>
<li>TXN 3: Pay <em>v</em> BTC to &lt;A’s public key&gt; if (<em>x</em>
for <em>h(x)</em> known and signed by A) or (signed by A &amp; B)</li>
</ul>
<p>Your script code for this will go into the
<code>atomicswap_scriptPubKey()</code> function.</p>
<p>To help you with this code, we provide the two redeeming
functions:</p>
<ul>
<li><code>atomcswap_scriptSig_redeem()</code> is when Alice or Bob,
knowing the secret, wants to redeem the transaction. The
<code>OP_TRUE</code> is for use in an <code>OP_IF</code> statement in
the script you have to write.</li>
<li><code>atomcswap_scriptSig_refund()</code> is used when the
transaction times out – that’s when the sender can get a refund on
his/her transaction; this has to be signed by both Alice and Bob. The
particular script sent to redeem this would be TXN 2 (from <a
href="../../slides/bitcoin.html#/xchainpt1">here</a>) or TXN 4 (from <a
href="../../slides/bitcoin.html#/xchainpt2">here</a>). You do not have
to implement TXN 2 or TXN 4.</li>
</ul>
<p>The last thing to do before you write the
<code>atomicswap_scriptPubKey()</code> function is to determine what the
secret is – pick a number between 1 million and 2 billion, and save that
in <code>atomic_swap_secret</code>. (It needs to be in that range to
ensure it’s encoded as a 4-byte integer). Keep in mind that this secret
is only known to Alice initially; Bob is only given the hash of the
secret (the bitcoinctl.py file handles that part for you).</p>
<p>Once you have written the script in the
<code>atomicswap_scriptPubKey()</code> function, you can perform your
cross-chain transaction. This involves four steps, which are outlined
below. After you perform each step, enter the transaction hash into the
variable as specified, and then get the URL via <code>./bitcoinctl.py
geturls</code>. You can check that URL to ensure that it works properly.
As with the previous transactions, you have to wait up to 10 minutes for
at least one confirmation before you can redeem that UTXO.</p>
<ol type="1">
<li>You (Alice) transmits <a
href="../../slides/bitcoin.html#/xchainpt1">TXN 1</a> to the tBTC
network, which was created by the <code>atomicswap_scriptPubKey()</code>
function. Be sure to set the <code>utxo_index</code> variable in
scripts.py to a valid index before running this part! This is run via
<code>./bitcoinctl.py part4a</code>. Save the transaction hash for this
in the <code>txid_atomicswap_alice_send_tbtc</code> variable.</li>
<li>Bob transmits <a href="../../slides/bitcoin.html#/xchainpt2">TXN
3</a> to the BCY network, which was also created by the
<code>atomicswap_scriptPubKey()</code> function. Be sure to set the
<code>utxo_index</code> variable in scripts.py to a valid index before
running this part! This is run via <code>./bitcoinctl.py part4b</code>.
Save the transaction hash for this in the
<code>txid_atomicswap_bob_send_bcy</code> variable.</li>
<li>Alice (you) can redeem TXN 3 on the BCY network, which reveals the
secret. Be sure to set the <code>utxo_index</code> variable in
scripts.py to a valid index before running this part! This is run via
<code>./bitcoinctl.py part4c</code>. Save the transaction hash into
<code>txid_atomicswap_alice_redeem_bcy</code>.</li>
<li>Bob can new redeem TXN 1 on the tBTC network, since he knows the
secret which Alice just revealed via her redemption above. Be sure to
set the <code>utxo_index</code> variable in scripts.py to a valid index
before running this part! This is run via <code>./bitcoinctl.py
part4d</code>. Save the transaction hash into
<code>txid_atomicswap_bob_redeem_tbtc</code>.</li>
</ol>
<h3 id="part-5-pay-back-the-tbtc-faucet-address">Part 5: Pay back the
tBTC faucet address</h3>
<p>Once you have completed this assignment, you should pay any unspent
tBTC UTXOs back to the faucet address. You can use the script from part
1 for this – just change the <code>utxo_index</code> value and re-run it
until all the UTXO indices are spent. If you have any other inputs –
perhaps you used the faucet multiple times – just change the
<code>txid_split</code> variable (and the <code>utxo_index</code> and
the <code>send_amount</code>), and then call <code>./bitcoinctl.py
part1</code>. But be sure to change those values back!!!</p>
<p>When done, there should not be any unspent UTXOs remaining! We are
going to test this by seeing if the amount of tBTC left in your wallet
address is zero.</p>
<p>You do not need to do this for the extra BCY in your account(s).</p>
<h3 id="submission">Submission</h3>
<p>The only file you need to submit is scripts.py. There will be a few
sanity checks made when you submit it. Those checks are:</p>
<ul>
<li>Ensure that the <code>userid</code> returns a non-zero length
string</li>
<li>Ensure that the three values set during setup
(<code>my_private_key_str</code>, <code>my_invoice_address_str</code>,
and <code>txid_initial</code>)</li>
<li>Ensure that all the transaction hashes (all the variables that start
with <code>txid_</code>) are of the expected length (64 characters)</li>
<li>Ensure that the split transaction was split into at least 5
different UTXO indices</li>
<li>Ensure that the four parts verify via <code>VerifyScript()</code>.
This does NOT mean they work correctly! It just means that the
<code>VerifyScript()</code> function did not detect errors. For one
example, the <code>VerifyScript()</code> has no way of knowing the
actual signature required on the blockchain. This is the same function
that is run before broadcasting the transactions to the network. The
full grading will check what is on the blockchain itself.</li>
<li>Ensure that the final balance of the tBTC wallet (from
<code>my_invoice_address_str</code>) is zero</li>
</ul>
</body>
</html>
