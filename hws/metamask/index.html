<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Metamask Assignment</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../../markdown.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="metamask-assignment">Metamask Assignment</h1>
<p><a href="../index.html">Go up to the CCC HW page</a> (<a
href="../index.md">md</a>)</p>
<h3 id="overview">Overview</h3>
<p>You are going to create a web interface for the Auctioneer contract
you created in the <a href="../auction/index.html">dApp Auction</a> (<a
href="../auction/index.md">md</a>) assignment. This web interface will
allow for the creation of NFTs and the ability to start and stop
auctions, as well as bidding on running auctions.</p>
<h3 id="changelog">Changelog</h3>
<p>Any changes to this page will be put here for easy reference. Typo
fixes and minor clarifications are not listed here. So far there aren’t
any significant changes to report.</p>
<h3 id="pre-requisites">Pre-requisites</h3>
<p>Writing this homework will require completion of the following
assignments:</p>
<ul>
<li><a href="../ethprivate/index.html">Private Ethereum Blockchain</a>
(<a href="../ethprivate/index">md</a>)</li>
<li><a href="../daoweb3/index.html">DAO &amp; web3</a> (<a
href="../daoweb3/index.md">md</a>)<a
href="../tokens/index.html">Ethereum Tokens</a> (<a
href="../tokens/index.md">md</a>)</li>
<li><a href="../daoweb3/index.html">DAO &amp; web3</a> (<a
href="../daoweb3/index.md">md</a>)</li>
<li><a href="../arbitrage/index.html">Arbitrage trading</a> (<a
href="../arbitrage/index.md">md</a>)</li>
<li><a href="../auction/index.html">dApp Auction</a> (<a
href="../auction/index.md">md</a>)</li>
</ul>
<h3 id="setup-auctioneer">Setup: Auctioneer</h3>
<p>We are going to use your Auctioneer contract, from the <a
href="../auction/index.html">dApp Auction</a> (<a
href="../auction/index.md">md</a>) assignment. You will also need your
NFTmanager contract, from the <a href="../tokens/index.html">Ethereum
Tokens</a> (<a href="../tokens/index.md">md</a>) assignment, as well. If
you did not get yours working, then contact the course staff, and we can
deploy them for you to use.</p>
<p>Before you deploy yours, however, we need to make a few changes to
our Auctioneer.sol contract. We recommend saving this updated version in
a separate file, such as <code>Auctioneer_v2.sol</code>.</p>
<p><strong>Change 1:</strong> The first change is due to an imprecise
specification in the <a href="../auction/index.html">dApp Auction</a>
(<a href="../auction/index.md">md</a>) assignment. The change is this:
<em>all</em> monetary amounts should be in <em>wei</em>. This
includes:</p>
<ul>
<li>The <code>reserve</code> and <code>highestBid</code> fields of the
<code>Auction</code> struct</li>
<li>The return value of <code>fees()</code> (which is probably just a
getter function from a public variable)</li>
<li>The <code>_reserve</code> parameter to
<code>createAuction()</code></li>
</ul>
<p>To make this change, check for each time you modify those fields of
the <code>Auction</code> struct, for how you store it in
<code>fees</code>, and the code in the <code>createAuction()</code>
function.</p>
<p><strong>Change 2:</strong> To make everybody’s lives easier, each
Auctioneer contract will deploy it’s <em>own</em> NFTmanager. We saw how
this was done in the testing section of the <a
href="../daoweb3/index.html">DAO &amp; web3</a> (<a
href="../daoweb3/index.md">md</a>) assignment. This way we won’t have to
pass in the address of the NFT manager every time we want to deal with
an NFT which will make our lives easier. To make this change, add the
following as a public variable to your contract:</p>
<pre><code>address public override nftmanager;</code></pre>
<p>This will create an associated getter function as well. This
<code>override</code> is because it will override the updated
AuctionManager_v2.sol contract, which is provided below.</p>
<p>Also add the following line in your constructor; if you don’t have a
constructor, add one with just the following line:</p>
<pre><code>nftmanager = address(new NFTmanager());</code></pre>
<p>The rest of your Auctioneer code should be unaffected by this change.
The only time the NFTmanager address comes up is when it is read in
during the <code>onERC721Received()</code> function, and when it’s
stored in the <code>Auction</code> struct. But that code should work
just fine with this change – we are just going to be saving that same
NFTmanager in all the <code>Auction</code> structs. This is a bit of a
waste of gas, but it simplifies our modifications for this assignment.
And gas is free for us in this course.</p>
<p><strong>Change 3:</strong> We are going to add a method to the
Auctioneer to mint an NFT, which it does by calling the NFTmanager’s
<code>mintWithURI()</code> method. Add the following code:</p>
<pre><code>address public override nftmanager;

mapping (address =&gt; uint) public override lastMintedNFT;

function mintNFT (string memory uri) public override returns (uint) {
    uint ret = NFTmanager(nftmanager).mintWithURI(msg.sender,uri);
    lastMintedNFT[msg.sender] = ret;
    return ret;
}

function tokenURI(uint tokenID) public view override returns (string memory) {
    return NFTmanager(nftmanager).tokenURI(tokenID);
}</code></pre>
<p>The <code>mintNFT()</code> function allows us to create a new NFT
without having to interact with the NFTmanager contract, which will
simplify the work we have to do below. This assumes that the NFT is
being minted for the sender, which is a reasonable assumption in this
case. As mentioned in the <a href="../arbitrage/index.html">Arbitrage
trading</a> (<a href="../arbitrage/index.md">md</a>) assignment, it’s
challenging to obtain the return value of a transaction, so we save the
just minted NFT ID in the <code>lastMintedNFT</code> mapping, which we
can then read via a regular call. (This means if you mint two NFTs in
succession, without getting the ID of the first before you mint the
second, then you won’t know the ID of the first; we are going to
carefully ignore this case for simplicity). The <code>tokenURI()</code>
just passes the call to the NFTmanager – having this function here
allows us to not have to interact with two smart contracts, as the
Auctioneer will forward that request on for us. This uses up more gas,
but will make it much simpler for us in this assignment.</p>
<p><strong>Change 4:</strong> As a result of these changes, your
Auctioneer_v2.sol contract will now support the updated <a
href="AuctionManager_v2.sol.html">AuctionManager_v2.sol</a> (<a
href="AuctionManager_v2.sol">src</a>) interface. Other than changing a
few comments (changing all ‘gwei’ instances to ‘wei’), the changes for
this assignment are the first few lines of the contract. In particular,
your contract line should be <code>contract Auctioneer_v2 is
AuctionManager_v2 {</code>. In addition to implementing the above
functions, this means you have to change your <code>import
"AuctionManager.sol";</code> line to <code>import
"AuctionManager_v2.sol";</code>. Your <code>supportsInterface()</code>
function will have to support the new interface (you don’t have to
indicate support of the old AuctionManager.sol interface, just the new
AuctionManager_v2.sol interface). The ABI for that interface can be
found in the <a href="AuctionManager_v2.abi">AuctionManager_v2.abi</a>
file. Although you likely won’t need it, you can get the link for the
NFTmanager ABI as well; it’s actually the ABI for the IERC721full
interfaceP: <a href="IERC721full.abi">IERC721.abi</a>.</p>
<p><strong>Finalizing:</strong> Once that modification is done, you
should deploy your Auctioneer_v2.sol contract to the blockchain. Save
the contract address, as it will be needed below.</p>
<h3 id="setup-metamask">Setup: MetaMask</h3>
<p><img src="metamask-pop-up.webp" style="float:right;border:1px solid black"></p>
<p>This assignment uses the <a href="https://metamask.io/">MetaMask</a>
extension to Google Chrome. Unfortunately, it does not run in any other
browser; meaning you can’t use Firefox, Safari, Edge, or Internet
Explorer. You have to use Chrome for this assignment.</p>
<p>Here are the MetaMask setup steps:</p>
<ol type="1">
<li>If you haven’t already, install <a
href="https://www.google.com/chrome">Google Chrome</a></li>
<li>Install the <a href="https://metamask.io/">MetaMask</a>
extension</li>
<li>Obtain your decrypted private key for the account that you want to
use. This was done in Part 4 of the <a
href="../ethprivate/index.html">Private Ethereum Blockchain</a> (<a
href="../ethprivate/index">md</a>) assignment, and you also used that in
the <a href="../arbitrage/index.html">Arbitrage trading</a> (<a
href="../arbitrage/index.md">md</a>) assignment. It will be a hex value
of the form
<code>0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef</code></li>
<li>Start your geth node. Among any other flags that you are using, you
need to supply the <code>--http</code> flag when you start geth</li>
<li>Configure MetaMask. To do so, click on the MetaMask icon
(<img src="metamask-fox.svg" style="max-height:20px;vertical-align:middle">)
next to the address box. You will see something similar to the image to
the right. Sometimes there is a noticeable delay when clicking that icon
before the pop-up windows appears.
<ul>
<li>First we have to configure the connection to the blockchain. At the
very top of the MetaMask pop-up window is a networks drop-down – in the
image to the right it says “Localhost:8545”. In the list that appears,
if you DO see “localhost:8545”, then select it
<ul>
<li>If you do NOT see “localhost:8545”, you will have to add it. Keep
“localhost:8545” as the network name, the RPC URL is
<code>http://localhost:8545</code>, the chain ID is provided on the
Collab landing page. The click “add network”.</li>
<li>Does it not connect? Make sure you are running your geth node with
the <code>--http</code> flag.</li>
</ul></li>
<li>Next we need to configure our account.
<ul>
<li>Click on the circular icon in the upper-right of the MetaMask window
– in the image to the right it looks like:
<img src="metamask-account-icon.webp" style="max-height:20px;vertical-align:middle">,
but will likely look different in yours</li>
<li>Click on “import account” (NOT create account!)</li>
<li>Paste in your decrypted private key and click on ‘import’</li>
<li>You should now see your balance in the account pop-up window</li>
<li>You will likely want to rename the account – MetaMask just calls
them “account 1”, “account 2”, etc., and makes it hard to delete
“account 1”. To rename your account, in the MetaMask window in the image
to the right, click on the vertical ellipsis (⋮) to the right of the
account name, then click on “account details”, then click on the
pencil/edit icon to the right of the account name.</li>
</ul></li>
</ul></li>
</ol>
<p>At this point, the MetaMask extension should be connected to your
account on the private Ethereum blockchain. Note that if you restart
Chrome, you may have to enter your password. Also, it will say “Not
connected” to the left of the account name – that’s fine for now, since
we have not yet created a web page for it to connect to.
<br clear="all"></p>
<!---

### Background: Function Call Encoding

We are going to be reading from the blockchain using the web3.js library that you used in the [DAO & web3](../daoweb3/index.html) ([md](../daoweb3/index.md)) assignment.  In fact, you are encouraged to start with the code of the NFT auction manager web site that was provided to you in the [dApp Auction](../auction/index.html) ([md](../auction/index.md)) assignment.  The intent of this current assignment is to add features to that web page.

We are going to be using a *different* mechanism to write to the blockchain as we do to read from it.  Reading from the blockchain is still using the web3.js code, and that should mostly be all done for you in the web site that was provided to you in the [dApp Auction](../auction/index.html) ([md](../auction/index.md)) assignment.

Why a separate system?  A few reasons.  One is that it lowers the amount of work to make it reasonable in a single assignment.  Another is that calling the read-only functions with web3.js is much easier.  And using this combination is still safe and secure, so it could be used in production.

The catch: in order to be able to call a smart contract that is a *transaction*, as opposed to a *call*, we have to encode the function call in hex ourselves.  To this end, you will need to read through the [function call encoding tutorial](../../docs/function_call_encoding.html) ([md](../../docs/function_call_encoding.md)).  You need to understand all of what is in there, as you will have to write Javascript code to do that encoding!  We aren't expecting you to have it memorized, but instead to use that document as a reference.

-->
<h3 id="background-html-forms-and-javascript">Background: HTML forms and
Javascript</h3>
<p>The intent is for you to start with the web site that was provided to
you in the <a href="../auction/index.html">dApp Auction</a> (<a
href="../auction/index.md">md</a>) assignment, and add some features.
The URL of that web site is on the Collab landing page – you can just
save that as a new HTML file, which you will want to name
<code>auctions.html</code>. You are going to create a few web forms,
each of which will call a different Javascript function. Those forms –
and paired functions – will perform the various actions that we need to
perform on the Auctioneer: minting new NFTs, starting a new auction,
closing an auction, and bidding on an auction.</p>
<h5 id="ensure-metamask-is-installed-and-enabled">Ensure MetaMask is
installed and enabled</h5>
<p>We want to ensure that any viewer of this web page has MetaMask
properly installed. The following code will do that:</p>
<pre><code>&lt;script&gt;
  if ( window.ethereum === undefined )
    window.alert(&quot;Please install MetaMask; this page will not work properly without that extension installed&quot;);
&lt;/script&gt;</code></pre>
<p>This is useful as it will give a warning to those using other
browsers, or those on Chrome without the MetaMask extension installed,
that the site won’t work properly. In a fully developed web site, we
would display the rest of the page differently if it is run without
MetaMask. For this assignment, you should just display that warning.
It’s fine for this assignment if the rest of your page does not display
correctly without MetaMask.</p>
<h5 id="connecting-to-metamask">Connecting to MetaMask</h5>
<p>The first thing a user has to do is enable the MetaMask extension to
use the site; this is usually phrased as “connecting to MetaMask”. To do
this, we add the following code to our HTML file (adapted from <a
href="https://docs.metamask.io/guide/getting-started.html#connecting-to-metamask">here</a>).
You can put this right after the <code>&lt;body&gt;</code> opening
tag.</p>
<pre><code>&lt;button class=&quot;enableEthereumButton&quot;&gt;Enable Ethereum&lt;/button&gt;
&lt;script&gt;
  const ethereumButton = document.querySelector(&#39;.enableEthereumButton&#39;);
  ethereumButton.addEventListener(&#39;click&#39;, () =&gt; {
    // will start the metamask extension
    ethereum.request({ method: &#39;eth_requestAccounts&#39; });
  });
&lt;/script&gt;</code></pre>
<p>This connection will persist through a page reload, and – on some
operating systems at least – will persist thorough a browser
restart.</p>
<p>The expectation is that any user will click on that button to connect
to MetaMask. You do not need to handle the case when a user tries to use
the rest of the page without first connecting via this button.</p>
<h5 id="web3.js-library">Web3.js library</h5>
<p>We could interact with MetaMask directly, but using web3.js, which we
are familiar with, is going to make life much easier – it will do all
the encoding of parameters into calls, etc.</p>
<p>Previously, we defined the <code>web3</code> variable as such
(<code>URL</code> is on the Collab landing page):</p>
<pre><code>let web3 = new Web3(&#39;URL&#39;);</code></pre>
<p>We are now going to <em>add</em> a line:</p>
<pre><code>let web3 = new Web3(&#39;URL&#39;);
let web3mm = new Web3(window.ethereum);</code></pre>
<p>You will notice that we are creating <em>TWO</em> connections to the
blockchain. The first connection is through the normal URL as was done
in the <a href="../daoweb3/index.html">DAO &amp; web3</a> (<a
href="../daoweb3/index.md">md</a>) assignment and as is done in the
auctions.php page that you are basing your code off of; that URL is on
the Collab landing page. The second connection is through MetaMask,
which injects the <code>window.ethereum</code> object, and Web3.js can
just connect via that.</p>
<p>The reason we are doing two connections is because the first one
supports subscriptions, which is what allows the table to be updated
upon an event emission – you did that in the <a
href="../daoweb3/index.html">DAO &amp; web3</a> (<a
href="../daoweb3/index.md">md</a>) assignment, and the auctions.php does
that as well. However, that first connection does not allow sending
transactions to the blockchain. The second connection, which is through
MetaMask, does not support subscriptions (so no automatic updating of
the tables), but does allow sending transactions to the blockchain.</p>
<p>As both are wrapped in the Web3 constructor, they operate the same
way.</p>
<p>As a general rule, any one Javascript function should use only one of
those connections. If you are sending transactions to the blockchain,
you have to use the <code>web3mm</code> one. Otherwise, use the
<code>web3</code> one. As you will only have four functions that send
transactions to the blockchain, only those four will use
<code>web3mm</code>.</p>
<h5 id="html-and-javascript">HTML and Javascript</h5>
<p>Below is an example HTML form and associated Javascript function.
This will call the <code>mintNFT()</code> function on your smart
contract.</p>
<pre><code>&lt;script&gt;
  const mintNFT = async() =&gt; {
    try {
      const eth_coinbase = await web3mm.eth.getCoinbase();
      var str = document.getElementById(&#39;nftstring&#39;).value;
      await auctionContract.methods.mintNFT(str).send({from:eth_coinbase, gas:1000000, gasPrice:100000000000});
      const nftid = await auctionContract.methods.lastMintedNFT(eth_coinbase).call();
      const nfturi = await auctionContract.methods.tokenURI(nftid).call();
      window.alert(&quot;NFT ID: &quot;+nftid+&quot;\n&quot;+ntfuri);
    } catch (error) {
      console.error(error);
    }
  }
&lt;/script&gt;

&lt;form onsubmit=&#39;return false;&#39;&gt;
  &lt;p&gt;NFT URI / string: &lt;input type=&#39;text&#39; id=&#39;nftstring&#39;&gt;&lt;/p&gt;
  &lt;input type=&#39;button&#39; value=&quot;mint!&quot; onClick=&quot;mintNFT();&quot;&gt;
&lt;/form&gt;</code></pre>
<p><img src="metamask-confirmation.webp" style="float:right;border:1px solid black"></p>
<p>There is a lot going on here, and you will need to understand it in
order to be able to adapt it for the other function calls that you need
to make.</p>
<ul>
<li>Notice that we are using the <code>web3mm</code> connection, since
we are connecting through MetaMask.</li>
<li>We define the <code>mintNFT()</code> function which is an
<code>async</code> function; <code>async</code> functions were described
in the <a href="../daoweb3/index.html">DAO &amp; web3</a> (<a
href="../daoweb3/index.md">md</a>) assignment. Note that while this
function has the same name as the <code>mintNFT()</code> function in the
smart contract, they are still different functions.</li>
<li>One way to deal with <code>async</code> functions is to give it a
code block to execute when the function returns. The other is to force
it to wait until the <code>async</code> function returns. We chose the
latter here by putting the <code>await</code> keyword in front of the
various <code>async</code> calls in that function. Note that
<code>await</code> can ONLY be called in an <code>async</code> function
(and in one other situation that does not apply to us here); this is a
Javascript restriction. Note that any variable that you
<code>await</code> for a value for must be a <code>const</code>.</li>
<li>To get the user’s coinbase account address, we call <code>await
web3mm.eth.getCoinbase();</code> – that’s the account they are logged
into using MetaMask.</li>
<li>The <code>auctionContract.methods.mintNFT(str)</code> line is where
the transaction itself occurs. You will notice that this uses
<code>send()</code>, not <code>sendTransaction()</code>. So this is
similar to the <a href="../../docs/geth_reference.html">geth commands we
know</a> (<a href="../../docs/geth_reference.md">md</a>), but just
different enough to drive us up the wall learning a slightly different
syntax for how to call the transaction.</li>
<li>For this assignment, keep the gas at 1 million and the gas price at
10 gwei (which is 10000000000 wei); yes, this is a lot of gas, but since
our ETH is free, we aren’t worried about it.</li>
<li>Looking at the form, we see that the text box has an ID of
<code>nftstring</code> (3rd line from the bottom). The
<code>document.getElementById('nftstring').value</code> gets the value
currently typed into the text box.</li>
<li>After <code>await</code>ing for the various function calls, we then
display the results via an alert box: <code>window.alert("NFT ID:
"+nftid+"\n"+ntfuri);</code>. A full fledged website would have a better
UI for displaying this, but an alert box is sufficient for us. We assume
the user will remember his/her NFT ID, and we do not have to handle the
case when they forget it.</li>
<li>We put everything into a try-catch clause, as this will allow
printing out of the error if one occurs. You can view that in the
Javascript developer console.</li>
<li>In the form, you will notice that the form tag has the value
<code>onsubmit='return false;'</code>. We want this entire web page to
do all the work, and we are not submitting a form (which will reload the
page). This clause prevents form submission from hitting Enter in the
text box.</li>
<li>Also in the form, the button has <code>onClick="mintNFT();"</code>
which will launch the <code>mintNFT()</code> Javascript function when it
is clicked.</li>
<li>If you are familiar with HTML, you will notice that there is no
<code>submit</code> button, as we do not want the form to be submitted
(and cause a reload). If you are not familiar with HTML, and don’t know
what that means, you can ignore this bullet point.</li>
</ul>
<p>When this function is called, MetaMask will pop up a window, such as
what is shown to the right, to verify that you really want to send that
transaction. This happens on the
<code>auctionContract.methods.mintNFT(str)</code> line, since that’s the
only line that is <em>sending</em> a transaction; the others are only
doing read-only calls. You will have to click ‘confirm’ for the
transaction to be sent to the blockchain.</p>
<p>Once it is confirmed, it will take a second or so for the transaction
to reach the P2P network, and then a second or two for it to be
auto-mined into the blockchain. However, MetaMask can take a while (5-10
seconds) to realize that the transaction has occurred. So it can easily
take 10 seconds for the pop-up window to appear. <br clear='all'></p>
<h3 id="the-task">The Task</h3>
<p>Finally! We can get to the whole reason for this party.</p>
<p>Your task is to create a web interface to your <a
href="../auction/AuctionManager.sol.html">Auctioneer.sol</a> contract.
MAKE SURE IT’S THE UPDATED VERSION (that you developed above)! That
updated version was discussed in the “Setup: NFTmanager” section,
above.</p>
<p>As you are starting with the web site that was provided to you in the
<a href="../auction/index.html">dApp Auction</a> (<a
href="../auction/index.md">md</a>) assignment, the read-only parts of
this assignment are already done for you. You will have to change the
contract ID, of course – you should hard-code that into your HTML /
Javascript code (just replace the one that is there).</p>
<p>For this assignment, you only need to create an interface with four
of your functions – <code>createAuction()</code>,
<code>closeAuction()</code>, <code>placeBid()</code>, and
<code>mintNFT()</code>. And the interface for <code>mintNFT()</code> was
provided for you, above. In particular, you do NOT have to create an
interface for <code>cancelAuction()</code>. We discussed how to create a
HTML form interface, and the Javascript code to make it work, above.</p>
<p>The forms for those three functions should be on that same page – in
particular, you will only be submitting one page, called
<code>auctions.html</code> (note the plurality of the filename!). You
can put those forms on the bottom, along with the MetaMask connect
button described above. As with the <a href="../daoweb3/index.html">DAO
&amp; web3</a> (<a href="../daoweb3/index.md">md</a>) assignment, since
this is not a course in user interfaces, it will not be graded on it’s
beauty. But it still has to be usable.</p>
<p>Any calls to the first three functions (<code>createAuction()</code>,
<code>closeAuction()</code>, <code>placeBid()</code>) will have that
change reflected in the table of auctions, which will automatically
update when an event is emitted. When <code>mintNFT()</code> is called,
it performs the transaction and then perform a web3.js call to get the
NFT ID. It just displays that ID via a popup alert box.</p>
<p>When this assignment is complete, anybody should be able to create
NFTs, initiate auctions, bid on existing auctions, and close auctions
when they are done. As for the NFT images, we will still provide just a
file name, and the URL prefix will be the same Collab link as in the <a
href="../tokens/index.html">Ethereum Tokens</a> (<a
href="../tokens/index.md">md</a>) assignment; that prefix is on the
Collab landing page.</p>
<!--

### Calling a smart contract function

Unlike web3.js, it's more difficult (read: annoying) to call a function via MetaMask.  Consider this Javascript code from the [MetaMask page on sending transactions](https://docs.metamask.io/guide/sending-transactions.html#example):

```
const transactionParameters = {
  nonce: '0x00', // ignored by MetaMask
  gasPrice: '0x09184e72a000', // customizable by user during MetaMask confirmation.
  gas: '0x2710', // customizable by user during MetaMask confirmation.
  to: '0x0000000000000000000000000000000000000000', // Required except during contract publications.
  from: ethereum.selectedAddress, // must match user's active address.
  value: '0x00', // Only required to send ether to the recipient from the initiating external account.
  data:
    '0x7f7465737432000000000000000000000000000000000000000000000000000000600057', // Optional, but used for defining smart contract creation and interaction.
  chainId: '0x3', // Used to prevent transaction reuse across blockchains. Auto-filled by MetaMask.
};

// txHash is a hex string
// As with any RPC call, it may throw an error
const txHash = await ethereum.request({
  method: 'eth_sendTransaction',
  params: [transactionParameters],
});
```

This is the Javascript code that will have to be run, in some function that you define, in order to execute a transaction.  MetaMask has already connected to the blockchain and unlocked the account, so you can directly make the transaction as shown above.

For this assignment:

- `nonce`: MetaMask ignores this, so just putting `0x00` is fine
- `gasPrice`: We are going to use a fixed 10 gwei, like we did in the [Arbitrage trading](../arbitrage/index.html) ([md](../arbitrage/index.md)) assignment.  10 gwei is $10 \ast 10^{18}$ wei, which is 0x2540be400 in hex.
- `gas`: Since our (fake) ETH is free, you can put a large value, such as 100,000 here (which is 0x186a0 in hex).  In practice we would perform a gas estimate, like we did in the [Arbitrage trading](../arbitrage/index.html) ([md](../arbitrage/index.md)) assignment.
- `to`: That's your smart contract's address.
- `from`: That's obtained from the MetaMask extension, and the `ethereum.selectedAddress` will do that for you.
- `value`: How much ether, expressed in wei, you are sending in with this function call.  Note that this must also be in hex!
- `data`: This is the hex code to call the function on the smart contract.  How to encode that is described in the [function call encoding tutorial](../docs/function_call_encoding.html) ([md](../docs/function_call_encoding.md)).
- `chainId`: Apparently filled in by MetaMask, but the value for our course chain is on the Collab landing page.

Once those parameters are set correctly, the last four lines in the above code will call that function.

-->
<h3 id="troubleshooting">Troubleshooting</h3>
<ul>
<li>“Invalid sender” error when you are submitting a transaction: while
there are lots of things that could cause this, you will want to check
that your chain ID is set correctly. Click on the MetaMask fox icon
(<img src="metamask-fox.svg" style="max-height:20px;vertical-align:middle">),
then the circular account icon in the top right
(<img src="metamask-account-icon.webp" style="max-height:20px;vertical-align:middle">,
although your may look different), then Settings, then Networks, then
click on the “localhost:8545” network. Make sure the chain ID is set
correctly; it’s on the Collab landing page, if you forget what it is. It
should be set using it’s base-10 value.</li>
</ul>
<h3 id="submission">Submission</h3>
<p>There are <em>four</em> forms of submission for this assignment; you
must do all four.</p>
<p>Submission 1: You should submit just your <code>auctions.html</code>
contract to Gradescope. In particular, you are NOT submitting any
Solidity code for this assignment. <strong>NOTE:</strong> Gradescope
cannot fully test this assignment, as it does not have access to the
private blockchain. So it can only check that the right file has been
submitted.</p>
<p>Submission 2: You must deploy your Auctioneer smart contract (and
likely your NFTmanager smart contract) to our private Ethereum
blockchain. It’s fine if you deploy it a few times to test it.</p>
<p>Submission 3: You need to start a few auctions. Mint some NFTs, start
some auctions.</p>
<p>Submission 4: You will need to submit your information via a Google
form, the link to which is on the Collab landing page.</p>
</body>
</html>
